<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Shader学习笔记 | Tamsiree</title><meta name="keywords" content="GameEngine,Unity,Shader"><meta name="author" content="Tamsiree,tamsiree.com@gmail.com"><meta name="copyright" content="Tamsiree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言这里是前言介绍。 正文一口气解决RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend和Stencil知道吗，如果只是想要实现Xray效果的话，其实并不难。   实现上图的效果，原理就是对角色画两次。第一次是被遮挡住的效果(半透明、单色)，第二次是正常的效果(为了简化这里使用unlight只显示贴图) 这两个pass最大的区别，在于使用不同的Ztest(深度">
<meta property="og:type" content="article">
<meta property="og:title" content="Shader学习笔记">
<meta property="og:url" content="https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Tamsiree">
<meta property="og:description" content="前言这里是前言介绍。 正文一口气解决RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend和Stencil知道吗，如果只是想要实现Xray效果的话，其实并不难。   实现上图的效果，原理就是对角色画两次。第一次是被遮挡住的效果(半透明、单色)，第二次是正常的效果(为了简化这里使用unlight只显示贴图) 这两个pass最大的区别，在于使用不同的Ztest(深度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg">
<meta property="article:published_time" content="2021-12-26T16:34:43.000Z">
<meta property="article:modified_time" content="2024-09-25T07:07:27.983Z">
<meta property="article:author" content="Tamsiree">
<meta property="article:tag" content="GameEngine">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png"><link rel="canonical" href="https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Tamsiree","link":"链接: ","source":"来源: Tamsiree","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Shader学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-25 15:07:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8688374801147098" crossorigin="anonymous"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Tamsiree" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">137</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">139</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tamsiree</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Shader学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-26T16:34:43.000Z" title="发表于 2021-12-27 00:34:43">2021-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-25T07:07:27.983Z" title="更新于 2024-09-25 15:07:27">2024-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GameEngine/">GameEngine</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GameEngine/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GameEngine/Unity/Shader/">Shader</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Shader学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一口气解决RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend和Stencil"><a href="#一口气解决RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend和Stencil" class="headerlink" title="一口气解决RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend和Stencil"></a>一口气解决RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend和Stencil</h2><p><strong>知道吗，如果只是想要实现Xray效果的话，其实并不难。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-8d07b211268f64c663515a011b1bca14_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-8d07b211268f64c663515a011b1bca14_720w.jpg"></p>
<p><em>实现上图的效果，原理就是对角色画两次。第一次是被遮挡住的效果(半透明、单色)，第二次是正常的效果(为了简化这里使用unlight只显示贴图)</em></p>
<p><strong>这两个pass最大的区别，在于使用不同的Ztest(深度测试)。但是这一次我决定不仅仅只写关于Ztest的问题。反正我已经决定对抗懒癌晚期，那就干脆一口气把RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend、StencilTest这些烂七八糟的东西都拎出来写一遍,因为这些东西有很多地方都是相通的，一起说明白反而省些力气。</strong></p>
<p><strong>不过说实话，这些东西确实是有点麻烦。我尽自己最大的努力去把这些东西说明白。但是鉴于个人能力实在有限，如果有哪里说得不对或者不清楚，还请见谅。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-0ba75819a33e8c1362a2b9f61677c92d_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-0ba75819a33e8c1362a2b9f61677c92d_720w.jpg"></p>
<p><em>如上图，现在有三个多边形分别是红色盒子绿色盒子和蓝色盒子，在镜头里红色的盒子在最前面（距离摄像机最近），所以盖住了其他两个颜色的盒子。</em></p>
<p><strong>按照我们的生活常识，显示最前面的红盒子这样的结果是再正常不过了。可是计算机并不存在所谓的“人类的常识”，它只依靠数学的方法去处理问题。而如何判断谁在前谁在后，这个问题却并非那么简单，并且很容易让人陷入混乱。因为这牵扯到Ztest(深度测试)ZWrite(深度写入或者叫深度缓存)和RenderQueue(渲染序列)。</strong></p>
<p><strong>如果是2D的话，只需要一个Zindex就可以确定Sprite之间的前后(覆盖)关系。RenderQueue(渲染序列)和这个Zindex的概念很像，都是直截了当指定了一个渲染的顺序。 关于RenderQueue可用的标签，有：</strong></p>
<p><strong>Background:1000</strong></p>
<p><strong>Geometry:2000</strong></p>
<p><strong>AlphaTest:2450</strong></p>
<p><strong>Transparent:3000</strong></p>
<p><strong>Overlay:4000</strong></p>
<p><strong>(写起来的样子是这样的：”Queue” = “TransParent”)</strong></p>
<p><strong>数字越大的物体，其渲染顺序就越靠后，就会遮住数字小的物体。从名字里也能看得出来，BackGround自然是那种最先渲染然后被所有东西覆盖掉的东西(比如天空盒)。而像Overlay这样的东西在绝大部分物体之后渲染，适合用来制作UI。</strong></p>
<p><strong>值得注意的是半透明物体(Transparent Objects)的渲染顺序十分靠后。一般情况下是在所有非半透明物体渲染之后，再渲染半透明物体。至于其原因等稍后再说明。</strong></p>
<p><strong>除了使用默认的标签之外，还可以更详细指定渲染序列，写起来大概是这样的: “Queue” = “Geometry+1” 。这样这个物体会在所有Geometry渲染之后再渲染，顺序增加了一个“身位”。如果是”Queue” = “Geometry+5000” ，那可就是比Overlay还靠后，绝对是最最后渲染的东西，理论上覆盖在一切东西之上。</strong></p>
<p><strong>听起来似乎很简单，好像我们已经拿到了一把万能钥匙，可以随意控制那个小小3D世界里的所有一切。然而进度条告诉你事情并没这么简单（雾）。</strong></p>
<p><strong>因为显卡既不允许你用这么简单粗暴的方式控制渲染结果，实际上你也没法用简单的Queue值来确定物体渲染的前后关系。</strong></p>
<p><strong>试想一个大场景里动辄成千上万的物体，你如何去一个一个指定他们的RenderQueue？即便你真的这么做了，一旦镜头转个180°是不是就全错了？更不要提每一帧都在变换位置的角色。就是神仙也不可能预知他们所处的位置到底应该是渲染序列的哪一个位置。</strong></p>
<p><strong>这一点和2D游戏有着本质上的区别。在2D游戏里指定ZIndex的做法在3D游戏里肯定是走不通的。</strong></p>
<p><strong>所以在大多数情况下(除了制作UI和天空盒之外)，这个RenderQueue并没有什么卵用。我用几张图来具体说明。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-b7ff915181dbe3835625eb19b7569f7e_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-b7ff915181dbe3835625eb19b7569f7e_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-8587a7b0b06c6d07818682107106aea7_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-8587a7b0b06c6d07818682107106aea7_720w.jpg"></p>
<p><em>如上图，正常情况下这三个盒子都是”Queue” = “Geometry”。因为是“正常情况”，所以显示的效果肯定是正确的(红色的盒子挡住其他两个，同时绿色盒子挡住蓝色盒子)。但是打开FrameDebugger你会发现，渲染的顺序是很混乱的。也许是因为做测试的时候改动过RenderQueue。现在莫名其妙的是先中间后两边。</em></p>
<p><strong>关于非透明物体渲染的排序问题，我在这里多说两句。3D实时渲染性能消耗的两个重要部分是CPU和GPU。如果想节省GPU的时间，就要在渲染之前计算一次渲染顺序，这样在Ztest之后就，被遮挡的部分就不会进入fragment shader；反之想要解放CPU的负担，就不要对渲染物体进行排序(排序这个东西大家都懂的)。当然这样会多次渲染被遮挡的像素。</strong></p>
<p><strong>在Unity3d文档里，我找到了关于控制非透明物体渲染顺序的API，其描述如下:</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-a4d69c1236e4e1f51e8346871b4900ab_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-a4d69c1236e4e1f51e8346871b4900ab_720w.jpg"></p>
<p><em>在我的印象当中以前是没有Camera.opaqueSortMode这个东西的，估计是新版本后加入的(我的5.4.0版本已经比较老了)。大家可以根据自己游戏性能的考虑去做优化。</em></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-b7ff915181dbe3835625eb19b7569f7e_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-b7ff915181dbe3835625eb19b7569f7e_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-b7aa162382d592cbd95b50b0d2d47f9e_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-b7aa162382d592cbd95b50b0d2d47f9e_720w.jpg"></p>
<p><em>如上图，当我们强行让绿色盒子的RenderQueue发生改变(“Queue”=”Geometry+1”)，这样绿色盒子的渲染序列变为最后渲染，然而实际的效果依然没有改变，红色盒子一如既往地盖住了绿色盒子(哪怕红色盒子是在绿色盒子之前就渲染出来的)。</em></p>
<p><strong>RenderQueue之所以只决定了物体的渲染顺序，却没能决定物体的渲染结果，是因为显卡在渲染的时候，更多的是依靠深度测试(Ztest)来进行判断。</strong></p>
<p><strong>Ztest的工作原理是这样的(假设这3个盒子是屏幕上的3个像素点)：</strong></p>
<p><strong>Step1：显卡按照渲染顺序先画出了蓝色盒子的像素(渲染的每一个步骤都可以在FrameDebugger里看到，真是方便)</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-13688250bfcb137b4c402b4c68b3223b_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-13688250bfcb137b4c402b4c68b3223b_720w.jpg"></p>
<p><strong>在画蓝色盒子的像素的时候，除了RGB三个颜色的值以外，显卡还会把这个像素与当前镜头的距离记录下来(这里记录为z1)。与背景相比，蓝盒子显然距离镜头更近，即z1&lt;∞。按照“默认”的做法(注意在这个例子里我一直强调是在“默认”的情况，或者“默认”的做法)，画出蓝色的盒子，并且将摄像机在这个像素上的深度值替换为z1。</strong></p>
<p><strong>Step2:接下来按照渲染顺序，开始渲染红色的盒子。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-f014923f3185f969480655821527fcbd_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-f014923f3185f969480655821527fcbd_720w.jpg"></p>
<p><strong>当然红色盒子也有一个深度值(记录为z2)。这个时候显卡会用z2和摄像机在当前像素的深度值z1进行比较，发现z2&lt;z1(因为红色盒子距离镜头比较近)。于是按照“默认”的做法画出红色的盒子，并且将摄像机当前像素值更新为z2。</strong></p>
<p><strong>Step3：接下来按照渲染顺序，开始渲染绿色的盒子。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-c85bf90a5658ecc2d4ce177980bc2170_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-c85bf90a5658ecc2d4ce177980bc2170_720w.jpg"></p>
<p><em>虽然这张图和上一张很像，但是注意这个时候渲染的是被“神隐”的绿色盒子</em></p>
<p><strong>当渲染绿色盒子的时候，情况就发生了变化。我们知道绿色盒子之所以最后渲染，是因为我们强行改变了绿色盒子的渲染顺序(“Queue” = “Geometry+1”)。但是绿色盒子距离摄像机的距离是大于红色盒子的。</strong></p>
<p><strong>所以当渲染绿色盒子的时候，其深度值(记录为z3)必然会比当前像素的深度值z2大(z3&gt;z2，和上一步完全相反的情况)。于是显卡按照“默认”的做法，扔掉了绿色盒子的像素，并且保持当前像素值为z2。其结果就是看起来绿色盒子完全被红色盒子遮挡住了(哪怕它是最后渲染出来的物体)。</strong></p>
<p><strong>这一套流程走下来我们不难看出，所谓“默认”的工作原理(注意我再次强调是“默认”)，就是当一个物体像素的z值小于当前镜头在该位置像素的深度值时，画出该物体的这个像素，并且将这个较小的z值更新为当前镜头在这个像素上的深度值。</strong></p>
<p><strong>反之，当一个物体的像素的z值大于当前镜头在该位置像素的深度值时，不画出该物体的这个像素，并且保留摄像机在这个像素上的深度值。</strong></p>
<p><strong>说起来实在是拗口，也不知道各位是否能看明白。反正我是尽力了。如果非要打个比方来说，我想和当初学C语言的时候进行数字排序的做法差不多。不知道各位同学是不是看起来很怀念呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>],i,j,temp;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入十五个整数：&quot;</span>);  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="number">15</span>;j++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">&#123;</span><br><span class="line">temp=a[j]；</span><br><span class="line">a[j]=a[i]；</span><br><span class="line">a[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的数是：%d&quot;</span>,a[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>而这个工作流程，就是所谓的Ztest+Zwrite。</strong></p>
<p><strong>比较新旧z值的大小，就是Ztest;之后更新摄像机每一个像素的z值，就是Zwrite。Ztest影响的是当前物体的显示；Zwrite影响的是之后渲染物体的显示。</strong></p>
<p><strong>可以看出来如果不进行Zwrite更新镜头的z值，那么Ztest的时候就会出现不正常的结果(完全不知道前面渲染出来的物体的深度，只能完全依赖RenderQueue)；而Zwrite是否更新摄像机在当前像素上的z值，根据两个条件：</strong></p>
<p><strong>一是要看是否允许进行Zwrite（默认是Zwrite On。当然很多时候我们会手动关掉Zwrite,即Zwrite Off）；二是要看Ztest是否通过，只有通过了ZWrite才会更新新的z值。</strong></p>
<p><strong>请务必注意这里：z值是否更新并不在于物体在该像素上的z值比摄像机在该像素上的z值小。而在于是否通过Ztest。只不过在默认的情况下，通过Ztest的条件是小于等于。如果Ztest的条件改变，那么Zwrite写入的新值就未必比原来的值小(关于Ztest的条件马上就会提到)。</strong></p>
<p><strong>Zwrite的概念相对简单，无非就是根据条件，对一个变量进行反复地赋值。比较有意思的Ztest。在三个盒子的例子里，我一直都在强调“默认”两个字。那么默认是什么呢，就是Zwrite On + Ztest On。Zwrite就两种情况(On或者Off)。而对于Ztest来说，条件就要丰富得多得多。Ztest的条件总共有如下几种:</strong></p>
<p><strong>Less (当物体的这个像素的Z值小于当前摄像机在这个像素上的Z值，则通过Ztest)</strong></p>
<p><strong>LEqual(条件变为小于等于)</strong></p>
<p><strong>Greater(条件变为大于)</strong></p>
<p><strong>GEqual(条件变为大于等于)</strong></p>
<p><strong>Equal(条件变为相等)</strong></p>
<p><strong>NotEqual(条件变为不相等)</strong></p>
<p><strong>Always(Ztest永远通过)</strong></p>
<p><strong>Never(Ztest永远不通过)</strong></p>
<p><strong>Off(等同于 ZTest Always)</strong></p>
<p><strong>On(等同于ZTest LEqual)</strong></p>
<p><strong>ZTest LEqual也就是上面一直提到的“Ztest默认工作的原理”。当不写明Ztest的处理方式的时候，ZTest的通过条件LEqual。因此我们就总能看到距离摄像机近的物体(Z值小)盖住了距离摄像机远(Z值大)的物体，这样“理所当然”的效果。</strong></p>
<p><strong>有意思的是当我们相要搞些事情的时候，就可以利用ZTest那些非默认的选项。当物体被遮挡住的时候(即Ztest Greater),原本是看不见的。但是Xray的效果不就正是要看见原本看不见的东西么？</strong></p>
<p><strong>所以Xray效果的第一个pass。我使用以下的“黑科技”:</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-5b06b29a38f18c138126a2f21c14ac52_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-5b06b29a38f18c138126a2f21c14ac52_720w.jpg"></p>
<p><em>Blend SrcAlpha OneMinusSrcAlpha说明我们要用alpha blend的方式进行渲染(关于Alpha Blend后面会提到)。Ztest Greater意味着我就是要处理z值大于摄像机z值的情况(只有在别的物体后面z值才会比较大，也就是说只有实际上被别的物体挡住的时候，才会用这种方式渲染)。同时关掉Zwrite。</em></p>
<p><strong>关闭Zwrite是比较重要的一步，开着Zwrite会把错误的z值(比较大的z值)更新上去。正如前面特别强调的，Zwrite的条件之一是通过Ztest。这一次Ztest的条件是Greater，所以通过Ztest以后z值是比原来大的，更新上去以后会对其他物体的深度判断造成影响，关于这一点我们马上举例说明。</strong></p>
<p><strong>第一个pass效果如下:</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-7698ec0e7c14466964a68304e5729ef9_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-7698ec0e7c14466964a68304e5729ef9_720w.jpg"></p>
<p><em>我们看到，Z值比较小的像素(即未被遮挡住的像素)，反而因为没有处理Ztest Lequal的Pass而无法显示出来。</em></p>
<p><strong>接下来就是第二个Pass。我们使用新的Ztest条件：</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-d9bcb63d4b5c7f646f06a5447b923e76_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-d9bcb63d4b5c7f646f06a5447b923e76_720w.jpg"></p>
<p><strong>其实这就是刚才我们一直所说的“默认情况”。换句话是其实Zwrite On 和 ZTest LEqual完全可以不用写。效果如下：</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-8d07b211268f64c663515a011b1bca14_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-8d07b211268f64c663515a011b1bca14_720w.jpg"></p>
<p><strong>那么问题来了，如果我们在第一个pass中打开Zwrite会出现什么结果呢？</strong></p>
<p><strong>第一个Pass打开Zwrite的效果如下:</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-d91e5808b6bc4abe5b2be91c064a1888_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d91e5808b6bc4abe5b2be91c064a1888_720w.jpg"></p>
<p><strong>无论是否被遮挡，人物都会显示成Pass2的效果（而且还有明显得错误）。</strong></p>
<p><strong>我们利用刚才获知的原理来分析一下。在Pass1通过Ztest之后，因为打开了Zwrite，所以将角色在Pass1阶段渲染出来的像素的深度值写入到屏幕当前的深度值。注意这个深度值是大于墙的像素的深度值的，但是依然被写进镜头的深度当中。</strong></p>
<p><strong>当来到Pass2时，Ztest的条件是LEqual(小于等于)。因为当前摄像机中该像素的深度值就是角色身上像素的深度(因为上一步通过Zwrite已经写入)。所以完全符Equal(相等)的条件。于是Pass2的像素成功通过ZTest并被画出来，Pass1画出的像素自然就被Pass2覆盖掉了。</strong></p>
<p><strong>有兴趣的朋友也可以在Pass2中试一试，当Ztest的条件是Less的时候会出现什么效果。这里就不一一举例了。</strong></p>
<p><strong>以上是关于ZTest、Zwrite和RenderQueue三个容易产生混乱的概念。下面又是一个类似的概念：Stencil（模板）。</strong></p>
<p><strong>Stencil和深度一样，是写进buffer里的一个数值(Z buffer和Stencil Buffer这两个词你应该听过很多次了)。</strong></p>
<p><strong>Stencil的工作原理和Ztest+Zwrite很相似，但是灵活性更高一些。关于Stencil的一些具体例子和讲解，网上有很多。我这里的重点就不放在实际例子上，而是关于模板和深度这两个东西在用法和原理上的异同。</strong></p>
<p><strong>关于Ztest+Zwrite我已经提到过很多次了，最简单的理解就是“比较”+“写入”。如果你真的对其原理理解得非常好，那么搞定Stencil就没有任何问题。</strong></p>
<p><strong>在Unity3D里面并不存在“Stencil Test”和“Stencil Write”这两个字眼儿。Stencil就是一个过程，同时包含了“比较”和“写入”两个步骤。</strong></p>
<p><strong>Stencil的完整语法：</strong></p>
<p><strong>stencil{</strong></p>
<p><strong>Ref referenceValue</strong></p>
<p><strong>ReadMask readMask</strong></p>
<p><strong>WriteMask writeMask</strong></p>
<p><strong>Comp comparisonFunction</strong></p>
<p><strong>Pass stencilOperation</strong></p>
<p><strong>Fail stencilOperation</strong></p>
<p><strong>ZFail stencilOperation</strong></p>
<p><strong>}</strong></p>
<p><strong>具体详尽的用法写起来太麻烦(我实在是怕麻烦怕得要死)，我就稍微总结一下：总的来说你只要关注Ref\Comp\Pass三个关键词。再稍微复杂一点儿的情况，你可能需要用到Fail\Zfail。最后在需要更复杂的判断的时候，你也许会需要用到那两个Mask。</strong></p>
<p><strong>我们再回顾一下Ztest+Zwrite的原理。获取Z值-&gt;测试(比较)Z值-&gt;写入新的Z值(如果通过测试)。</strong></p>
<p><strong>我们假定Stencil也有一个值叫Ref值。那么Stencil的用法也实在是看着眼熟：获取Ref值-&gt;测试(比较)Ref值-&gt;写入新的Ref值(如果通过测试)。</strong></p>
<p><strong>说到底这俩玩意儿的区别，就是在第一步，获取当前物体在这个像素上的这个变量。</strong></p>
<p><strong>Z值是根据像素到摄像机的距离算出来的，不会因为你的个人意愿而改变；S值是你可以随便填的(是的随便填，想写几就写几，范围0-255)。</strong></p>
<p><strong>这样一来Stencil可以帮助你突破Ztest所带来的限制，用更灵(jian)活(dan)便(cu)捷(bao)的方式来控制渲染效果。</strong></p>
<p><strong>Ref就是写入这个像素的Ref值，正如我之前提到的想写几就写几完全看心情(所以我一直都认为叫Stencil Buffer模板缓冲实在是有点唬人的感觉。改成“看哪个数字顺眼就用哪个数字比大小”更贴切一些)。</strong></p>
<p><strong>Com是进行Test的条件，当你看到一大堆Less\LEqual\Greater\GEqual\Equal\NotEqual\Always\Never这样的字眼儿，是不是感到非常的眼熟？这一步比较的过程和Ztest完全一样。</strong></p>
<p><strong>Pass和Zwrite简直就是一个妈生出的俩个孩儿。区别就是这个小哥比他兄弟花样儿多点。Zwrite无非就是写入或者不写入(On or Off)。Pass甚至还可以控制如何写入(虽然大多数情况下可能用不到)。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-efbed4ee6525cab050651da10572b817_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-efbed4ee6525cab050651da10572b817_720w.jpg"></p>
<p><em>Pass支持的条件一览，其中Keep类似于Zwrite里的Off;Replace类似于ZWrite里的On(此图来自互联网)。</em></p>
<p><strong>举个栗子，如下图所示，现在有一面墙和一个茶壶，按照与镜头的位置关系，墙体遮挡住茶壶的下半部分。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-b12d128a7157f7caf317d7999d80380b_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-b12d128a7157f7caf317d7999d80380b_720w.jpg"></p>
<p><strong>如果我们想要做一个如Flash里的Mask Layer效果。就可以使用Stencil来做。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stencil </span><br><span class="line">&#123;</span><br><span class="line">    //摄像机在当前像素的默认stencil值是0</span><br><span class="line">    //设置当前物体当前像素的参考值为100</span><br><span class="line">    Ref 100 </span><br><span class="line">    //永远通过stencil测试</span><br><span class="line">    //这个shader的唯一目的就是在这个物体所占的像素上写入stencil值100</span><br><span class="line">    Comp Always</span><br><span class="line">    //通过后(因为Comp Always所以必然会通过),将当前stencil值更新为ref的值(100)</span><br><span class="line">    Pass replace</span><br><span class="line">    //这样墙所占有的像素的Stencil值就被确定下来了</span><br><span class="line">    //如果有多个墙,也可以用Comp GEqual或者Comp LEqual</span><br><span class="line">    //来找一个最大/最小的stencil值作为当前像素的stencil值</span><br><span class="line">&#125;</span><br><span class="line">Zwrite Off </span><br></pre></td></tr></table></figure>

<p><strong>注意墙的深度缓冲要关掉，否则茶壶在做Ztest的时候会因为遮挡关系而被弃掉像素。</strong></p>
<p><strong>接着是茶壶的shader:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stencil </span><br><span class="line">&#123;</span><br><span class="line">	//像素默认的stencil值应该是0</span><br><span class="line">	//设置茶壶在当前像素的参考值为90</span><br><span class="line">	Ref 90</span><br><span class="line">	//因为之前墙的ref值100已经写入到摄像机里,所以当前像素的ref值已经是100</span><br><span class="line">        //因为茶壶的Ref值（90）小于当前摄像机在该位置的像素的ref值100，测试通过</span><br><span class="line">	Comp LEqual</span><br><span class="line">	//通过后,不更新ref值</span><br><span class="line">	Pass keep</span><br><span class="line">	//这样墙在该像素上的Stencil值(100)依然是摄像机在当前像素上的人ref值</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-b6d4f7bdce4ee7b56561149dac30f034_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-b6d4f7bdce4ee7b56561149dac30f034_720w.jpg"></p>
<p><em>茶壶被透明墙遮挡住的部分，因为其Stencil值通过测试，所以被显示了出来。</em></p>
<p><strong>当然这里存在一个潜在的问题。试想如果这两个非透明物体在渲染的时候，顺序并不是先画墙再画茶壶。其结果就会因为墙的ref值没有提前更新好，而造成了茶壶在比较的ref值的时候出现我们不期望的结果。所以说，虽然我们并没有太多注意过非透明物体的渲染顺序。但是这东西确实会在各种意想不到的地方，造成莫名其妙的显示错误。</strong></p>
<p><strong>最后就是Alpah Test 和 Alpha Blend。看到XXXTest是不是第一反应又是Test + Write这种东西。然后又是一堆Lequal、Gequal这些乱七八糟的条件。</strong></p>
<p><strong>好消息是这个世界上并不存在“Alpha Write”这种东西，并且Alpha Test也远没有之前那两个Test那么复杂；坏消息是你需要多了解一个新的概念——Alpha Blend,一个既麻烦又特别容易出问题的玩意儿。</strong></p>
<p><strong>首先一句话解决Alpha Test。与其他的Test概念相通的是：Alpha Test的运作原理也是当条件成立时，画出该像素，否则抛弃该像素。但是它的特点是无需(也无法)同镜头中同一个位置的其他像素值进行比较(自然更加无法进行写入)。</strong></p>
<p><strong>相对而言，其他的Test还需要跟别的东西比较一下，Alpha Test并不存在这个过程，它只和自己本身存在的变量进行比较，是一个非常自闭的过程。</strong></p>
<p><strong>因为AlpahTest有以上的特性，所以在Unity的shader里并没有Alpha Test On\Off这样的关键字。Alpha Test可用的函数只有两个，一个是clip一个是discard。clip(x)函数的变量x必须小于0才会通过测试。比如说简单粗暴的clip(-1)就把所有像素都干掉了；而用if(){discard;}可以使用任意条件触发。相对而言discard比较灵活，但是要用到if让我很不爽。这两个函数的具体用法大家可自行百度(好吧是我懒得贴)。</strong></p>
<p><strong>一般做渐变消失的时候，会用到clip\discard。比如下图</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-d83f5829ff843cbd471919d7f1a03b62_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-d83f5829ff843cbd471919d7f1a03b62_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-3b94cb2c6143c778c8200c79236721df_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-3b94cb2c6143c778c8200c79236721df_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-d61d607e1b5f0267261a5fd1cab3b0d4_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d61d607e1b5f0267261a5fd1cab3b0d4_720w.jpg"></p>
<p><em>把不断变化的时间值传入shader，来不断减小clip()函数的变量，就能做出如上的效果。当然这个效果还可以进一步改进，因为和本文无关所以就不展开了。需要注意的是在移动平台上，Alpha Test的消耗较大，属于能不用就不用的东西(就像if、for这些东西能不用尽量别用)。</em></p>
<p><em>如果你非要搞明白为什么简单粗暴的alpha test反而消耗大，就自己去查关于PowerVR GPUs、Deferred Tile-Based-Rendering、Early-Z等等这些知识点，对于我一个懒人来说搬运这些东西简直跟要了我的命没什么区别。</em></p>
<p><strong>Alpha Test是一个非黑即白的过程。通过或者不通过，画出或者抛弃，简单粗暴一目了然。当然我们大多数时候并不喜欢如此粗暴的处理，毕竟人不是机器，凡事还需要温柔一点。所以我们更多的时候用的是Alpha Blend而非Alpha Test。</strong></p>
<p><strong>Alpha Blend即透明混合。我们之前提到的所有Test方式，不是你盖住我就是我盖住你，总之没有任何“和谐共处”的可能性。而Alpha Blend提供了这种可能性。根据Blend的方式不同，该物体在这个像素的rgb值会和其他物体在这个像素上的rgb进行混合。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-42e0d0ff41ef2b67434b653bd8aed8e4_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-42e0d0ff41ef2b67434b653bd8aed8e4_720w.jpg"></p>
<p><em>Alpha Blend的效果，在一般意义上这就是我们理解的“半透明”。</em></p>
<p><strong>我们之前曾经提到过，半透明的物体(也就是需要用Alpha Blend方式渲染的物体)一般来说渲染序列比较靠后(通常我们用”Queue” = “Transparent”)。道理很简单，你要和别的像素混合，那么必须要有其他像素已经画出来才行。如果透明物体被提前渲染出来，而当时还不存在后面要跟它混合的像素，自然就会出现错误。</strong></p>
<p><strong>所以难怪只有Overlay这种做UI的物体，渲染顺序会排在Transparent之后——毕竟UI是不需要和场景中的半透物体进行混合。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-87f12e69afa888da3a5d7e8c87c2e028_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-87f12e69afa888da3a5d7e8c87c2e028_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-a658ce89bdb0b4f449be427f6ea3f85d_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-a658ce89bdb0b4f449be427f6ea3f85d_720w.jpg"></p>
<p><em>如图所示，当半透明物体(红色方形粒子)没有被指定渲染顺序为Transparent的时候，在混合天空盒的时候发生了明显错误。红圈是渲染粒子的部分，黑圈是渲染天空盒的部分。很明显在渲染粒子的时候，并没有渲染出来天空盒，所以也就没有混合(Blend)操作时可以用来混合的颜色。</em></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-ad239998df983e903dff334dff9f95fb_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-ad239998df983e903dff334dff9f95fb_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-e9da208c4b3cdae9044c33bfef0244df_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-e9da208c4b3cdae9044c33bfef0244df_720w.jpg"></p>
<p><em>当半透明的渲染顺序被正确指定为Transparent的时候，渲染天空盒发生在渲染粒子之前，也就是在画粒子的时候天空盒的像素就已经存在了。这样粒子就有了可以进行混合操作的颜色，因此半透明粒子与天空盒的混合效果正确。(说实话我很奇怪为什么Unity默认的天空盒渲染顺序居然不是BackGround，也许他们有他们自己的考虑吧。)</em></p>
<p><strong>注意在谈关于Alpha Blend的时候，几乎每一个细节都和RenderQueue息息相关。这和之前的Ztest完全不同。其区别在于Ztest只关心谁盖住了谁，一旦被盖住就不再在意被盖住的像素到底是个什么样;然而Alpha Blend却需要关注任何一个画在当前位置的像素颜色，只有获得这些颜色的全部信息，才可能进行正确的混合。这也是为什么Alpha Blend的消耗很大(因为所有在该像素上的物体都要进入fragment shader进行绘制)，而且常常会引发各种非常棘手的问题。</strong></p>
<p><strong>在写Unity Shader的时候，Alpha Blend有两个非常重要的语句：Zwrite Off和Blend的方式。</strong></p>
<p><strong>一般情况下我们渲染半透明物体的时候，都是Zwrite Off。</strong></p>
<p><strong>为什么一定是Zwrite Off？我们最开始说，只有打开Zwrite，才有可能进行“正确有效”的Ztest，否则所有关闭Zwrite的物体，其渲染将完全依赖于RenderQueue。</strong></p>
<p><strong>但是对于透明物体之间来说(注意是透明物体之间，而不是透明和非透明物体之间)，我们需要的恰恰是不要进行有效的Ztest——因为我们的初衷就是不能让“正确”的遮挡关系产生作用。试想如果透明物体之间因为Ztest判定了“正确”的遮挡关系，而造成部分像素被显卡丢弃不画，又怎么可能产生之后混合的过程呢？</strong></p>
<p><strong>而一旦放弃Zwrite。透明物体之间的Ztest其实都是统统通过的，换言之任何一个半透明物体的像素在与其他半透明物体的像素进行Ztest的时候，将不会被认为是需要弃掉不画的像素(我再次强调，因为RenderQueue的关系，所有谈到的东西都仅限于半透明物体之间)。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-2ffeff5b8aafb68d5e18c4896df5505b_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-2ffeff5b8aafb68d5e18c4896df5505b_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-95d494fdc777d4f6de2d925d69a755ed_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-95d494fdc777d4f6de2d925d69a755ed_720w.jpg"></p>
<p><em>来看这张图，注意粒子后面的角色和墙不一样，这个角色与粒子相同也是个半透明的物体。当Zwrite On的时候，整个渲染过程是先画了方块形的粒子(Draw Dynamic)，再画的绿色的角色(那三个Draw Mesh)。当开始绘制角色的时候显卡做了Ztest，其判定这个角色被粒子遮挡住，所以像素并没有画出来。</em></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-cc292be9f408d0df9f7884f365627891_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-cc292be9f408d0df9f7884f365627891_720w.jpg"></p>
<p><em>当Zwrite Off以后，注意这个时候依然是先画出粒子再画出角色，在角色做Ztest的时候，被判定并没有被粒子遮挡(因为粒子的深度信息并没有写入，角色像素的Z值小于等于当前摄像机在当前像素上的Z值)，所以角色的像素被绘制出来，并且与粒子的颜色进行了正常的混合。</em></p>
<p><strong>你可能会问为什么墙不会被挡住，因为墙是”Queue” = “Geometry”，作为一个渲染序列靠前的物体，在画粒子的时候其像素就已经存在了。</strong></p>
<p><strong>根据上面的实例，我总结一下关于显卡的工作机制。显卡只能确定当下的像素是否可以绘制以及如何绘制。其结果可能是1、弃掉这个像素不画。2、这个像素会覆盖掉之前的像素。3、如果是Alpha Blend就和之前的像素进行混合。但是注意无论如何渲染的过程都不可能影响之前的已经被画出来的像素——显卡也许会抛弃当前的像素不画，但是绝不可能让之前画出来的像素消失掉。这个规则非常重要，请务必理解。</strong></p>
<p><strong>所以说对于Alpha Blend来说，RenderQueue非常的重要。已经画出来的像素只能被混合却不能被消除。所以基本上出问题的一定是透明物体和透明物体之间，因为他们的RenderQueue是相同的。先渲染的永远存在，而后渲染的却有可能被抛弃。</strong></p>
<p><strong>当然ZTest Off也许会解决这种因为遮挡而造成的不画像素的问题，但是相信我你绝对不会这么去做，因为会引发更多的麻烦(因为没了Ztest，就是非透明物体也不能正确覆盖住透明物体了)。</strong></p>
<p><strong>因为存在着如此“危险”的规则(之后的渲染不能改变之前的渲染)，渲染的先后顺序就绝对不可能是完全随机的。和非透明物体的渲染顺序控制类似，Unity也提供了控制透明物体排序的机制。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-4310e278900d4ad04627c59a6702e6ed_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-4310e278900d4ad04627c59a6702e6ed_720w.jpg"></p>
<p><strong>因为透明物体之间的排序比较重要，所以我稍微多说两句。按照Unity3D的默认做法，在对透明物体在渲染之前的排序，是根据多边形中心点与摄像机的远近来比较的。比较之后显卡会从后向前对透明物体依次进行渲染。所以绝大多数情况下你看到的粒子特效，其前后遮挡关系还是没什么大问题的。</strong></p>
<p><strong>但是这么做又会引出一个新的问题——当半透明物体交叉在一起的时候，这种判断方式几乎没有任何帮助。所以当一个复杂的多边形(例如有很多部件的角色)在使用Alpha Blend的时候，经常会出现显示效果错误，也是因为这种原因。</strong></p>
<p><strong>所以从优化的角度来讲，我们一直希望尽量少用或者不用Alpha Blend，但是现在的游戏几乎到处都充斥着Alpha Blend的物体。好在现在的处理器性能比之过去实在是强了太多，这些问题似乎也渐渐地不再成为游戏开发的限制。</strong></p>
<p><strong>那么之所以我还要特意写出来，是希望大家能知道关于Alpha Blend消耗的来龙去脉。毕竟无论处理器的性能如何发展，我们做游戏还是要以能省一点儿是一点儿的态度去抠这些细节。</strong></p>
<p><strong>单以上面的例子而言，如果你对之前的讲解理解深入的话，应该知道除了关闭Zwrite这一个办法之外，也可以用指定RenderQueue的方式强行让角色先绘制出来(或者让粒子后绘制)。这种强行改变(指定)RenderQueue也能解决两个半透明物体遮挡的问题。但是正如我之前所说的，强行指定RenderQueue是一种极其不被推荐的做法。还是那句话，如果这个时候镜头转动了180°（即物体和物体之间的前后关系完全反转），强行指定RenderQueue就会造成更严重的渲染错误。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-0b0f92ef50e8d0154b52dfda1b563a91_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-0b0f92ef50e8d0154b52dfda1b563a91_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-e50a7f4c4915ad18f79dbdd55ee91f8e_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-e50a7f4c4915ad18f79dbdd55ee91f8e_720w.jpg"></p>
<p><em>如上图，在没有关闭Zwrite的前提下， 改变粒子的渲染顺序(“Queue” = “Transparent+1” )。这样绿色的半透明角色就在粒子之前被渲染出来，红色的粒子也就有了可以进行混合的对象。</em></p>
<p><strong>Zwrite Off虽然已经成为Alpha Blend的“标配”，但是不能进行Zwrite其实是很麻烦的。如果你认为上一个效果没毛病就万事大吉，那可就大错特错了。来看下图：</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-a73c096f34f70f4f83daede1f3c21736_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-a73c096f34f70f4f83daede1f3c21736_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-bc7e9b1186b0f3a5cde5b882c302da6f_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-bc7e9b1186b0f3a5cde5b882c302da6f_720w.jpg"></p>
<p><em>大多数时候我们当然希望第一张图的效果（打开Zwrite，遮挡住原本应该被遮挡的壶把）而非第二张图的效果(关闭Zwirte，这样该物体的任何一个像素都不会改变摄像机在该像素上的深度，就会出现无法遮挡住问题)。</em></p>
<p><em>很显然，在不打开Zwrite的前提下，是不可能做出第一张图的效果的。但是正如我们之前所提到的，透明物体如果不是Zwrite Off，又会引发半透明物体之间因为遮挡而无法混合的问题。这真是一个让人头疼的麻烦。</em></p>
<p><strong>以下是官方一个例子的原理(实在搜不到了只好自己动手，惨)，是目前解决半透明问题比较常规的做法。首先做一个pass进行Zwrite，然后在第二个pass里关闭Zwrite，其他不变。可以做出一个完全是剪影的半透明效果。如下图右面的茶壶。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-20dd33a5980c074beee9c9d730b9077f_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-20dd33a5980c074beee9c9d730b9077f_720w.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-9a3d0afd41d07edc84349e237376eec8_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-9a3d0afd41d07edc84349e237376eec8_720w.jpg"></p>
<p><strong>ColorMask是指定输出通道，这里让第一个pass完全不输出任何东西，仅仅只是写入深度。这样一来茶壶就像是个非透明物体一样在屏幕上改变了当前像素的深度值。第二个pass正常绘制，在其Ztest的时候比较的就是刚刚自己留在屏幕上的Z值。这样一个完美的剪影就做出来了。</strong></p>
<p><strong>这里说点题外话。一直以来我都以为把Tag放到Pass里是可行的，直到写本文的时候我才发现只有将Tag放在Pass外面才会真正起作用。那就意味着多pass之间来回切换Tag是不可能的(或许是我理解上有问题，毕竟我刚刚才发现)。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-e19f9840fa0984f39af3145b1e73f060_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-e19f9840fa0984f39af3145b1e73f060_720w.jpg"></p>
<p><strong>最后要说的是混合方式。如果你用PhotoShop的话，应该对图层混合的模式并不陌生，而Blend方式其实也是一样的概念。所以关于Blend的方式，我就不过多展开了，相关资料网上很多有兴趣可以自行百度。</strong></p>
<p><strong>一般来说正常的Blend方式是：</strong></p>
<p><strong>Blend SrcAlpha OneMinusSrcAlpha</strong></p>
<p><strong>这个语法翻译成中文，大意是这个像素的颜色乘以这个像素的alpha值(SrcAlpha) + 这个像素背后的颜色 * (1 - 这个像素的alpha值)（OneMinusSrcAlpha）。</strong></p>
<p><strong>比如一个红色的像素(1,0,0,0.7)，期身后的颜色是蓝色(0,0,1,1)。那么在摄像机里，这个像素最终的颜色就应该是(0.7,0,0.3,0.7)（(1,0,0) * 0.7 + (0,0,1）* （1 - 0.7））。如果再出现一个半透明的物体，那就继续用这个步骤计算。</strong></p>
<p><strong>这是“正常”的方式，得到的效果是我们习惯的“默认”的效果。那么非“正常”的效果呢？半透的混合方式还有如下几种。作为比较特殊的混合方式，所有这些方式你都可以在PS的图层混合里找到相同的效果。</strong></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-6c920eb81f2d9e64731db6f15ff0c94e_b.jpg"></p>
<p><img src= "/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-6c920eb81f2d9e64731db6f15ff0c94e_720w.jpg"></p>
<hr>
<blockquote>
<p>参考来源： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/28557283">https://zhuanlan.zhihu.com/p/28557283</a></p>
</blockquote>
<hr>
<blockquote>
<p>to be continued…</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:tamsiree.com@gmail.com" rel="external nofollow noreferrer">Tamsiree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tamsiree.com" target="_blank">Tamsiree</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GameEngine/">GameEngine</a><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity3D%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"><img class="prev-cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/7e535a0de6a84796973d387bb5b3dbc1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity内存优化</div></div></a></div><div class="next-post pull-right"><a href="/GameEngine/Unity/Unity%E7%9A%84Application%E8%B7%AF%E5%BE%84/"><img class="next-cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/91b264e9960f4d75a4086ab198acd5d5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity的Application路径</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/GameEngine/Unity/AssetBundle/" title="AssetBundle"><img class="cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/jiguangbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-19</div><div class="title">AssetBundle</div></div></a></div><div><a href="/GameEngine/Unity/UGUI/UGUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/" title="UGUI源码分析系列"><img class="cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-6b320d4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-13</div><div class="title">UGUI源码分析系列</div></div></a></div><div><a href="/GameEngine/Unity/UnityHub%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%89%8B%E5%8A%A8%E6%BF%80%E6%B4%BB/" title="Unity3d许可证手动激活"><img class="cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/wallhaven-0jwzwp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-29</div><div class="title">Unity3d许可证手动激活</div></div></a></div><div><a href="/GameEngine/Unity/Unity%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" title="Unity使用心得"><img class="cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-b7b4f5b.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">Unity使用心得</div></div></a></div><div><a href="/GameEngine/Unity/Unity%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDPrefab/" title="Unity动态加载Prefab"><img class="cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg6d49cc2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-09</div><div class="title">Unity动态加载Prefab</div></div></a></div><div><a href="/GameEngine/Unity/Unity%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Unity使用技巧"><img class="cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/wallhavenlmj76.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-27</div><div class="title">Unity使用技巧</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tamsiree</div><div class="author-info__description">勇于尝试才有可能迈向成功</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">137</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">139</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/tamsiree"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tamsiree" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github-square"></i></a><a class="social-icon" href="mailto:tamsiree.com@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope-square"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">只有用心灵才能看得清事物的本质，真正重要的东西是肉眼无法看见的。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%8F%A3%E6%B0%94%E8%A7%A3%E5%86%B3RenderQueue%E3%80%81Ztest%E3%80%81Zwrite%E3%80%81AlphaTest%E3%80%81AlphaBlend%E5%92%8CStencil"><span class="toc-number">2.1.</span> <span class="toc-text">一口气解决RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend和Stencil</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity多线程渲染导致部分手机崩溃"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/Konachan.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity多线程渲染导致部分手机崩溃"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity多线程渲染导致部分手机崩溃">Unity多线程渲染导致部分手机崩溃</a><time datetime="2023-11-09T11:55:51.000Z" title="发表于 2023-11-09 19:55:51">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的CDN之jsDelivr"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/20b24a69649941669d83bb997b01fed6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="好用的CDN之jsDelivr"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的CDN之jsDelivr">好用的CDN之jsDelivr</a><time datetime="2023-10-16T07:00:56.000Z" title="发表于 2023-10-16 15:00:56">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" title="Unity坐标系统"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/wallhaven-z8rqjo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity坐标系统"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" title="Unity坐标系统">Unity坐标系统</a><time datetime="2023-10-14T06:11:46.000Z" title="发表于 2023-10-14 14:11:46">2023-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E7%9A%84ShaderLab%E7%9D%80%E8%89%B2%E5%99%A8%E5%85%A5%E9%97%A8/" title="Unity的ShaderLab着色器入门"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/wallhaven-kxj3l1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity的ShaderLab着色器入门"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E7%9A%84ShaderLab%E7%9D%80%E8%89%B2%E5%99%A8%E5%85%A5%E9%97%A8/" title="Unity的ShaderLab着色器入门">Unity的ShaderLab着色器入门</a><time datetime="2023-10-12T10:18:23.000Z" title="发表于 2023-10-12 18:18:23">2023-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/C-%E4%B8%ADReadOnly%E5%92%8CConst%E7%9A%84%E5%8C%BA%E5%88%AB/" title="C#中ReadOnly和Const的区别"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/78dc5761ab8c4b55b940967ae24ebe3a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#中ReadOnly和Const的区别"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/C-%E4%B8%ADReadOnly%E5%92%8CConst%E7%9A%84%E5%8C%BA%E5%88%AB/" title="C#中ReadOnly和Const的区别">C#中ReadOnly和Const的区别</a><time datetime="2022-11-04T06:08:52.000Z" title="发表于 2022-11-04 14:08:52">2022-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2024 By Tamsiree</div><div class="footer_custom_text">不要盯着我看，已经到底啦～</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://comment.tamsiree.com',
      path: location.pathname,
      visitor: true,
      dark: 'html[data-theme="dark"]'
    }, {"placeholder":"留下你的脚印与心声~","pageSize":10,"lang":"zh-CN","requiredFields":["nick"]}))
  }

  if (typeof Waline === 'function') initWaline()
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/talking/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>