<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Shader 学习笔记 | Tamsiree</title><meta name="author" content="Tamsiree,tamsiree.com@gmail.com"><meta name="copyright" content="Tamsiree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言这里是前言介绍。 正文一口气解决 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend 和 Stencil** 知道吗，如果只是想要实现 Xray 效果的话，其实并不难。**   实现上图的效果，原理就是对角色画两次。第一次是被遮挡住的效果(半透明、单色)，第二次是正常的效果(为了简化这里使用 unlight 只显示贴图) ** 这两个 pass 最大的区">
<meta property="og:type" content="article">
<meta property="og:title" content="Shader 学习笔记">
<meta property="og:url" content="https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Tamsiree">
<meta property="og:description" content="前言这里是前言介绍。 正文一口气解决 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend 和 Stencil** 知道吗，如果只是想要实现 Xray 效果的话，其实并不难。**   实现上图的效果，原理就是对角色画两次。第一次是被遮挡住的效果(半透明、单色)，第二次是正常的效果(为了简化这里使用 unlight 只显示贴图) ** 这两个 pass 最大的区">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg">
<meta property="article:published_time" content="2021-12-26T16:34:43.000Z">
<meta property="article:modified_time" content="2025-11-05T13:53:39.373Z">
<meta property="article:author" content="Tamsiree">
<meta property="article:tag" content="GameEngine">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Shader 学习笔记",
  "url": "https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg",
  "datePublished": "2021-12-26T16:34:43.000Z",
  "dateModified": "2025-11-05T13:53:39.373Z",
  "author": [
    {
      "@type": "Person",
      "name": "Tamsiree",
      "url": "https://tamsiree.com"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png"><link rel="canonical" href="https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-8688374801147098',
  enable_page_level_ads: 'true'
});</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Tamsiree","link":"链接: ","source":"来源: Tamsiree","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Shader 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><script>if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') { window.location.href = window.location.href.replace('http:', 'https:'); }</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="Tamsiree" type="application/atom+xml">
</head><body><div class="bg-animation" id="web_bg" style="background-color: #f0f0f0;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">143</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Tamsiree</span></a><a class="nav-page-title" href="/"><span class="site-name">Shader 学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Shader 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-26T16:34:43.000Z" title="发表于 2021-12-27 00:34:43">2021-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-05T13:53:39.373Z" title="更新于 2025-11-05 21:53:39">2025-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GameEngine/">GameEngine</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GameEngine/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GameEngine/Unity/Shader/">Shader</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一口气解决-RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend-和-Stencil"><a href="#一口气解决-RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend-和-Stencil" class="headerlink" title="一口气解决 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend 和 Stencil"></a>一口气解决 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend 和 Stencil</h2><p>** 知道吗，如果只是想要实现 Xray 效果的话，其实并不难。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-8d07b211268f64c663515a011b1bca14_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-8d07b211268f64c663515a011b1bca14_720w.jpg"></p>
<p><em>实现上图的效果，原理就是对角色画两次。第一次是被遮挡住的效果(半透明、单色)，第二次是正常的效果(为了简化这里使用 unlight 只显示贴图)</em></p>
<p>** 这两个 pass 最大的区别，在于使用不同的 Ztest(深度测试)。但是这一次我决定不仅仅只写关于 Ztest 的问题。反正我已经决定对抗懒癌晚期，那就干脆一口气把 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend、StencilTest 这些烂七八糟的东西都拎出来写一遍, 因为这些东西有很多地方都是相通的，一起说明白反而省些力气。**</p>
<p>** 不过说实话，这些东西确实是有点麻烦。我尽自己最大的努力去把这些东西说明白。但是鉴于个人能力实在有限，如果有哪里说得不对或者不清楚，还请见谅。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-0ba75819a33e8c1362a2b9f61677c92d_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-0ba75819a33e8c1362a2b9f61677c92d_720w.jpg"></p>
<p><em>如上图，现在有三个多边形分别是红色盒子绿色盒子和蓝色盒子，在镜头里红色的盒子在最前面（距离摄像机最近），所以盖住了其他两个颜色的盒子。</em></p>
<p>** 按照我们的生活常识，显示最前面的红盒子这样的结果是再正常不过了。可是计算机并不存在所谓的 “人类的常识”，它只依靠数学的方法去处理问题。而如何判断谁在前谁在后，这个问题却并非那么简单，并且很容易让人陷入混乱。因为这牵扯到 Ztest(深度测试)ZWrite(深度写入或者叫深度缓存) 和 RenderQueue(渲染序列)。**</p>
<p>** 如果是 2D 的话，只需要一个 Zindex 就可以确定 Sprite 之间的前后 (覆盖) 关系。RenderQueue(渲染序列)和这个 Zindex 的概念很像，都是直截了当指定了一个渲染的顺序。 关于 RenderQueue 可用的标签，有：**</p>
<p><strong>Background:1000</strong></p>
<p><strong>Geometry:2000</strong></p>
<p><strong>AlphaTest:2450</strong></p>
<p><strong>Transparent:3000</strong></p>
<p><strong>Overlay:4000</strong></p>
<p><strong>(写起来的样子是这样的：”Queue” = “TransParent”)</strong></p>
<p>** 数字越大的物体，其渲染顺序就越靠后，就会遮住数字小的物体。从名字里也能看得出来，BackGround 自然是那种最先渲染然后被所有东西覆盖掉的东西(比如天空盒)。而像 Overlay 这样的东西在绝大部分物体之后渲染，适合用来制作 UI。**</p>
<p>** 值得注意的是半透明物体 (Transparent Objects) 的渲染顺序十分靠后。一般情况下是在所有非半透明物体渲染之后，再渲染半透明物体。至于其原因等稍后再说明。**</p>
<p>** 除了使用默认的标签之外，还可以更详细指定渲染序列，写起来大概是这样的: “Queue” = “Geometry+1” 。这样这个物体会在所有 Geometry 渲染之后再渲染，顺序增加了一个“身位”。如果是 “Queue” = “Geometry+5000” ，那可就是比 Overlay 还靠后，绝对是最最后渲染的东西，理论上覆盖在一切东西之上。**</p>
<p>** 听起来似乎很简单，好像我们已经拿到了一把万能钥匙，可以随意控制那个小小 3D 世界里的所有一切。然而进度条告诉你事情并没这么简单（雾）。**</p>
<p>** 因为显卡既不允许你用这么简单粗暴的方式控制渲染结果，实际上你也没法用简单的 Queue 值来确定物体渲染的前后关系。**</p>
<p>** 试想一个大场景里动辄成千上万的物体，你如何去一个一个指定他们的 RenderQueue？即便你真的这么做了，一旦镜头转个 180° 是不是就全错了？更不要提每一帧都在变换位置的角色。就是神仙也不可能预知他们所处的位置到底应该是渲染序列的哪一个位置。**</p>
<p>** 这一点和 2D 游戏有着本质上的区别。在 2D 游戏里指定 ZIndex 的做法在 3D 游戏里肯定是走不通的。**</p>
<p>** 所以在大多数情况下(除了制作 UI 和天空盒之外)，这个 RenderQueue 并没有什么卵用。我用几张图来具体说明。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-b7ff915181dbe3835625eb19b7569f7e_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-b7ff915181dbe3835625eb19b7569f7e_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-8587a7b0b06c6d07818682107106aea7_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-8587a7b0b06c6d07818682107106aea7_720w.jpg"></p>
<p><em>如上图，正常情况下这三个盒子都是 “Queue” = “Geometry”。因为是“正常情况”，所以显示的效果肯定是正确的(红色的盒子挡住其他两个，同时绿色盒子挡住蓝色盒子)。但是打开 FrameDebugger 你会发现，渲染的顺序是很混乱的。也许是因为做测试的时候改动过 RenderQueue。现在莫名其妙的是先中间后两边。</em></p>
<p>** 关于非透明物体渲染的排序问题，我在这里多说两句。3D 实时渲染性能消耗的两个重要部分是 CPU 和 GPU。如果想节省 GPU 的时间，就要在渲染之前计算一次渲染顺序，这样在 Ztest 之后就，被遮挡的部分就不会进入 fragment shader；反之想要解放 CPU 的负担，就不要对渲染物体进行排序(排序这个东西大家都懂的)。当然这样会多次渲染被遮挡的像素。**</p>
<p>** 在 Unity3d 文档里，我找到了关于控制非透明物体渲染顺序的 API，其描述如下:**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-a4d69c1236e4e1f51e8346871b4900ab_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-a4d69c1236e4e1f51e8346871b4900ab_720w.jpg"></p>
<p><em>在我的印象当中以前是没有 Camera.opaqueSortMode 这个东西的，估计是新版本后加入的(我的 5.4.0 版本已经比较老了)。大家可以根据自己游戏性能的考虑去做优化。</em></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-b7ff915181dbe3835625eb19b7569f7e_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-b7ff915181dbe3835625eb19b7569f7e_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-b7aa162382d592cbd95b50b0d2d47f9e_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-b7aa162382d592cbd95b50b0d2d47f9e_720w.jpg"></p>
<p><em>如上图，当我们强行让绿色盒子的 RenderQueue 发生改变(“Queue”=”Geometry+1”)，这样绿色盒子的渲染序列变为最后渲染，然而实际的效果依然没有改变，红色盒子一如既往地盖住了绿色盒子(哪怕红色盒子是在绿色盒子之前就渲染出来的)。</em></p>
<p><strong>RenderQueue 之所以只决定了物体的渲染顺序，却没能决定物体的渲染结果，是因为显卡在渲染的时候，更多的是依靠深度测试 (Ztest) 来进行判断。</strong></p>
<p><strong>Ztest 的工作原理是这样的(假设这 3 个盒子是屏幕上的 3 个像素点)：</strong></p>
<p><strong>Step1：显卡按照渲染顺序先画出了蓝色盒子的像素(渲染的每一个步骤都可以在 FrameDebugger 里看到，真是方便)</strong></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-13688250bfcb137b4c402b4c68b3223b_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-13688250bfcb137b4c402b4c68b3223b_720w.jpg"></p>
<p>** 在画蓝色盒子的像素的时候，除了 RGB 三个颜色的值以外，显卡还会把这个像素与当前镜头的距离记录下来 (这里记录为 z1)。与背景相比，蓝盒子显然距离镜头更近，即 z1&lt;∞。按照“默认” 的做法 (注意在这个例子里我一直强调是在“默认” 的情况，或者 “默认” 的做法)，画出蓝色的盒子，并且将摄像机在这个像素上的深度值替换为 z1。**</p>
<p><strong>Step2: 接下来按照渲染顺序，开始渲染红色的盒子。</strong></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-f014923f3185f969480655821527fcbd_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-f014923f3185f969480655821527fcbd_720w.jpg"></p>
<p>** 当然红色盒子也有一个深度值 (记录为 z2)。这个时候显卡会用 z2 和摄像机在当前像素的深度值 z1 进行比较，发现 z2&lt;z1(因为红色盒子距离镜头比较近)。于是按照“默认” 的做法画出红色的盒子，并且将摄像机当前像素值更新为 z2。**</p>
<p><strong>Step3：接下来按照渲染顺序，开始渲染绿色的盒子。</strong></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-c85bf90a5658ecc2d4ce177980bc2170_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-c85bf90a5658ecc2d4ce177980bc2170_720w.jpg"></p>
<p><em>虽然这张图和上一张很像，但是注意这个时候渲染的是被 “神隐” 的绿色盒子</em></p>
<p>** 当渲染绿色盒子的时候，情况就发生了变化。我们知道绿色盒子之所以最后渲染，是因为我们强行改变了绿色盒子的渲染顺序(“Queue” = “Geometry+1”)。但是绿色盒子距离摄像机的距离是大于红色盒子的。**</p>
<p>** 所以当渲染绿色盒子的时候，其深度值 (记录为 z3) 必然会比当前像素的深度值 z2 大 (z3&gt;z2，和上一步完全相反的情况)。于是显卡按照“默认” 的做法，扔掉了绿色盒子的像素，并且保持当前像素值为 z2。其结果就是看起来绿色盒子完全被红色盒子遮挡住了(哪怕它是最后渲染出来的物体)。**</p>
<p>** 这一套流程走下来我们不难看出，所谓 “默认” 的工作原理(注意我再次强调是“默认”)，就是当一个物体像素的 z 值小于当前镜头在该位置像素的深度值时，画出该物体的这个像素，并且将这个较小的 z 值更新为当前镜头在这个像素上的深度值。**</p>
<p>** 反之，当一个物体的像素的 z 值大于当前镜头在该位置像素的深度值时，不画出该物体的这个像素，并且保留摄像机在这个像素上的深度值。**</p>
<p>** 说起来实在是拗口，也不知道各位是否能看明白。反正我是尽力了。如果非要打个比方来说，我想和当初学 C 语言的时候进行数字排序的做法差不多。不知道各位同学是不是看起来很怀念呢？**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>],i,j,temp;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; 请输入十五个整数：&quot;</span>);  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="number">15</span>;j++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">&#123;</span><br><span class="line">temp=a[j]；</span><br><span class="line">a[j]=a[i]；</span><br><span class="line">a[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; 排序后的数是：%d&quot;</span>,a[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 而这个工作流程，就是所谓的 Ztest+Zwrite。**</p>
<p>** 比较新旧 z 值的大小，就是 Ztest; 之后更新摄像机每一个像素的 z 值，就是 Zwrite。Ztest 影响的是当前物体的显示；Zwrite 影响的是之后渲染物体的显示。**</p>
<p>** 可以看出来如果不进行 Zwrite 更新镜头的 z 值，那么 Ztest 的时候就会出现不正常的结果(完全不知道前面渲染出来的物体的深度，只能完全依赖 RenderQueue)；而 Zwrite 是否更新摄像机在当前像素上的 z 值，根据两个条件：**</p>
<p>** 一是要看是否允许进行 Zwrite（默认是 Zwrite On。当然很多时候我们会手动关掉 Zwrite, 即 Zwrite Off）；二是要看 Ztest 是否通过，只有通过了 ZWrite 才会更新新的 z 值。**</p>
<p>** 请务必注意这里：z 值是否更新并不在于物体在该像素上的 z 值比摄像机在该像素上的 z 值小。而在于是否通过 Ztest。只不过在默认的情况下，通过 Ztest 的条件是小于等于。如果 Ztest 的条件改变，那么 Zwrite 写入的新值就未必比原来的值小(关于 Ztest 的条件马上就会提到)。**</p>
<p><strong>Zwrite 的概念相对简单，无非就是根据条件，对一个变量进行反复地赋值。比较有意思的 Ztest。在三个盒子的例子里，我一直都在强调 “默认” 两个字。那么默认是什么呢，就是 Zwrite On + Ztest On。Zwrite 就两种情况(On 或者 Off)。而对于 Ztest 来说，条件就要丰富得多得多。Ztest 的条件总共有如下几种:</strong></p>
<p><strong>Less (当物体的这个像素的 Z 值小于当前摄像机在这个像素上的 Z 值，则通过 Ztest)</strong></p>
<p><strong>LEqual(条件变为小于等于)</strong></p>
<p><strong>Greater(条件变为大于)</strong></p>
<p><strong>GEqual(条件变为大于等于)</strong></p>
<p><strong>Equal(条件变为相等)</strong></p>
<p><strong>NotEqual(条件变为不相等)</strong></p>
<p><strong>Always(Ztest 永远通过)</strong></p>
<p><strong>Never(Ztest 永远不通过)</strong></p>
<p><strong>Off(等同于 ZTest Always)</strong></p>
<p><strong>On(等同于 ZTest LEqual)</strong></p>
<p><strong>ZTest LEqual 也就是上面一直提到的 “Ztest 默认工作的原理”。当不写明 Ztest 的处理方式的时候，ZTest 的通过条件 LEqual。因此我们就总能看到距离摄像机近的物体(Z 值小) 盖住了距离摄像机远 (Z 值大) 的物体，这样 “理所当然” 的效果。</strong></p>
<p>** 有意思的是当我们相要搞些事情的时候，就可以利用 ZTest 那些非默认的选项。当物体被遮挡住的时候(即 Ztest Greater), 原本是看不见的。但是 Xray 的效果不就正是要看见原本看不见的东西么？**</p>
<p>** 所以 Xray 效果的第一个 pass。我使用以下的“黑科技”:**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-5b06b29a38f18c138126a2f21c14ac52_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-5b06b29a38f18c138126a2f21c14ac52_720w.jpg"></p>
<p><em>Blend SrcAlpha OneMinusSrcAlpha 说明我们要用 alpha blend 的方式进行渲染(关于 Alpha Blend 后面会提到)。Ztest Greater 意味着我就是要处理 z 值大于摄像机 z 值的情况(只有在别的物体后面 z 值才会比较大，也就是说只有实际上被别的物体挡住的时候，才会用这种方式渲染)。同时关掉 Zwrite。</em></p>
<p>** 关闭 Zwrite 是比较重要的一步，开着 Zwrite 会把错误的 z 值 (比较大的 z 值) 更新上去。正如前面特别强调的，Zwrite 的条件之一是通过 Ztest。这一次 Ztest 的条件是 Greater，所以通过 Ztest 以后 z 值是比原来大的，更新上去以后会对其他物体的深度判断造成影响，关于这一点我们马上举例说明。**</p>
<p>** 第一个 pass 效果如下:**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-7698ec0e7c14466964a68304e5729ef9_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-7698ec0e7c14466964a68304e5729ef9_720w.jpg"></p>
<p><em>我们看到，Z 值比较小的像素(即未被遮挡住的像素)，反而因为没有处理 Ztest Lequal 的 Pass 而无法显示出来。</em></p>
<p>** 接下来就是第二个 Pass。我们使用新的 Ztest 条件：**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-d9bcb63d4b5c7f646f06a5447b923e76_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-d9bcb63d4b5c7f646f06a5447b923e76_720w.jpg"></p>
<p>** 其实这就是刚才我们一直所说的“默认情况”。换句话是其实 Zwrite On 和 ZTest LEqual 完全可以不用写。效果如下：**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-8d07b211268f64c663515a011b1bca14_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-8d07b211268f64c663515a011b1bca14_720w.jpg"></p>
<p>** 那么问题来了，如果我们在第一个 pass 中打开 Zwrite 会出现什么结果呢？**</p>
<p>** 第一个 Pass 打开 Zwrite 的效果如下:**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-d91e5808b6bc4abe5b2be91c064a1888_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d91e5808b6bc4abe5b2be91c064a1888_720w.jpg"></p>
<p>** 无论是否被遮挡，人物都会显示成 Pass2 的效果（而且还有明显得错误）。**</p>
<p>** 我们利用刚才获知的原理来分析一下。在 Pass1 通过 Ztest 之后，因为打开了 Zwrite，所以将角色在 Pass1 阶段渲染出来的像素的深度值写入到屏幕当前的深度值。注意这个深度值是大于墙的像素的深度值的，但是依然被写进镜头的深度当中。**</p>
<p>** 当来到 Pass2 时，Ztest 的条件是 LEqual(小于等于)。因为当前摄像机中该像素的深度值就是角色身上像素的深度 (因为上一步通过 Zwrite 已经写入)。所以完全符 Equal(相等) 的条件。于是 Pass2 的像素成功通过 ZTest 并被画出来，Pass1 画出的像素自然就被 Pass2 覆盖掉了。**</p>
<p>** 有兴趣的朋友也可以在 Pass2 中试一试，当 Ztest 的条件是 Less 的时候会出现什么效果。这里就不一一举例了。**</p>
<p>** 以上是关于 ZTest、Zwrite 和 RenderQueue 三个容易产生混乱的概念。下面又是一个类似的概念：Stencil（模板）。**</p>
<p><strong>Stencil 和深度一样，是写进 buffer 里的一个数值(Z buffer 和 Stencil Buffer 这两个词你应该听过很多次了)。</strong></p>
<p><strong>Stencil 的工作原理和 Ztest+Zwrite 很相似，但是灵活性更高一些。关于 Stencil 的一些具体例子和讲解，网上有很多。我这里的重点就不放在实际例子上，而是关于模板和深度这两个东西在用法和原理上的异同。</strong></p>
<p>** 关于 Ztest+Zwrite 我已经提到过很多次了，最简单的理解就是“比较”+“写入”。如果你真的对其原理理解得非常好，那么搞定 Stencil 就没有任何问题。**</p>
<p>** 在 Unity3D 里面并不存在 “Stencil Test” 和“Stencil Write”这两个字眼儿。Stencil 就是一个过程，同时包含了 “比较” 和“写入”两个步骤。**</p>
<p><strong>Stencil 的完整语法：</strong></p>
<p><strong>stencil{</strong></p>
<p><strong>Ref referenceValue</strong></p>
<p><strong>ReadMask readMask</strong></p>
<p><strong>WriteMask writeMask</strong></p>
<p><strong>Comp comparisonFunction</strong></p>
<p><strong>Pass stencilOperation</strong></p>
<p><strong>Fail stencilOperation</strong></p>
<p><strong>ZFail stencilOperation</strong></p>
<p><strong>}</strong></p>
<p>** 具体详尽的用法写起来太麻烦(我实在是怕麻烦怕得要死)，我就稍微总结一下：总的来说你只要关注 Ref\Comp\Pass 三个关键词。再稍微复杂一点儿的情况，你可能需要用到 Fail\Zfail。最后在需要更复杂的判断的时候，你也许会需要用到那两个 Mask。**</p>
<p>** 我们再回顾一下 Ztest+Zwrite 的原理。获取 Z 值 -&gt;测试 (比较)Z 值 -&gt; 写入新的 Z 值(如果通过测试)。**</p>
<p>** 我们假定 Stencil 也有一个值叫 Ref 值。那么 Stencil 的用法也实在是看着眼熟：获取 Ref 值 -&gt;测试 (比较)Ref 值 -&gt; 写入新的 Ref 值(如果通过测试)。**</p>
<p>** 说到底这俩玩意儿的区别，就是在第一步，获取当前物体在这个像素上的这个变量。**</p>
<p><strong>Z 值是根据像素到摄像机的距离算出来的，不会因为你的个人意愿而改变；S 值是你可以随便填的(是的随便填，想写几就写几，范围 0-255)。</strong></p>
<p>** 这样一来 Stencil 可以帮助你突破 Ztest 所带来的限制，用更灵 (jian) 活(dan)便 (cu) 捷(bao)的方式来控制渲染效果。**</p>
<p><strong>Ref 就是写入这个像素的 Ref 值，正如我之前提到的想写几就写几完全看心情 (所以我一直都认为叫 Stencil Buffer 模板缓冲实在是有点唬人的感觉。改成“看哪个数字顺眼就用哪个数字比大小” 更贴切一些)。</strong></p>
<p><strong>Com 是进行 Test 的条件，当你看到一大堆 Less\LEqual\Greater\GEqual\Equal\NotEqual\Always\Never 这样的字眼儿，是不是感到非常的眼熟？这一步比较的过程和 Ztest 完全一样。</strong></p>
<p><strong>Pass 和 Zwrite 简直就是一个妈生出的俩个孩儿。区别就是这个小哥比他兄弟花样儿多点。Zwrite 无非就是写入或者不写入(On or Off)。Pass 甚至还可以控制如何写入(虽然大多数情况下可能用不到)。</strong></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-efbed4ee6525cab050651da10572b817_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-efbed4ee6525cab050651da10572b817_720w.jpg"></p>
<p><em>Pass 支持的条件一览，其中 Keep 类似于 Zwrite 里的 Off;Replace 类似于 ZWrite 里的 On(此图来自互联网)。</em></p>
<p>** 举个栗子，如下图所示，现在有一面墙和一个茶壶，按照与镜头的位置关系，墙体遮挡住茶壶的下半部分。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-b12d128a7157f7caf317d7999d80380b_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-b12d128a7157f7caf317d7999d80380b_720w.jpg"></p>
<p>** 如果我们想要做一个如 Flash 里的 Mask Layer 效果。就可以使用 Stencil 来做。**</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stencil </span><br><span class="line">&#123;</span><br><span class="line">    // 摄像机在当前像素的默认 stencil 值是 0</span><br><span class="line">    // 设置当前物体当前像素的参考值为 100</span><br><span class="line">    Ref 100 </span><br><span class="line">    // 永远通过 stencil 测试</span><br><span class="line">    // 这个 shader 的唯一目的就是在这个物体所占的像素上写入 stencil 值 100</span><br><span class="line">    Comp Always</span><br><span class="line">    // 通过后(因为 Comp Always 所以必然会通过), 将当前 stencil 值更新为 ref 的值(100)</span><br><span class="line">    Pass replace</span><br><span class="line">    // 这样墙所占有的像素的 Stencil 值就被确定下来了</span><br><span class="line">    // 如果有多个墙, 也可以用 Comp GEqual 或者 Comp LEqual</span><br><span class="line">    // 来找一个最大 / 最小的 stencil 值作为当前像素的 stencil 值</span><br><span class="line">&#125;</span><br><span class="line">Zwrite Off </span><br></pre></td></tr></table></figure>

<p>** 注意墙的深度缓冲要关掉，否则茶壶在做 Ztest 的时候会因为遮挡关系而被弃掉像素。**</p>
<p>** 接着是茶壶的 shader:**</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stencil </span><br><span class="line">&#123;</span><br><span class="line">	// 像素默认的 stencil 值应该是 0</span><br><span class="line">	// 设置茶壶在当前像素的参考值为 90</span><br><span class="line">	Ref 90</span><br><span class="line">	// 因为之前墙的 ref 值 100 已经写入到摄像机里, 所以当前像素的 ref 值已经是 100</span><br><span class="line">        // 因为茶壶的 Ref 值（90）小于当前摄像机在该位置的像素的 ref 值 100，测试通过 </span><br><span class="line">	Comp LEqual</span><br><span class="line">	// 通过后, 不更新 ref 值</span><br><span class="line">	Pass keep</span><br><span class="line">	// 这样墙在该像素上的 Stencil 值(100) 依然是摄像机在当前像素上的人 ref 值</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-b6d4f7bdce4ee7b56561149dac30f034_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-b6d4f7bdce4ee7b56561149dac30f034_720w.jpg"></p>
<p><em>茶壶被透明墙遮挡住的部分，因为其 Stencil 值通过测试，所以被显示了出来。</em></p>
<p>** 当然这里存在一个潜在的问题。试想如果这两个非透明物体在渲染的时候，顺序并不是先画墙再画茶壶。其结果就会因为墙的 ref 值没有提前更新好，而造成了茶壶在比较的 ref 值的时候出现我们不期望的结果。所以说，虽然我们并没有太多注意过非透明物体的渲染顺序。但是这东西确实会在各种意想不到的地方，造成莫名其妙的显示错误。**</p>
<p>** 最后就是 Alpah Test 和 Alpha Blend。看到 XXXTest 是不是第一反应又是 Test + Write 这种东西。然后又是一堆 Lequal、Gequal 这些乱七八糟的条件。**</p>
<p>** 好消息是这个世界上并不存在 “Alpha Write” 这种东西，并且 Alpha Test 也远没有之前那两个 Test 那么复杂；坏消息是你需要多了解一个新的概念——Alpha Blend, 一个既麻烦又特别容易出问题的玩意儿。**</p>
<p>** 首先一句话解决 Alpha Test。与其他的 Test 概念相通的是：Alpha Test 的运作原理也是当条件成立时，画出该像素，否则抛弃该像素。但是它的特点是无需 (也无法) 同镜头中同一个位置的其他像素值进行比较(自然更加无法进行写入)。**</p>
<p>** 相对而言，其他的 Test 还需要跟别的东西比较一下，Alpha Test 并不存在这个过程，它只和自己本身存在的变量进行比较，是一个非常自闭的过程。**</p>
<p>** 因为 AlpahTest 有以上的特性，所以在 Unity 的 shader 里并没有 Alpha Test On\Off 这样的关键字。Alpha Test 可用的函数只有两个，一个是 clip 一个是 discard。clip(x)函数的变量 x 必须小于 0 才会通过测试。比如说简单粗暴的 clip(-1)就把所有像素都干掉了；而用 if(){discard;}可以使用任意条件触发。相对而言 discard 比较灵活，但是要用到 if 让我很不爽。这两个函数的具体用法大家可自行百度(好吧是我懒得贴)。**</p>
<p>** 一般做渐变消失的时候，会用到 clip\discard。比如下图 **</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-d83f5829ff843cbd471919d7f1a03b62_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-d83f5829ff843cbd471919d7f1a03b62_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-3b94cb2c6143c778c8200c79236721df_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-3b94cb2c6143c778c8200c79236721df_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-d61d607e1b5f0267261a5fd1cab3b0d4_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d61d607e1b5f0267261a5fd1cab3b0d4_720w.jpg"></p>
<p><em>把不断变化的时间值传入 shader，来不断减小 clip()函数的变量，就能做出如上的效果。当然这个效果还可以进一步改进，因为和本文无关所以就不展开了。需要注意的是在移动平台上，Alpha Test 的消耗较大，属于能不用就不用的东西(就像 if、for 这些东西能不用尽量别用)。</em></p>
<p><em>如果你非要搞明白为什么简单粗暴的 alpha test 反而消耗大，就自己去查关于 PowerVR GPUs、Deferred Tile-Based-Rendering、Early-Z 等等这些知识点，对于我一个懒人来说搬运这些东西简直跟要了我的命没什么区别。</em></p>
<p><strong>Alpha Test 是一个非黑即白的过程。通过或者不通过，画出或者抛弃，简单粗暴一目了然。当然我们大多数时候并不喜欢如此粗暴的处理，毕竟人不是机器，凡事还需要温柔一点。所以我们更多的时候用的是 Alpha Blend 而非 Alpha Test。</strong></p>
<p><strong>Alpha Blend 即透明混合。我们之前提到的所有 Test 方式，不是你盖住我就是我盖住你，总之没有任何 “和谐共处” 的可能性。而 Alpha Blend 提供了这种可能性。根据 Blend 的方式不同，该物体在这个像素的 rgb 值会和其他物体在这个像素上的 rgb 进行混合。</strong></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-42e0d0ff41ef2b67434b653bd8aed8e4_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-42e0d0ff41ef2b67434b653bd8aed8e4_720w.jpg"></p>
<p><em>Alpha Blend 的效果，在一般意义上这就是我们理解的“半透明”。</em></p>
<p>** 我们之前曾经提到过，半透明的物体 (也就是需要用 Alpha Blend 方式渲染的物体) 一般来说渲染序列比较靠后(通常我们用 “Queue” = “Transparent”)。道理很简单，你要和别的像素混合，那么必须要有其他像素已经画出来才行。如果透明物体被提前渲染出来，而当时还不存在后面要跟它混合的像素，自然就会出现错误。**</p>
<p>** 所以难怪只有 Overlay 这种做 UI 的物体，渲染顺序会排在 Transparent 之后——毕竟 UI 是不需要和场景中的半透物体进行混合。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-87f12e69afa888da3a5d7e8c87c2e028_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-87f12e69afa888da3a5d7e8c87c2e028_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-a658ce89bdb0b4f449be427f6ea3f85d_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-a658ce89bdb0b4f449be427f6ea3f85d_720w.jpg"></p>
<p><em>如图所示，当半透明物体 (红色方形粒子) 没有被指定渲染顺序为 Transparent 的时候，在混合天空盒的时候发生了明显错误。红圈是渲染粒子的部分，黑圈是渲染天空盒的部分。很明显在渲染粒子的时候，并没有渲染出来天空盒，所以也就没有混合 (Blend) 操作时可以用来混合的颜色。</em></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-ad239998df983e903dff334dff9f95fb_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-ad239998df983e903dff334dff9f95fb_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-e9da208c4b3cdae9044c33bfef0244df_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-e9da208c4b3cdae9044c33bfef0244df_720w.jpg"></p>
<p><em>当半透明的渲染顺序被正确指定为 Transparent 的时候，渲染天空盒发生在渲染粒子之前，也就是在画粒子的时候天空盒的像素就已经存在了。这样粒子就有了可以进行混合操作的颜色，因此半透明粒子与天空盒的混合效果正确。(说实话我很奇怪为什么 Unity 默认的天空盒渲染顺序居然不是 BackGround，也许他们有他们自己的考虑吧。)</em></p>
<p>** 注意在谈关于 Alpha Blend 的时候，几乎每一个细节都和 RenderQueue 息息相关。这和之前的 Ztest 完全不同。其区别在于 Ztest 只关心谁盖住了谁，一旦被盖住就不再在意被盖住的像素到底是个什么样; 然而 Alpha Blend 却需要关注任何一个画在当前位置的像素颜色，只有获得这些颜色的全部信息，才可能进行正确的混合。这也是为什么 Alpha Blend 的消耗很大(因为所有在该像素上的物体都要进入 fragment shader 进行绘制)，而且常常会引发各种非常棘手的问题。**</p>
<p>** 在写 Unity Shader 的时候，Alpha Blend 有两个非常重要的语句：Zwrite Off 和 Blend 的方式。**</p>
<p>** 一般情况下我们渲染半透明物体的时候，都是 Zwrite Off。**</p>
<p>** 为什么一定是 Zwrite Off？我们最开始说，只有打开 Zwrite，才有可能进行 “正确有效” 的 Ztest，否则所有关闭 Zwrite 的物体，其渲染将完全依赖于 RenderQueue。**</p>
<p>** 但是对于透明物体之间来说 (注意是透明物体之间，而不是透明和非透明物体之间)，我们需要的恰恰是不要进行有效的 Ztest——因为我们的初衷就是不能让“正确” 的遮挡关系产生作用。试想如果透明物体之间因为 Ztest 判定了 “正确” 的遮挡关系，而造成部分像素被显卡丢弃不画，又怎么可能产生之后混合的过程呢？**</p>
<p>** 而一旦放弃 Zwrite。透明物体之间的 Ztest 其实都是统统通过的，换言之任何一个半透明物体的像素在与其他半透明物体的像素进行 Ztest 的时候，将不会被认为是需要弃掉不画的像素(我再次强调，因为 RenderQueue 的关系，所有谈到的东西都仅限于半透明物体之间)。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-2ffeff5b8aafb68d5e18c4896df5505b_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-2ffeff5b8aafb68d5e18c4896df5505b_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-95d494fdc777d4f6de2d925d69a755ed_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-95d494fdc777d4f6de2d925d69a755ed_720w.jpg"></p>
<p><em>来看这张图，注意粒子后面的角色和墙不一样，这个角色与粒子相同也是个半透明的物体。当 Zwrite On 的时候，整个渲染过程是先画了方块形的粒子(Draw Dynamic)，再画的绿色的角色(那三个 Draw Mesh)。当开始绘制角色的时候显卡做了 Ztest，其判定这个角色被粒子遮挡住，所以像素并没有画出来。</em></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-cc292be9f408d0df9f7884f365627891_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-cc292be9f408d0df9f7884f365627891_720w.jpg"></p>
<p><em>当 Zwrite Off 以后，注意这个时候依然是先画出粒子再画出角色，在角色做 Ztest 的时候，被判定并没有被粒子遮挡(因为粒子的深度信息并没有写入，角色像素的 Z 值小于等于当前摄像机在当前像素上的 Z 值)，所以角色的像素被绘制出来，并且与粒子的颜色进行了正常的混合。</em></p>
<p>** 你可能会问为什么墙不会被挡住，因为墙是 “Queue” = “Geometry”，作为一个渲染序列靠前的物体，在画粒子的时候其像素就已经存在了。**</p>
<p>** 根据上面的实例，我总结一下关于显卡的工作机制。显卡只能确定当下的像素是否可以绘制以及如何绘制。其结果可能是 1、弃掉这个像素不画。2、这个像素会覆盖掉之前的像素。3、如果是 Alpha Blend 就和之前的像素进行混合。但是注意无论如何渲染的过程都不可能影响之前的已经被画出来的像素——显卡也许会抛弃当前的像素不画，但是绝不可能让之前画出来的像素消失掉。这个规则非常重要，请务必理解。**</p>
<p>** 所以说对于 Alpha Blend 来说，RenderQueue 非常的重要。已经画出来的像素只能被混合却不能被消除。所以基本上出问题的一定是透明物体和透明物体之间，因为他们的 RenderQueue 是相同的。先渲染的永远存在，而后渲染的却有可能被抛弃。**</p>
<p>** 当然 ZTest Off 也许会解决这种因为遮挡而造成的不画像素的问题，但是相信我你绝对不会这么去做，因为会引发更多的麻烦(因为没了 Ztest，就是非透明物体也不能正确覆盖住透明物体了)。**</p>
<p>** 因为存在着如此 “危险” 的规则(之后的渲染不能改变之前的渲染)，渲染的先后顺序就绝对不可能是完全随机的。和非透明物体的渲染顺序控制类似，Unity 也提供了控制透明物体排序的机制。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-4310e278900d4ad04627c59a6702e6ed_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-4310e278900d4ad04627c59a6702e6ed_720w.jpg"></p>
<p>** 因为透明物体之间的排序比较重要，所以我稍微多说两句。按照 Unity3D 的默认做法，在对透明物体在渲染之前的排序，是根据多边形中心点与摄像机的远近来比较的。比较之后显卡会从后向前对透明物体依次进行渲染。所以绝大多数情况下你看到的粒子特效，其前后遮挡关系还是没什么大问题的。**</p>
<p>** 但是这么做又会引出一个新的问题——当半透明物体交叉在一起的时候，这种判断方式几乎没有任何帮助。所以当一个复杂的多边形 (例如有很多部件的角色) 在使用 Alpha Blend 的时候，经常会出现显示效果错误，也是因为这种原因。**</p>
<p>** 所以从优化的角度来讲，我们一直希望尽量少用或者不用 Alpha Blend，但是现在的游戏几乎到处都充斥着 Alpha Blend 的物体。好在现在的处理器性能比之过去实在是强了太多，这些问题似乎也渐渐地不再成为游戏开发的限制。**</p>
<p>** 那么之所以我还要特意写出来，是希望大家能知道关于 Alpha Blend 消耗的来龙去脉。毕竟无论处理器的性能如何发展，我们做游戏还是要以能省一点儿是一点儿的态度去抠这些细节。**</p>
<p>** 单以上面的例子而言，如果你对之前的讲解理解深入的话，应该知道除了关闭 Zwrite 这一个办法之外，也可以用指定 RenderQueue 的方式强行让角色先绘制出来(或者让粒子后绘制)。这种强行改变(指定)RenderQueue 也能解决两个半透明物体遮挡的问题。但是正如我之前所说的，强行指定 RenderQueue 是一种极其不被推荐的做法。还是那句话，如果这个时候镜头转动了 180°（即物体和物体之间的前后关系完全反转），强行指定 RenderQueue 就会造成更严重的渲染错误。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/v2-0b0f92ef50e8d0154b52dfda1b563a91_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-0b0f92ef50e8d0154b52dfda1b563a91_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-e50a7f4c4915ad18f79dbdd55ee91f8e_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-e50a7f4c4915ad18f79dbdd55ee91f8e_720w.jpg"></p>
<p><em>如上图，在没有关闭 Zwrite 的前提下， 改变粒子的渲染顺序(“Queue” = “Transparent+1” )。这样绿色的半透明角色就在粒子之前被渲染出来，红色的粒子也就有了可以进行混合的对象。</em></p>
<p><strong>Zwrite Off 虽然已经成为 Alpha Blend 的“标配”，但是不能进行 Zwrite 其实是很麻烦的。如果你认为上一个效果没毛病就万事大吉，那可就大错特错了。来看下图：</strong></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-a73c096f34f70f4f83daede1f3c21736_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-a73c096f34f70f4f83daede1f3c21736_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-bc7e9b1186b0f3a5cde5b882c302da6f_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-bc7e9b1186b0f3a5cde5b882c302da6f_720w.jpg"></p>
<p><em>大多数时候我们当然希望第一张图的效果（打开 Zwrite，遮挡住原本应该被遮挡的壶把）而非第二张图的效果(关闭 Zwirte，这样该物体的任何一个像素都不会改变摄像机在该像素上的深度，就会出现无法遮挡住问题)。</em></p>
<p><em>很显然，在不打开 Zwrite 的前提下，是不可能做出第一张图的效果的。但是正如我们之前所提到的，透明物体如果不是 Zwrite Off，又会引发半透明物体之间因为遮挡而无法混合的问题。这真是一个让人头疼的麻烦。</em></p>
<p>** 以下是官方一个例子的原理(实在搜不到了只好自己动手，惨)，是目前解决半透明问题比较常规的做法。首先做一个 pass 进行 Zwrite，然后在第二个 pass 里关闭 Zwrite，其他不变。可以做出一个完全是剪影的半透明效果。如下图右面的茶壶。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/v2-20dd33a5980c074beee9c9d730b9077f_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-20dd33a5980c074beee9c9d730b9077f_720w.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-9a3d0afd41d07edc84349e237376eec8_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-9a3d0afd41d07edc84349e237376eec8_720w.jpg"></p>
<p><strong>ColorMask 是指定输出通道，这里让第一个 pass 完全不输出任何东西，仅仅只是写入深度。这样一来茶壶就像是个非透明物体一样在屏幕上改变了当前像素的深度值。第二个 pass 正常绘制，在其 Ztest 的时候比较的就是刚刚自己留在屏幕上的 Z 值。这样一个完美的剪影就做出来了。</strong></p>
<p>** 这里说点题外话。一直以来我都以为把 Tag 放到 Pass 里是可行的，直到写本文的时候我才发现只有将 Tag 放在 Pass 外面才会真正起作用。那就意味着多 pass 之间来回切换 Tag 是不可能的(或许是我理解上有问题，毕竟我刚刚才发现)。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/v2-e19f9840fa0984f39af3145b1e73f060_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-e19f9840fa0984f39af3145b1e73f060_720w.jpg"></p>
<p>** 最后要说的是混合方式。如果你用 PhotoShop 的话，应该对图层混合的模式并不陌生，而 Blend 方式其实也是一样的概念。所以关于 Blend 的方式，我就不过多展开了，相关资料网上很多有兴趣可以自行百度。**</p>
<p>** 一般来说正常的 Blend 方式是：**</p>
<p><strong>Blend SrcAlpha OneMinusSrcAlpha</strong></p>
<p>** 这个语法翻译成中文，大意是这个像素的颜色乘以这个像素的 alpha 值(SrcAlpha) + 这个像素背后的颜色 * (1 - 这个像素的 alpha 值)（OneMinusSrcAlpha）。**</p>
<p>** 比如一个红色的像素(1,0,0,0.7)，期身后的颜色是蓝色(0,0,1,1)。那么在摄像机里，这个像素最终的颜色就应该是(0.7,0,0.3,0.7)（(1,0,0) * 0.7 + (0,0,1）* （1 - 0.7））。如果再出现一个半透明的物体，那就继续用这个步骤计算。**</p>
<p>** 这是 “正常” 的方式，得到的效果是我们习惯的 “默认” 的效果。那么非 “正常” 的效果呢？半透的混合方式还有如下几种。作为比较特殊的混合方式，所有这些方式你都可以在 PS 的图层混合里找到相同的效果。**</p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/v2-6c920eb81f2d9e64731db6f15ff0c94e_b.jpg"></p>
<p><img src="/images/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-6c920eb81f2d9e64731db6f15ff0c94e_720w.jpg"></p>
<hr>
<blockquote>
<p>参考来源： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/28557283">https://zhuanlan.zhihu.com/p/28557283</a></p>
</blockquote>
<hr>
<blockquote>
<p>to be continued…</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tamsiree.com">Tamsiree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://tamsiree.com" target="_blank">Tamsiree</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GameEngine/">GameEngine</a><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/66a3272c874d41e5b9ec7562fe5822cd.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity3D%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" title="Unity 内存优化"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/7e535a0de6a84796973d387bb5b3dbc1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unity 内存优化</div></div><div class="info-2"><div class="info-item-1">前言这里是前言介绍。 正文转载自 ：Unity3D 内存释放 最近网友通过网站搜索 Unity3D 在手机及其他平台下占用内存太大. 这里写下关于 unity3d 对于内存的管理与优化. Unity3D 里有两种动态加载机制：一个是 Resources.Load，另外一个通过 AssetBundle, 其实两者区别不大。Resources.Load 就是从一个缺省打进程序包里的 AssetBundle 里加载资源，而一般 AssetBundle 文件需要你自己创建，运行时 动态加载，可以指定路径和来源的。 其实场景里所有静态的对象也有这么一个加载过程，只是 Unity3D 后台替你自动完成了。 详细说一下细节概念：AssetBundle 运行时加载:来自文件就用 CreateFromFile(注意这种方法只能用于 standalone 程序）这是最快的加载方法也可以来自 Memory, 用 CreateFromMemory(byte[]), 这个 byte[]可以来自文件读取的缓冲，www 的下载或者其他可能的方式。其实 WWW 的 assetBundle 就是内部数据读取完后自...</div></div></div></a><a class="pagination-related" href="/GameEngine/Unity/Unity%E7%9A%84Application%E8%B7%AF%E5%BE%84/" title="Unity 的 Application 路径"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/91b264e9960f4d75a4086ab198acd5d5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity 的 Application 路径</div></div><div class="info-2"><div class="info-item-1">前言发现 **Application.temporaryCachePath 和 Application.persistentDataPath 返回空字符串 **。便花时间认真研究了一下 Unity3D 的路径问题。 正文我们常用的是以下四个路径： Application.dataPathApplication.streamingAssetsPathApplication.persistentDataPathApplication.temporaryCachePath   根据测试，详细情况如下：  iOS:Application.dataPath            /var/containers/Bundle/Application/app sandbox/xxx.app/DataApplication.streamingAssetsPath /var/containers/Bundle/Application/app sandbox/test.app/Data/RawApplication.temporaryCachePath /var/mobile/Containers/...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/GameEngine/Unity/UGUI/UGUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/" title="UGUI 源码分析系列"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-6b320d4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-13</div><div class="info-item-2">UGUI 源码分析系列</div></div><div class="info-2"><div class="info-item-1">阅前提示该系列注重分析 UGUI 源码，来深入了解 UGUI 每个模块每个组件的实现原理，使我们对 UGUI 使用和拓展上更加得心应手。适合人群：UGUI 使用者，All阅读方式：文章 + 源码阅读本系列在不断更新中，如果对你有所帮助，可以点赞收藏：）UGUI 版本：2017.4源码地址 文章目录   [阅前提示](# 阅前提示)   [总览图](# 总览图)   Base    UIBehaviour   EventSystem   CanvasUpdateSystem   LayoutSystem   Graphic   Selectable     Component    Image &amp; RawImage   Text &amp; Shadow &amp; Outline   Button   Toggle   Slider   Scrollbar &amp; ScrollRect   Dropdown InputField     总览图  Base UIBehaviour BaseClass: MonoBehaviour **Interface: 无 ** I...</div></div></div></a><a class="pagination-related" href="/GameEngine/Unity/Unity%E5%B0%863D%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7%E4%B8%BAURP%E9%A1%B9%E7%9B%AE/" title="Unity 将 3D 项目升级为 URP 项目"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-373df37.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-30</div><div class="info-item-2">Unity 将 3D 项目升级为 URP 项目</div></div><div class="info-2"><div class="info-item-1">前言在使用 Unity 的过程中，总会遇到老项目需要用到 URP 效果，故需要将 3D 项目转化为 URP 项目。 1. 安装 Universal RP在 Window 窗口下打开 Package Manager, 包的类型选择 Unity 为 Unity Registry 搜索 Universal，可以看到当前 unity 版本（2020.2）已经认证支持的 Universal RP 版本是 10.2.2。点击 install 进行安装。打开 UnityARegistry 时有时候会存在下面的报错，这是因为网络的问题，可能需要科学上网。 2. 创建渲染管线的 Pipeline点击 Project 下的加号创建新的渲染管线，Rendering -- Universal Render Pipeline -- Pipeline Asset(Forward Renderer)如下图, 使用默认的命名方式命名并把他们归纳在新的文件夹下。 点击窗口 Edit -- Project Settings 打开设置页面选择 Graphics 给可编辑渲染管线设置中添加刚才新创建的 URP Pipe...</div></div></div></a><a class="pagination-related" href="/GameEngine/Unity/Unity%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDPrefab/" title="Unity 动态加载 Prefab"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg6d49cc2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-09</div><div class="info-item-2">Unity 动态加载 Prefab</div></div><div class="info-2"><div class="info-item-1">前言在进行一些功能开发的时候，我们常常将一些能够复用的对象制作成 .prefab 的预设物体，然后将预设体存放到 Resources 目录之下，使用时再动态加载到场景中并进行实例化。例如：子弹、特效甚至音频等，都能制作成预设体。 预设动态加载到场景一个预设体要能够通过代码控制在场景中进行显示，需要三个步骤，这里我们以动态加载怪物血条为例子分析一个常见的误区： 预设体资源加载12// 加载预设体资源 GameObject bulletPrefab = (GameObject)Resources.Load(&quot;Prefabs/BulletPrefab&quot;);  通过上述操作，实现从资源目录下载入 Prefabs\BulletPreFab.prefab 预设体，用一个 GameObject 对象来存放，此时该预设物体并未真正载入到场景中，因为还未进行实例化操作。 预设体实例化在第一步中我们已经将预设体资源加载完毕，但是为实例化的资源不会出现在场景中，所以第二不我们需要对资源进行实例化，实例化使用的是 MonoBehaviour.Instantiate 函数来完成的，其实...</div></div></div></a><a class="pagination-related" href="/GameEngine/Unity/Unity%E5%AE%8F%E5%AE%9A%E4%B9%89/" title="Unity 宏定义"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/jiqiren.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-06</div><div class="info-item-2">Unity 宏定义</div></div><div class="info-2"><div class="info-item-1">前言Unity 包含一个称为 Platform Dependent Compilation 的功能。这包含一些预处理器指令，可让您对脚本进行分区，以便为受支持的平台之一专门编译和执行一段代码。 你可以在 Unity 编辑器中运行这个代码，这样你就可以专门为你的目标平台编译代码并在编辑器中测试它！ 正文宏123456789101112131415161718192021222324252627UNITY_EDITOR 编辑器调用 UNITY_STANDALONE_OSX 专门为 < span class="function">Mac OS( 包括 Universal，PPC 和 Intelarchitectures)平台的定义。UNITY_DASHBOARD_WIDGET Mac OS Dashboard widget (Mac OS 仪表板小部件 )。UNITY_STANDALONE_WIN Windows 操作系统UNITY_STANDALONE_LINUX Linux 操作系统UNITY_STANDALONE 独立的平台 (Mac,Windows 或 Linux)UNITY_...</div></div></div></a><a class="pagination-related" href="/GameEngine/Unity/Unity%E8%87%AA%E5%AE%9A%E4%B9%89PackageManager%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Unity 自定义 PackageManager 服务器"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/wallroom-3840x2400-bg-e7cde59.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="info-item-2">Unity 自定义 PackageManager 服务器</div></div><div class="info-2"><div class="info-item-1">前言这里是前言介绍。 正文** 本文会实现以下几个需求 **   ** 搭建自己的 PackageManager 服务器 **    安装 nodejs    安装 npm    部署 verdaccio      ** 将自己写的插件发布到 PackageManager 服务器上 **    配置自己的 Package    注册 Verdaccio 服务器账号    登陆 Verdaccio 服务器    发布 Package 到 Verdaccio 服务器上      ** 让项目可以使用 Verdaccio 服务器上的所有 Package**    修改项目的 manifest.json      ** 修改 Unity 编辑器的项目模板，让每个新建的 Unity 项目都可安装自己服务器上的插件 **    修改 Unity 编辑器项目模板的 mainfest.json    使用 peazip 重新压缩为. tgz 文件   ** 本文需要用到的工具 **   Unity Editor   云服务器   Windows PowerShell   PeaZip  ** 参...</div></div></div></a><a class="pagination-related" href="/GameEngine/Unity/Unity%E7%A0%B4%E8%A7%A3/" title="Unity 破解"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/sadsadwqe456.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-18</div><div class="info-item-2">Unity 破解</div></div><div class="info-2"><div class="info-item-1">正文介绍   名字 网址    Ⅰ 本文以及所有标题和标签都是 AppNee 的原始内容。版权所有。要转发或复制，您必须在本文的 URL 旁添加一个明确的脚注！   Ⅱ 严格禁止任何手动或自动的整个网站的收集 / 爬取行为。   Ⅲ AppNee 上共享的任何资源都仅限于个人研究和研究，严禁任何形式的商业行为。否则，您可能会收到各种版权投诉，并且必须自己处理。   Ⅳ 在使用（尤其是下载）AppNee 共享的任何资源之前，请先或多或少地阅读我们的 常见问题解答 页面。否则，请自行承担所有后果。    这项工作已根据知识共享署名 - 非商业性 - 相同方式共享 4.0 国际许可进行了许可。    Unity（简称：Unity3D / Unity2D，简称 U3D）是目前 由丹麦Unity Technologies 开发的最受欢迎的多平台免费游戏引擎（主要用 C，C ++ 和 C＃编写，于 2005 年首次发布）。具有 C＃和 JavaScript 编程经验的用户可以更快地入门。 作为跨平台且高度集成的游戏开发工具（即，专业游戏引擎的全面集成），类似于 Adobe Director，...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Tamsiree</div><div class="author-info-description">勇于尝试才有可能迈向成功</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">143</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/tamsiree"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Tamsiree" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github-square"></i></a><a class="social-icon" href="mailto:tamsiree.com@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope-square"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只有用心灵才能看得清事物的本质，真正重要的东西是肉眼无法看见的。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%8F%A3%E6%B0%94%E8%A7%A3%E5%86%B3-RenderQueue%E3%80%81Ztest%E3%80%81Zwrite%E3%80%81AlphaTest%E3%80%81AlphaBlend-%E5%92%8C-Stencil"><span class="toc-number">2.1.</span> <span class="toc-text">一口气解决 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend 和 Stencil</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/" title="独立游戏的成功之母"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/552b1999aa4d5a2e75352fa2f6e93d51.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="独立游戏的成功之母"/></a><div class="content"><a class="title" href="/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/" title="独立游戏的成功之母">独立游戏的成功之母</a><time datetime="2025-11-11T05:08:38.000Z" title="发表于 2025-11-11 13:08:38">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="Docker 中 MongoDB 数据库的备份与恢复"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/cdd893c83169033d6b4a8354f1ab9d37.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker 中 MongoDB 数据库的备份与恢复"/></a><div class="content"><a class="title" href="/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="Docker 中 MongoDB 数据库的备份与恢复">Docker 中 MongoDB 数据库的备份与恢复</a><time datetime="2025-11-06T00:49:58.000Z" title="发表于 2025-11-06 08:49:58">2025-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity 多线程渲染导致部分手机崩溃"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/9408053447.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 多线程渲染导致部分手机崩溃"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity 多线程渲染导致部分手机崩溃">Unity 多线程渲染导致部分手机崩溃</a><time datetime="2023-11-09T11:55:51.000Z" title="发表于 2023-11-09 19:55:51">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的 CDN 之 jsDelivr"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/20b24a69649941669d83bb997b01fed6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="好用的 CDN 之 jsDelivr"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的 CDN 之 jsDelivr">好用的 CDN 之 jsDelivr</a><time datetime="2023-10-16T07:00:56.000Z" title="发表于 2023-10-16 15:00:56">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" title="Unity 坐标系统"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/wallhaven-z8rqjo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 坐标系统"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" title="Unity 坐标系统">Unity 坐标系统</a><time datetime="2023-10-14T06:11:46.000Z" title="发表于 2023-10-14 14:11:46">2023-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2016 - 2025 By Tamsiree</span></div><div class="footer_custom_text">不要盯着我看，已经到底啦～</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/js/tw_cn.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"placeholder":"留下你的脚印与心声~","pageSize":10,"lang":"zh-CN","requiredFields":["nick"],"avatar":"wavatar"}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.tamsiree.com',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !true) {
    if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8688374801147098" crossorigin="anonymous"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/talking/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>