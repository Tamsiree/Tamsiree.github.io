<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>红黑树 | Tamsiree</title><meta name="author" content="Tamsiree,tamsiree.com@gmail.com"><meta name="copyright" content="Tamsiree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。本文参考了《算法导论》中红黑树相关知识，加之自己的理解，然后以图文的形式对红黑树进行说明。本文的主要内容包括：红黑树的特性，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="红黑树">
<meta property="og:url" content="https://tamsiree.com/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91/">
<meta property="og:site_name" content="Tamsiree">
<meta property="og:description" content="R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。本文参考了《算法导论》中红黑树相关知识，加之自己的理解，然后以图文的形式对红黑树进行说明。本文的主要内容包括：红黑树的特性，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/thumb-1920-987815.jpg">
<meta property="article:published_time" content="2021-04-16T21:51:43.000Z">
<meta property="article:modified_time" content="2025-11-05T13:53:39.416Z">
<meta property="article:author" content="Tamsiree">
<meta property="article:tag" content="Research">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="红黑树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/thumb-1920-987815.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "红黑树",
  "url": "https://tamsiree.com/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91/",
  "image": "https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/thumb-1920-987815.jpg",
  "datePublished": "2021-04-16T21:51:43.000Z",
  "dateModified": "2025-11-05T13:53:39.416Z",
  "author": [
    {
      "@type": "Person",
      "name": "Tamsiree",
      "url": "https://tamsiree.com"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png"><link rel="canonical" href="https://tamsiree.com/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-8688374801147098',
  enable_page_level_ads: 'true'
});</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Tamsiree","link":"链接: ","source":"来源: Tamsiree","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '红黑树',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><script>if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') { window.location.href = window.location.href.replace('http:', 'https:'); }</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="Tamsiree" type="application/atom+xml">
</head><body><div class="bg-animation" id="web_bg" style="background-color: #f0f0f0;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">201</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">143</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/thumb-1920-987815.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Tamsiree</span></a><a class="nav-page-title" href="/"><span class="site-name">红黑树</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">红黑树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-16T21:51:43.000Z" title="发表于 2021-04-17 05:51:43">2021-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-05T13:53:39.416Z" title="更新于 2025-11-05 21:53:39">2025-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Research/">Research</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="R-B-Tree-简介"><a href="#R-B-Tree-简介" class="headerlink" title="**R-B Tree 简介 **"></a>**R-B Tree 简介 **</h3><p>    R-B Tree，全称是 Red-Black Tree，又称为 “红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red) 或黑(Black)。</p>
<p>** 红黑树的特性 **:<br><strong>（1）每个节点或者是黑色，或者是红色。</strong><br><strong>（2）根节点是黑色。</strong><br><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空 (NIL 或 NULL) 的叶子节点！]</strong><br><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br><strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p>
<p>** 注意 **：<br>(01) 特性 (3) 中的叶子节点，是只为空 (NIL 或 null) 的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接 ** 衡的二叉树。</p>
<p>红黑树示意图如下：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251730074203156.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251730074203156.jpg"></a></p>
<h3 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="** 红黑树的应用 **"></a>** 红黑树的应用 **</h3><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是 O(lgn)，效率非常之高。<br>例如，Java 集合中的 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3311268.html">TreeSet</a> 和 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3310928.html">TreeMap</a>，C++ STL 中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的。</p>
<h3 id="红黑树的时间复杂度和相关证明"><a href="#红黑树的时间复杂度和相关证明" class="headerlink" title="** 红黑树的时间复杂度和相关证明"></a>** 红黑树的时间复杂度和相关证明</h3><p>**</p>
<p>** 红黑树的时间复杂度为: O(lgn)**<br>下面通过 “_数学归纳法_” 对红黑树的时间复杂度进行证明。</p>
<p>定理：** 一棵含有 n 个节点的红黑树的高度至多为 2log(n+1)**.</p>
<p>证明：<br>    “一棵含有 n 个节点的红黑树的高度至多为 2log(n+1)” 的 ** 逆否命题 ** 是 “高度为 h 的红黑树，它的包含的内节点个数至少为 2h/2-1 个”。<br>    我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为 h 的红黑树，它的包含的内节点个数至少为 2h/2-1 个”。</p>
<p>    从某个节点 x 出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度 (x’s black height)，记为 <strong>bh(x)<strong>。关于 bh(x) 有两点需要说明： <br>    第 1 点：根据红黑树的 “</strong> 特性 (5)</strong> ，即_从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点_” 可知，从节点 x 出发到达的所有的叶节点具有相同数目的黑节点。** 这也就意味着，bh(x) 的值是唯一的 **！<br>    第 2 点：根据红黑色的 “特性(4)，即_如果一个节点是红色的，则它的子节点必须是黑色的_” 可知，从节点 x 出发达到叶节点 “所经历的黑节点数目”&gt;= “所经历的红节点的数目”。假设 x 是根节点，则可以得出结论 “<strong>bh(x) &gt;= h/2</strong>“。进而，我们只需证明 “高度为 h 的红黑树，它的包含的黑节点个数至少为 2bh(x)-1 个” 即可。</p>
<p>    到这里，我们将需要证明的定理已经由<br><strong>“一棵含有 n 个节点的红黑树的高度至多为 2log(n+1)”</strong><br>    转变成只需要证明<br><strong>“高度为 h 的红黑树，它的包含的内节点个数至少为 2bh(x)-1 个”。</strong></p>
<p>下面通过 “数学归纳法” 开始论证高度为 h 的红黑树，它的包含的内节点个数至少为 2bh(x)-1 个 “。</p>
<p>(01) 当树的高度 h=0 时，<br>    内节点个数是 0，bh(x) 为 0，2bh(x)-1 也为 0。显然，原命题成立。</p>
<p>(02) 当 h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2bh(x)-1-1。这个是根据 (01) 推断出来的！</p>
<p>    下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2bh(x)-1”。</p>
<p>    当树的高度为 h 时，<br>    对于节点 x(x 为根节点)，其黑高度为 bh(x)。<br>    对于节点 x 的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br>    根据 (02) 的已知条件，我们已知 “x 的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2bh(x)-1-1 个”；</p>
<p>    所以，节点 x 所包含的节点至少为 ( 2bh(x)-1-1 ) + ( 2bh(x)-1-1 ) + 1 = 2^bh(x)-1。即节点 x 所包含的节点至少为 2bh(x)-1。<br>    因此，原命题成立。</p>
<p>    由 (01)、(02) 得出，”高度为 h 的红黑树，它的包含的内节点个数至少为 2^bh(x)-1 个”。<br>    因此，“一棵含有 n 个节点的红黑树的高度至多为 2log(n+1)”。</p>
<h3 id="红黑树的基本操作-一-左旋和右旋"><a href="#红黑树的基本操作-一-左旋和右旋" class="headerlink" title="** 红黑树的基本操作(一) 左旋和右旋 **"></a>** 红黑树的基本操作(一) 左旋和右旋 **</h3><p>红黑树的基本操作是 ** 添加 <strong>、</strong> 删除 <strong>。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的 5 条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。<br>旋转包括两种：</strong> 左旋 ** 和 ** 右旋 **。下面分别对它们进行介绍。</p>
<p>**1. 左旋 **</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post//251733282013849.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251733282013849.jpg"></a></p>
<p>对 x 进行左旋，意味着 “将 x 变成一个左节点”。</p>
<p>左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解 “红黑树 T 的节点 x 进行左旋” 是如何进行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x) </span><br><span class="line">  <span class="comment">// 前提：这里假设 x 的右孩子为 y。下面开始正式操作</span></span><br><span class="line">  y ← right[x]            </span><br><span class="line">  <span class="comment">// 将 “y 的左孩子” 设为 “x 的右孩子”，即 将β设为 x 的右孩子</span></span><br><span class="line">  right[x] ← left[y]      </span><br><span class="line">  <span class="comment">// 将 “x” 设为 “y 的左孩子的父亲”，即 将β的父亲设为 x</span></span><br><span class="line">  p[left[y]] ← x          </span><br><span class="line">  <span class="comment">// 将 “x 的父亲” 设为 “y 的父亲”</span></span><br><span class="line">  p[y] ← p[x]             </span><br><span class="line">  <span class="keyword">if</span> p[x] = nil[T] </span><br><span class="line">  <span class="comment">// 情况 1：如果 “x 的父亲” 是空节点，则将 y 设为根节点</span></span><br><span class="line">  then root[T] ← y                 </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> x = left[p[x]] </span><br><span class="line">            <span class="comment">// 情况 2：如果 x 是它父节点的左孩子，则将 y 设为“x 的父节点的左孩子”</span></span><br><span class="line">            then left[p[x]] ← y    </span><br><span class="line">            <span class="comment">// 情况 3：(x 是它父节点的右孩子) 将 y 设为“x 的父节点的右孩子”</span></span><br><span class="line">            <span class="keyword">else</span> right[p[x]] ← y   </span><br><span class="line">  <span class="comment">// 将 “x” 设为 “y 的左孩子”</span></span><br><span class="line">  left[y] ← x             </span><br><span class="line">  <span class="comment">// 将 “x 的父节点” 设为 “y”</span></span><br><span class="line">  p[x] ← y                </span><br></pre></td></tr></table></figure>

<p>理解左旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251734577643655.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251734577643655.jpg"></a></p>
<p>**2. 右旋 **</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251735527958942.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251735527958942.jpg"></a></p>
<p>对 x 进行左旋，意味着 “将 x 变成一个左节点”。</p>
<p>右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解 “红黑树 T 的节点 y 进行右旋” 是如何进行的。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y) </span><br><span class="line">  <span class="comment">// 前提：这里假设 y 的左孩子为 x。下面开始正式操作</span></span><br><span class="line">  x ← left[y]             </span><br><span class="line">  <span class="comment">// 将 “x 的右孩子” 设为 “y 的左孩子”，即 将β设为 y 的左孩子</span></span><br><span class="line">  left[y] ← right[x]      </span><br><span class="line">  <span class="comment">// 将 “y” 设为 “x 的右孩子的父亲”，即 将β的父亲设为 y</span></span><br><span class="line">  p[right[x]] ← y         </span><br><span class="line">  <span class="comment">// 将 “y 的父亲” 设为 “x 的父亲”</span></span><br><span class="line">  p[x] ← p[y]             </span><br><span class="line">  <span class="keyword">if</span> p[y] = nil[T] </span><br><span class="line">  <span class="comment">// 情况 1：如果 “y 的父亲” 是空节点，则将 x 设为根节点</span></span><br><span class="line">  then root[T] ← x                 </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> y = right[p[y]] </span><br><span class="line">            <span class="comment">// 情况 2：如果 y 是它父节点的右孩子，则将 x 设为“y 的父节点的左孩子”</span></span><br><span class="line">            then right[p[y]] ← x   </span><br><span class="line">            <span class="comment">// 情况 3：(y 是它父节点的左孩子) 将 x 设为“y 的父节点的左孩子”</span></span><br><span class="line">            <span class="keyword">else</span> left[p[y]] ← x    </span><br><span class="line">  <span class="comment">// 将 “y” 设为 “x 的右孩子”</span></span><br><span class="line">  right[x] ← y            </span><br><span class="line">  <span class="comment">// 将 “y 的父节点” 设为 “x”</span></span><br><span class="line">  p[y] ← x                </span><br></pre></td></tr></table></figure>

<p>理解右旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251737465769614.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251737465769614.jpg"></a></p>
<p>** 旋转总结 **：</p>
<p>(01) 左旋 和 右旋 是相对的两个概念，原理类似。理解一个也就理解了另一个。</p>
<p>(02) 下面谈谈如何区分 左旋 和 右旋。<br>在实际应用中，若没有彻底理解 左旋 和 右旋，可能会将它们混淆。下面谈谈我对如何区分 左旋 和 右旋 的理解。</p>
<p>**3. 区分 左旋 和 右旋 **</p>
<p>仔细观察上面 “左旋” 和 “右旋” 的示意图。我们能清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，在旋转前是二叉查找树，并且旋转之后仍然是一颗二叉查找树。</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251739385617803.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251739385617803.jpg"></a></p>
<p>** 左旋示例图 **(以 x 为节点进行左旋)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                            z</span><br><span class="line">  x                        /                  </span><br><span class="line"> / \       --(左旋)--&gt;    x</span><br><span class="line">y   z                    / </span><br><span class="line">                        y</span><br></pre></td></tr></table></figure>

<p>对 x 进行左旋，意味着，将 “x 的右孩子” 设为“x 的父亲节点”；即，将 x 变成了一个左节点(x 成了为 z 的左孩子)！。 因此，** 左旋中的“左”，意味着“被旋转的节点将变成一个左节点”**。</p>
<p>** 右旋示例图 **(以 x 为节点进行右旋)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                           y</span><br><span class="line">  x                         \                           </span><br><span class="line"> / \       --(右旋)--&gt;        x</span><br><span class="line">y   z                          \</span><br><span class="line">                                z                          </span><br></pre></td></tr></table></figure>


<p>对 x 进行右旋，意味着，将 “x 的左孩子” 设为“x 的父亲节点”；即，将 x 变成了一个右节点(x 成了为 y 的右孩子)！ 因此，** 右旋中的“右”，意味着“被旋转的节点将变成一个右节点”**。</p>
<h3 id="红黑树的基本操作-二-添加"><a href="#红黑树的基本操作-二-添加" class="headerlink" title="** 红黑树的基本操作(二) 添加 **"></a>** 红黑树的基本操作(二) 添加 **</h3><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p>
<p>** 第一步: 将红黑树当作一颗二叉查找树，将节点插入。**<br>       红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>       好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p>
<p>** 第二步：将插入的节点着色为 “红色”。**<br>       为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [ 注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>       将插入的节点着色为红色，不会违背 “特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o… 哈哈</p>
<p>** 第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。**<br>       第二步中，将插入节点着色为 “红色” 之后，不会违背 “特性(5)”。那它到底会违背哪些特性呢？<br>       对于 “特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>       对于 “特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>       对于 “特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>       对于 “特性(4)”，是有可能违背的！<br>       那接下来，想办法使之 “满足特性(4)”，就可以将树重新构造成红黑树了。</p>
<p>下面看看代码到底是怎样实现这三步的。</p>
<p>添加操作的伪代码《算法导论》</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T, z) </span><br><span class="line">  <span class="comment">// 新建节点 “y”，将 y 设为空节点。</span></span><br><span class="line">  y ← nil[T]                        </span><br><span class="line">  <span class="comment">// 设“红黑树 T” 的根节点为 “x”</span></span><br><span class="line">  x ← root[T]                       </span><br><span class="line">  <span class="comment">// 找出要插入的节点“z” 在二叉树 T 中的位置 “y”</span></span><br><span class="line">  <span class="keyword">while</span> x ≠ nil[T]                  </span><br><span class="line">      <span class="keyword">do</span> y ← x </span><br><span class="line">         <span class="keyword">if</span> key[z] &lt; key[x] </span><br><span class="line"> then x ← left[x] </span><br><span class="line">            <span class="keyword">else</span> x ← right[x] </span><br><span class="line">  <span class="comment">// 设置 “z 的父亲” 为 “y”</span></span><br><span class="line">  p[z] ← y                          </span><br><span class="line">  <span class="keyword">if</span> y = nil[T] </span><br><span class="line">     <span class="comment">// 情况 1：若 y 是空节点，则将 z 设为根</span></span><br><span class="line">     then root[T] ← z               </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> key[z] &lt; key[y] </span><br><span class="line">             <span class="comment">// 情况 2：若“z 所包含的值” &lt; “y 所包含的值”，则将 z 设为“y 的左孩子”</span></span><br><span class="line">             then left[y] ← z       </span><br><span class="line">             <span class="comment">// 情况 3：(“z 所包含的值” &gt;= “y 所包含的值”) 将 z 设为 “y 的右孩子” </span></span><br><span class="line">             <span class="keyword">else</span> right[y] ← z      </span><br><span class="line">  <span class="comment">// z 的左孩子设为空</span></span><br><span class="line">  left[z] ← nil[T]                  </span><br><span class="line">  <span class="comment">// z 的右孩子设为空。至此，已经完成将“节点 z 插入到二叉树” 中了。</span></span><br><span class="line">  right[z] ← nil[T]                 </span><br><span class="line">  <span class="comment">// 将 z 着色为“红色”</span></span><br><span class="line">  color[z] ← RED                    </span><br><span class="line">  <span class="comment">// 通过 RB-INSERT-FIXUP 对红黑树的节点进行颜色修改以及旋转，让树 T 仍然是一颗红黑树</span></span><br><span class="line">  RB-INSERT-FIXUP(T, z)             </span><br></pre></td></tr></table></figure>

<p>结合伪代码以及为代码上面的说明，先理解 RB-INSERT。理解了 RB-INSERT 之后，我们接着对 RB-INSERT-FIXUP 的伪代码进行说明。</p>
<p>添加修正操作的伪代码《算法导论》</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z) </span><br><span class="line"> <span class="comment">// 若 “当前节点(z) 的父节点是红色”，则进行以下处理。</span></span><br><span class="line"> <span class="keyword">while</span> color[p[z]] = RED                                                  </span><br><span class="line">     <span class="comment">// 若 “z 的父节点” 是“z 的祖父节点的左孩子”，则进行以下处理。</span></span><br><span class="line">     <span class="keyword">do</span> <span class="keyword">if</span> p[z] = left[p[p[z]]]                                           </span><br><span class="line">           <span class="comment">// 将 y 设置为 “z 的叔叔节点(z 的祖父节点的右孩子)”</span></span><br><span class="line">           then y ← right[p[p[z]]]                                        </span><br><span class="line">                <span class="comment">// Case 1 条件：叔叔是红色</span></span><br><span class="line">                <span class="keyword">if</span> color[y] = RED                                         </span><br><span class="line">                   <span class="comment">// (01) 将“父节点” 设为黑色。</span></span><br><span class="line">                   then color[p[z]] ← BLACK                    ▹ Case <span class="number">1</span>   </span><br><span class="line">                        <span class="comment">// (02) 将 “叔叔节点” 设为黑色。</span></span><br><span class="line">                        color[y] ← BLACK                       ▹ Case <span class="number">1</span>   </span><br><span class="line">                        <span class="comment">// (03) 将 “祖父节点” 设为 “红色”。</span></span><br><span class="line">                        color[p[p[z]]] ← RED                   ▹ Case <span class="number">1</span>   </span><br><span class="line">                        <span class="comment">// (04) 将“祖父节点” 设为 “当前节点”(红色节点)</span></span><br><span class="line">                        z ← p[p[z]]                            ▹ Case <span class="number">1</span>   </span><br><span class="line">                   <span class="comment">// Case 2 条件：叔叔是黑色，且当前节点是右孩子</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> z = right[p[z]]                                </span><br><span class="line">                           <span class="comment">// (01) 将“父节点” 作为 “新的当前节点”。</span></span><br><span class="line">                           then z ← p[z]                       ▹ Case <span class="number">2</span>   </span><br><span class="line">                                <span class="comment">// (02) 以“新的当前节点” 为支点进行左旋。</span></span><br><span class="line">                                LEFT-ROTATE(T, z)              ▹ Case <span class="number">2</span>   </span><br><span class="line">                           <span class="comment">// Case 3 条件：叔叔是黑色，且当前节点是左孩子。(01) 将 “父节点” 设为 “黑色”。</span></span><br><span class="line">                           color[p[z]] ← BLACK                 ▹ Case <span class="number">3</span>   </span><br><span class="line">                           <span class="comment">// (02) 将“祖父节点” 设为 “红色”。</span></span><br><span class="line">                           color[p[p[z]]] ← RED                ▹ Case <span class="number">3</span>   </span><br><span class="line">                           <span class="comment">// (03) 以“祖父节点” 为支点进行右旋。</span></span><br><span class="line">                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case <span class="number">3</span>   </span><br><span class="line">        <span class="comment">// 若 “z 的父节点” 是“z 的祖父节点的右孩子”，将上面的操作中 “right” 和“left”交换位置，然后依次执行。</span></span><br><span class="line">        <span class="keyword">else</span> (same as then clause with <span class="string">&quot;right&quot;</span> and <span class="string">&quot;left&quot;</span> exchanged)      </span><br><span class="line"> color[root[T]] ← BLACK </span><br></pre></td></tr></table></figure>

<p>根据被插入节点的父节点的情况，可以将 “当节点 z 被着色为红色节点，并插入二叉树” 划分为三种情况来处理。<br>① 情况说明：被插入的节点是根节点。<br>    处理方法：直接把此节点涂为黑色。<br>② 情况说明：被插入的节点的父节点是黑色。<br>    处理方法：什么也不需要做。节点被插入后，仍然是红黑树。<br>③ 情况说明：被插入的节点的父节点是红色。<br>    处理方法：那么，该情况与红黑树的 “特性(5)” 相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据 “叔叔节点的情况”，将这种情况进一步划分为 3 种情况(Case)。</p>
<p> </p>
<p>** 现象说明 **</p>
<p>** 处理策略 **</p>
<p>Case 1</p>
<p>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</p>
<p>(01) 将 “父节点” 设为黑色。<br>(02) 将 “叔叔节点” 设为黑色。<br>(03) 将 “祖父节点” 设为“红色”。<br>(04) 将 “祖父节点” 设为 “当前节点”(红色节点)；即，之后继续对“当前节点” 进行操作。</p>
<p>Case 2</p>
<p>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</p>
<p>(01) 将 “父节点” 作为“新的当前节点”。<br>(02) 以 “新的当前节点” 为支点进行左旋。</p>
<p>Case 3</p>
<p>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p>
<p>(01) 将 “父节点” 设为“黑色”。<br>(02) 将 “祖父节点” 设为“红色”。<br>(03) 以 “祖父节点” 为支点进行右旋。</p>
<p>上面三种情况 (Case) 处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。下面对它们详细进行介绍。</p>
<p>**1. (Case 1)叔叔是红色 **</p>
<p>**1.1 现象说明 **<br>当前节点 (即，被插入节点) 的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</p>
<p>**1.2 处理策略 **<br>(01) 将 “父节点” 设为黑色。<br>(02) 将 “叔叔节点” 设为黑色。<br>(03) 将 “祖父节点” 设为“红色”。<br>(04) 将 “祖父节点” 设为 “当前节点”(红色节点)；即，之后继续对“当前节点” 进行操作。</p>
<p>    ** 下面谈谈为什么要这样处理。**(建议理解的时候，通过下面的图进行对比)<br>    “当前节点”和 “父节点” 都是红色，违背 “特性(4)”。所以，将“父节点” 设置 “黑色” 以解决这个问题。<br>    但是，将 “父节点” 由“红色”变成 “黑色” 之后，违背了 “特性(5)”：因为，包含“父节点” 的分支的黑色节点的总数增加了 1。  解决这个问题的办法是：将 “祖父节点” 由“黑色”变成红色，同时，将 “叔叔节点” 由“红色”变成 “黑色”。关于这里，说明几点：第一，为什么“祖父节点” 之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么 “祖父节点” 一定是黑色。 第二，为什么将 “祖父节点” 由“黑色”变成红色，同时，将 “叔叔节点” 由“红色”变成 “黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了 1” 的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了 1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了 1”，既然这样，我们通过将 “祖父节点” 由“黑色”变成 “红色” 以解决 “包含‘祖父节点’的分支的黑色节点的总数增加了 1” 的问题； 但是，这样处理之后又会引起另一个问题 “包含‘叔叔’节点的分支的黑色节点的总数减少了 1”，现在我们已知“叔叔节点” 是“红色”，将 “叔叔节点” 设为 “黑色” 就能解决这个问题。 所以，将 “祖父节点” 由“黑色”变成红色，同时，将 “叔叔节点” 由“红色”变成“黑色”；就解决了该问题。<br>    按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为 “黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点” 设为 “新的当前节点”，接着对“新的当前节点” 进行分析。</p>
<p>**1.3 示意图 **</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251759273578917.jpg"><strong><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251759273578917.jpg"></strong></a></p>
<p>**2. (Case 2)叔叔是黑色，且当前节点是右孩子 **</p>
<p>**2.1 现象说明 **<br>当前节点 (即，被插入节点) 的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</p>
<p>**2.2 处理策略 **<br>(01) 将 “父节点” 作为“新的当前节点”。<br>(02) 以 “新的当前节点” 为支点进行左旋。</p>
<p>      ** 下面谈谈为什么要这样处理。**(建议理解的时候，通过下面的图进行对比)<br>      首先，将 “父节点” 作为 “新的当前节点”；接着，以“新的当前节点” 为支点进行左旋。 为了便于理解，我们先说明第 (02) 步，再说明第 (01) 步；为了便于说明，我们设置 “父节点” 的代号为 F(Father)，“当前节点”的代号为 S(Son)。<br>为什么要 “以 F 为支点进行左旋” 呢？根据已知条件可知：S 是 F 的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是 “将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而 S 又是一个右孩子，因此，我们可以通过“左旋” 来将 S 上移！<br>      按照上面的步骤 (以 F 为支点进行左旋) 处理之后：若 S 变成了根节点，那么直接将其设为 “黑色”，就完全解决问题了；若 S 不是根节点，那我们需要执行步骤(01)，即“将 F 设为‘新的当前节点’”。那为什么不继续以 S 为新的当前节点继续处理，而需要以 F 为新的当前节点来进行处理呢？这是因为“左旋” 之后，F 变成了 S 的 “子节点”，即 S 变成了 F 的父节点；而我们处理问题的时候，需要从下至上(由叶到根) 方向进行处理；也就是说，必须先解决 “孩子” 的问题，再解决 “父亲” 的问题；所以，我们执行步骤 (01)：将“父节点” 作为“新的当前节点”。</p>
<p>**2.2 示意图 **</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251801031546918.jpg"><strong><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251801031546918.jpg"></strong></a></p>
<p>**3. (Case 3)叔叔是黑色，且当前节点是左孩子 **</p>
<p>**3.1 现象说明 **<br>当前节点 (即，被插入节点) 的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p>
<p>**3.2 处理策略 **<br>(01) 将 “父节点” 设为“黑色”。<br>(02) 将 “祖父节点” 设为“红色”。<br>(03) 以 “祖父节点” 为支点进行右旋。</p>
<p>      ** 下面谈谈为什么要这样处理。**(建议理解的时候，通过下面的图进行对比)<br>      为了便于说明，我们设置 “当前节点” 为 S(Original Son)，“兄弟节点”为 B(Brother)，“叔叔节点”为 U(Uncle)，“父节点”为 F(Father)，祖父节点为 G(Grand-Father)。<br>      S 和 F 都是红色，违背了红黑树的 “特性(4)”，我们可以将 F 由“红色” 变为 “黑色”，就解决了“违背‘特性(4)’” 的问题；但却引起了其它问题：违背特性 (5)，因为将 F 由红色改为黑色之后，所有经过 F 的分支的黑色节点的个数增加了 1。那我们如何解决“所有经过 F 的分支的黑色节点的个数增加了 1” 的问题呢？ 我们可以通过 “将 G 由黑色变成红色”，同时“以 G 为支点进行右旋” 来解决。</p>
<p>**2.3 示意图 **</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/170945094945387.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/170945094945387.jpg"></a></p>
<p>提示：上面的进行 Case 3 处理之后，再将节点 “120” 当作当前节点，就变成了 Case 2 的情况。</p>
<h3 id="红黑树的基本操作-三-删除"><a href="#红黑树的基本操作-三-删除" class="headerlink" title="** 红黑树的基本操作(三) 删除 **"></a>** 红黑树的基本操作(三) 删除 **</h3><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过 “旋转和重新着色” 等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p>
<p>** 第一步：将红黑树当作一颗二叉查找树，将节点删除。**<br>       这和 “删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况：<br>       ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。<br>       ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>       ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把 “它的后继节点的内容” 复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给 “被删除节点” 之后，再将后继节点删除。这样就巧妙的将问题转换为 “删除后继节点” 的情况了，下面就考虑后继节点。 在 “被删除节点” 有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然 “的后继节点” 不可能双子都非空，就意味着 “该节点的后继节点” 要么没有儿子，要么只有一个儿子。若没有儿子，则按 “情况①” 进行处理；若只有一个儿子，则按 “情况②” 进行处理。</p>
<p>** 第二步：通过 “旋转和重新着色” 等一系列来修正该树，使之重新成为一棵红黑树。**<br>       因为 “第一步” 中删除节点之后，可能会违背红黑树的特性。所以需要通过 “旋转和重新着色” 来修正该树，使之重新成为一棵红黑树。</p>
<p>删除操作的伪代码《算法导论》</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z) </span><br><span class="line"> <span class="keyword">if</span> left[z] = nil[T] or right[z] = nil[T] </span><br><span class="line">    <span class="comment">// 若 “z 的左孩子” 或 “z 的右孩子” 为空，则将 “z” 赋值给 “y”；</span></span><br><span class="line">    then y ← z                                  </span><br><span class="line">    <span class="comment">// 否则，将 “z 的后继节点” 赋值给 “y”。</span></span><br><span class="line">    <span class="keyword">else</span> y ← TREE-SUCCESSOR(z)                  </span><br><span class="line"> <span class="keyword">if</span> left[y] ≠ nil[T] </span><br><span class="line">    <span class="comment">// 若“y 的左孩子” 不为空，则将“y 的左孩子” 赋值给 “x”；</span></span><br><span class="line">    then x ← left[y]                            </span><br><span class="line">    <span class="keyword">else</span> x ← right[y]                           <span class="comment">// 否则，“y 的右孩子” 赋值给 “x”。</span></span><br><span class="line"> <span class="comment">// 将“y 的父节点” 设置为 “x 的父节点”</span></span><br><span class="line"> p[x] ← p[y]                                    </span><br><span class="line"> <span class="keyword">if</span> p[y] = nil[T] </span><br><span class="line">    <span class="comment">// 情况 1：若“y 的父节点” 为空，则设置“x” 为 “根节点”。</span></span><br><span class="line">    then root[T] ← x                            </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> y = left[p[y]] </span><br><span class="line">            <span class="comment">// 情况 2：若“y 是它父节点的左孩子”，则设置“x” 为 “y 的父节点的左孩子”</span></span><br><span class="line">            then left[p[y]] ← x                 </span><br><span class="line">            <span class="comment">// 情况 3：若“y 是它父节点的右孩子”，则设置“x” 为 “y 的父节点的右孩子”</span></span><br><span class="line">            <span class="keyword">else</span> right[p[y]] ← x                </span><br><span class="line"> <span class="keyword">if</span> y ≠ z </span><br><span class="line">    <span class="comment">// 若“y 的值” 赋值给 “z”。注意：这里只拷贝 z 的值给 y，而没有拷贝 z 的颜色！！！</span></span><br><span class="line">    then key[z] ← key[y]                        </span><br><span class="line">         copy y<span class="string">&#x27;s satellite data into z </span></span><br><span class="line"><span class="string"> if color[y] = BLACK </span></span><br><span class="line"><span class="string">    // 若“y 为黑节点”，则调用</span></span><br><span class="line"><span class="string">    then RB-DELETE-FIXUP(T, x)                  </span></span><br><span class="line"><span class="string"> return y </span></span><br></pre></td></tr></table></figure>

<p>结合伪代码以及为代码上面的说明，先理解 RB-DELETE。理解了 RB-DELETE 之后，接着对 RB-DELETE-FIXUP 的伪代码进行说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x) </span><br><span class="line"> <span class="keyword">while</span> x ≠ root[T] and color[x] = BLACK </span><br><span class="line">     <span class="keyword">do</span> <span class="keyword">if</span> x = left[p[x]] </span><br><span class="line">           <span class="comment">// 若 “x”是 “它父节点的左孩子”，则设置 “w” 为“x 的叔叔”(即 x 为它父节点的右孩子) </span></span><br><span class="line">           then w ← right[p[x]]                                             </span><br><span class="line">                <span class="comment">// Case 1: x 是 “黑 + 黑” 节点，x 的兄弟节点是红色。(此时 x 的父节点和 x 的兄弟节点的子节点都是黑节点)。</span></span><br><span class="line">                <span class="keyword">if</span> color[w] = RED                                           </span><br><span class="line">                   <span class="comment">// (01) 将 x 的兄弟节点设为 “黑色”。</span></span><br><span class="line">                   then color[w] ← BLACK                        ▹  Case <span class="number">1</span>   </span><br><span class="line">                        <span class="comment">// (02) 将 x 的父节点设为“红色”。</span></span><br><span class="line">                        color[p[x]] ← RED                       ▹  Case <span class="number">1</span>   </span><br><span class="line">                        <span class="comment">// (03) 对 x 的父节点进行左旋。</span></span><br><span class="line">                        LEFT-ROTATE(T, p[x])                    ▹  Case <span class="number">1</span>   </span><br><span class="line">                        <span class="comment">// (04) 左旋后，重新设置 x 的兄弟节点。</span></span><br><span class="line">                        w ← right[p[x]]                         ▹  Case <span class="number">1</span>   </span><br><span class="line">                <span class="comment">// Case 2: x 是“黑 + 黑” 节点，x 的兄弟节点是黑色，x 的兄弟节点的两个孩子都是黑色。</span></span><br><span class="line">                <span class="keyword">if</span> color[left[w]] = BLACK and color[right[w]] = BLACK       </span><br><span class="line">                   <span class="comment">// (01) 将 x 的兄弟节点设为 “红色”。</span></span><br><span class="line">                   then color[w] ← RED                          ▹  Case <span class="number">2</span>   </span><br><span class="line">                        <span class="comment">// (02) 设置“x 的父节点” 为“新的 x 节点”。</span></span><br><span class="line">                        x ←  p[x]                               ▹  Case <span class="number">2</span>   </span><br><span class="line">                   <span class="comment">// Case 3: x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的左孩子是红色，右孩子是黑色的。</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> color[right[w]] = BLACK                          </span><br><span class="line">                           <span class="comment">// (01) 将 x 兄弟节点的左孩子设为 “黑色”。</span></span><br><span class="line">                           then color[left[w]] ← BLACK          ▹  Case <span class="number">3</span>   </span><br><span class="line">                                <span class="comment">// (02) 将 x 兄弟节点设为“红色”。</span></span><br><span class="line">                                color[w] ← RED                  ▹  Case <span class="number">3</span>   </span><br><span class="line">                                <span class="comment">// (03) 对 x 的兄弟节点进行右旋。</span></span><br><span class="line">                                RIGHT-ROTATE(T, w)              ▹  Case <span class="number">3</span>   </span><br><span class="line">                                <span class="comment">// (04) 右旋后，重新设置 x 的兄弟节点。</span></span><br><span class="line">                                w ← right[p[x]]                 ▹  Case <span class="number">3</span>   </span><br><span class="line">                        <span class="comment">// Case 4: x 是“黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的右孩子是红色的。(01) 将 x 父节点颜色 赋值给 x 的兄弟节点。</span></span><br><span class="line">                         color[w] ← color[p[x]]                 ▹  Case <span class="number">4</span>   </span><br><span class="line">                         <span class="comment">// (02) 将 x 父节点设为 “黑色”。</span></span><br><span class="line">                         color[p[x]] ← BLACK                    ▹  Case <span class="number">4</span>   </span><br><span class="line">                         <span class="comment">// (03) 将 x 兄弟节点的右子节设为“黑色”。</span></span><br><span class="line">                         color[right[w]] ← BLACK                ▹  Case <span class="number">4</span>   </span><br><span class="line">                         <span class="comment">// (04) 对 x 的父节点进行左旋。</span></span><br><span class="line">                         LEFT-ROTATE(T, p[x])                   ▹  Case <span class="number">4</span>   </span><br><span class="line">                         <span class="comment">// (05) 设置“x” 为“根节点”。</span></span><br><span class="line">                         x ← root[T]                            ▹  Case <span class="number">4</span>   </span><br><span class="line">        <span class="comment">// 若 “x”是 “它父节点的右孩子”，将上面的操作中“right” 和“left”交换位置，然后依次执行。</span></span><br><span class="line">        <span class="keyword">else</span> (same as then clause with <span class="string">&quot;right&quot;</span> and <span class="string">&quot;left&quot;</span> exchanged)        </span><br><span class="line"> color[x] ← BLACK   </span><br></pre></td></tr></table></figure>

<p>下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [ 注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>      前面我们将 “删除红黑树中的节点” 大致分为两步，在第一步中 “将红黑树当作一颗二叉查找树，将节点删除” 后，可能违反 “特性(2)、(4)、(5)” 三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。<br>      为了便于分析，我们假设 “x 包含一个额外的黑色”(x 原本的颜色还存在)，这样就不会违反 “特性(5)”。为什么呢？<br>      通过 RB-DELETE 算法，我们知道：删除节点 y 之后，x 占据了原来节点 y 的位置。 既然删除 y(y 是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设 “x 包含一个额外的黑色”，就正好弥补了 “删除 y 所丢失的黑色节点”，也就不会违反 “特性(5)”。 因此，假设 “x 包含一个额外的黑色”(x 原本的颜色还存在)，这样就不会违反 “特性(5)”。<br>      现在，x 不仅包含它原本的颜色属性，x 还包含一个额外的黑色。即 x 的颜色属性是 “红 + 黑” 或 “黑 + 黑”，它违反了 “特性(1)”。</p>
<p>      现在，我们面临的问题，由解决 “违反了特性 (2)、(4)、(5) 三个特性” 转换成了 “解决违反特性 (1)、(2)、(4) 三个特性”。RB-DELETE-FIXUP 需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP 的思想是：将 x 所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：<br>a) x 指向一个 “红 + 黑” 节点。此时，将 x 设为一个 “黑” 节点即可。<br>b) x 指向根。此时，将 x 设为一个 “黑” 节点即可。<br>c) 非前面两种姿态。</p>
<p>将上面的姿态，可以概括为 3 种情况。<br>① 情况说明：x 是 “红 + 黑” 节点。<br>    处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。<br>② 情况说明：x 是 “黑 + 黑” 节点，且 x 是根。<br>    处理方法：什么都不做，结束。此时红黑树性质全部恢复。<br>③ 情况说明：x 是 “黑 + 黑” 节点，且 x 不是根。<br>    处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：</p>
<p> </p>
<p>** 现象说明 **</p>
<p>** 处理策略 **</p>
<p><strong>Case 1</strong></p>
<p>x 是 “黑 + 黑” 节点，x 的兄弟节点是红色。(此时 x 的父节点和 x 的兄弟节点的子节点都是黑节点)。</p>
<p>(01) 将 x 的兄弟节点设为“黑色”。<br>(02) 将 x 的父节点设为“红色”。<br>(03) 对 x 的父节点进行左旋。<br>(04) 左旋后，重新设置 x 的兄弟节点。</p>
<p><strong>Case 2</strong></p>
<p>x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色，x 的兄弟节点的两个孩子都是黑色。</p>
<p>(01) 将 x 的兄弟节点设为“红色”。<br>(02) 设置 “x 的父节点” 为“新的 x 节点”。</p>
<p><strong>Case 3</strong></p>
<p>x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的左孩子是红色，右孩子是黑色的。</p>
<p>(01) 将 x 兄弟节点的左孩子设为“黑色”。<br>(02) 将 x 兄弟节点设为“红色”。<br>(03) 对 x 的兄弟节点进行右旋。<br>(04) 右旋后，重新设置 x 的兄弟节点。</p>
<p><strong>Case 4</strong></p>
<p>x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的右孩子是红色的，x 的兄弟节点的左孩子任意颜色。</p>
<p>(01) 将 x 父节点颜色 赋值给 x 的兄弟节点。<br>(02) 将 x 父节点设为“黑色”。<br>(03) 将 x 兄弟节点的右子节设为“黑色”。<br>(04) 对 x 的父节点进行左旋。<br>(05) 设置 “x” 为“根节点”。</p>
<p>**1. (Case 1)x 是 “黑 + 黑” 节点，x 的兄弟节点是红色 **</p>
<p>**1.1 现象说明 **<br>x 是 “黑 + 黑” 节点，x 的兄弟节点是红色。(此时 x 的父节点和 x 的兄弟节点的子节点都是黑节点)。</p>
<p>**1.2 处理策略 **<br>(01) 将 x 的兄弟节点设为“黑色”。<br>(02) 将 x 的父节点设为“红色”。<br>(03) 对 x 的父节点进行左旋。<br>(04) 左旋后，重新设置 x 的兄弟节点。</p>
<p>      ** 下面谈谈为什么要这样处理。**(建议理解的时候，通过下面的图进行对比)<br>      这样做的目的是将 “Case 1” 转换为 “Case 2”、“Case 3” 或“Case 4”，从而进行进一步的处理。对 x 的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将 x 的兄弟节点设为黑色”，同时“将 x 的父节点设为红色”；左旋后，由于 x 的兄弟节点发生了变化，需要更新 x 的兄弟节点，从而进行后续处理。</p>
<p>**1.3 示意图 **  </p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251813539515702.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251813539515702.jpg"></a></p>
<p>**2. (Case 2) x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色，x 的兄弟节点的两个孩子都是黑色 **</p>
<p>**2.1 现象说明 **<br>x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色，x 的兄弟节点的两个孩子都是黑色。</p>
<p>**2.2 处理策略 **<br>(01) 将 x 的兄弟节点设为“红色”。<br>(02) 设置 “x 的父节点” 为“新的 x 节点”。</p>
<p>      ** 下面谈谈为什么要这样处理。**(建议理解的时候，通过下面的图进行对比)<br>      这个情况的处理思想：是将 “x 中多余的一个黑色属性上移(往根方向移动)”。 x 是“黑 + 黑” 节点，我们将 x 由 “黑 + 黑” 节点 变成 “黑”节点，多余的一个 “黑” 属性移到 x 的父节点中，即 x 的父节点多出了一个黑属性 (若 x 的父节点原先是“黑”，则此时变成了“黑 + 黑”；若 x 的父节点原先时“红”，则此时变成了“红 + 黑”)。 此时，需要注意的是：所有经过 x 的分支中黑节点个数没变化；但是，所有经过 x 的兄弟节点的分支中黑色节点的个数增加了 1(因为 x 的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过 x 的兄弟节点的分支中黑色节点的个数减 1” 即可，那么就可以通过 “将 x 的兄弟节点由黑色变成红色” 来实现。<br>      经过上面的步骤 (将 x 的兄弟节点设为红色)，多余的一个颜色属性(黑色) 已经跑到 x 的父节点中。我们需要将 x 的父节点设为 “新的 x 节点” 进行处理。若 “新的 x 节点” 是“黑 + 红”，直接将 “新的 x 节点” 设为黑色，即可完全解决该问题；若 “新的 x 节点” 是“黑 + 黑”，则需要对 “新的 x 节点” 进行进一步处理。</p>
<p>**2.3 示意图 **  </p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251814572322069.jpg"><strong><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251814572322069.jpg"></strong></a></p>
<p>**3. (Case 3)x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的左孩子是红色，右孩子是黑色的 **</p>
<p>**3.1 现象说明 **<br>x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的左孩子是红色，右孩子是黑色的。</p>
<p>**3.2 处理策略 **<br>(01) 将 x 兄弟节点的左孩子设为“黑色”。<br>(02) 将 x 兄弟节点设为“红色”。<br>(03) 对 x 的兄弟节点进行右旋。<br>(04) 右旋后，重新设置 x 的兄弟节点。</p>
<p>       ** 下面谈谈为什么要这样处理。**(建议理解的时候，通过下面的图进行对比)<br>       我们处理 “Case 3” 的目的是为了将 “Case 3” 进行转换，转换成“Case 4”, 从而进行进一步的处理。转换的方式是对 x 的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将 x 的兄弟节点的左孩子设为黑色”，同时“将 x 的兄弟节点设为红色”；右旋后，由于 x 的兄弟节点发生了变化，需要更新 x 的兄弟节点，从而进行后续处理。</p>
<p>**3.3 示意图 **  </p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251815496235531.jpg"><strong><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251815496235531.jpg"></strong></a></p>
<p>**4. (Case 4)x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的右孩子是红色的，x 的兄弟节点的左孩子任意颜色 **</p>
<p>**4.1 现象说明 **<br>x 是 “黑 + 黑” 节点，x 的兄弟节点是黑色；x 的兄弟节点的右孩子是红色的，x 的兄弟节点的左孩子任意颜色。</p>
<p>**4.2 处理策略 **<br>(01) 将 x 父节点颜色 赋值给 x 的兄弟节点。<br>(02) 将 x 父节点设为“黑色”。<br>(03) 将 x 兄弟节点的右子节设为“黑色”。<br>(04) 对 x 的父节点进行左旋。<br>(05) 设置 “x” 为“根节点”。</p>
<p>      ** 下面谈谈为什么要这样处理。**(建议理解的时候，通过下面的图进行对比)<br>      我们处理 “Case 4” 的目的是：去掉 x 中额外的黑色，将 x 变成单独的黑色。处理的方式是“：进行颜色修改，然后对 x 的父节点进行左旋。下面，我们来分析是如何实现的。<br>      为了便于说明，我们设置 “当前节点” 为 S(Original Son)，“兄弟节点”为 B(Brother)，“兄弟节点的左孩子”为 BLS(Brother’s Left Son)，“兄弟节点的右孩子”为 BRS(Brother’s Right Son)，“父节点”为 F(Father)。<br>      我们要对 F 进行左旋。但在左旋前，我们需要调换 F 和 B 的颜色，并设置 BRS 为黑色。为什么需要这里处理呢？因为左旋后，F 和 BLS 是父子关系，而我们已知 BL 是红色，如果 F 是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F 设置为黑色”。 但是，F 设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：<br>      第一，“同时经过根节点和 S 的分支的黑色节点个数不变”。<br>             若满足 “第一”，只需要 S 丢弃它多余的颜色即可。因为 S 的颜色是“黑 + 黑”，而左旋后“同时经过根节点和 S 的分支的黑色节点个数” 增加了 1；现在，只需将 S 由 “黑 + 黑” 变成单独的 “黑” 节点，即可满足“第一”。<br>      第二，“同时经过根节点和 BLS 的分支的黑色节点数不变”。<br>             若满足 “第二”，只需要将“F 的原始颜色” 赋值给 B 即可。之前，我们已经将“F 设置为黑色”(即，将 B 的颜色 “黑色”，赋值给了 F)。至此，我们算是调换了 F 和 B 的颜色。<br>      第三，“同时经过根节点和 BRS 的分支的黑色节点数不变”。<br>             在 “第二” 已经满足的情况下，若要满足 “第三”，只需要将 BRS 设置为“黑色” 即可。<br>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将 x 设为根节点，就可以跳出 while 循环(参考伪代码)；即完成了全部处理。</p>
<p>至此，我们就完成了 Case 4 的处理。理解 Case 4 的核心，是了解如何“去掉当前节点额外的黑色”。</p>
<p>**4.3 示意图 **</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251817189983393.jpg"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/251817189983393.jpg"></a></p>
<p>OK！至此，红黑树的理论知识差不多讲完了。后续再更新红黑树的实现代码！</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>1, 《算法导论》</p>
<p>2,  <a target="_blank" rel="noopener external nofollow noreferrer" href="http://blog.csdn.net/v_JULY_v/article/details/6105630">[ 教你透彻了解红黑树 ]</a></p>
<p>3,  <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3245399.html">[ 红黑树 (一) 之 原理和算法详细介绍 ]</a></p>
<p>** 更多内容 **: <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3603935.html">数据结构与算法系列 目录</a> </p>
<p>(01) <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3245399.html">红黑树 (一) 之 原理和算法详细介绍</a><br>(02) <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3624177.html">红黑树 (二) 之 C 语言的实现</a><br>(03) <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3624202.html">红黑树 (三) 之 Linux 内核中红黑树的经典实现 </a><br>(04) <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3624291.html">红黑树 (四) 之 C++ 的实现</a><br>(05) <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3624343.html">红黑树 (五) 之 Java 的实现</a>  <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3624291.html">[1]</a><br>(06) <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/skywang12345/p/3644742.html">红黑树 (六) 之 参考资料</a></p>
</blockquote>
<hr>
<blockquote>
<p>to be continued…</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tamsiree.com">Tamsiree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tamsiree.com/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91/">https://tamsiree.com/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://tamsiree.com" target="_blank">Tamsiree</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Research/">Research</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/thumb-1920-987815.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Intellij-IDEA/EmmyLua%E8%B0%83%E8%AF%95Unity/" title="EmmyLua 调试 Unity"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-a73b613.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">EmmyLua 调试 Unity</div></div><div class="info-2"><div class="info-item-1">前言以前用开发 lua 都是使用 sublime，但是 sublime 终究是一个编辑器，调试不是方便，后来在同事的引荐下，接触到了 Intellij IDEA，刚开始使用很不习惯，用了一段时间后，发现 EmmyLua + Unity 用起来很舒服，简单说一下配置过程 安装 Intellij IDEA我使用的是 **IntelliJ IDEA 2019.2.3 (Community Edition)**，这个版本不收费，但足够我们使用了，附上下载地址 https://www.jetbrains.com/idea/download/#section=windows，下载安装即可 安装 EmmyLua请注意，这里面是有坑的，如果你直接在 Settings-&gt;Plugins 中搜索 EmmyLua 安装，是不能调试的（曾经手贱，升级了一下插件，死活连不上），因为最新版的 EmmyLua1.3.2 更新日志中，有如下提示：    更新日志说：因为它经常被防病毒软件拦截，所以删除连接调试（wtf？！，开发机会装杀毒软件？！）所以不要用最新版的，去插件的官网下载老版插件（我用的 1.3...</div></div></div></a><a class="pagination-related" href="/GameEngine/Unity/UGUI/UGUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/" title="UGUI 源码分析系列"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-6b320d4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UGUI 源码分析系列</div></div><div class="info-2"><div class="info-item-1">阅前提示该系列注重分析 UGUI 源码，来深入了解 UGUI 每个模块每个组件的实现原理，使我们对 UGUI 使用和拓展上更加得心应手。适合人群：UGUI 使用者，All阅读方式：文章 + 源码阅读本系列在不断更新中，如果对你有所帮助，可以点赞收藏：）UGUI 版本：2017.4源码地址 文章目录   [阅前提示](# 阅前提示)   [总览图](# 总览图)   Base    UIBehaviour   EventSystem   CanvasUpdateSystem   LayoutSystem   Graphic   Selectable     Component    Image &amp; RawImage   Text &amp; Shadow &amp; Outline   Button   Toggle   Slider   Scrollbar &amp; ScrollRect   Dropdown InputField     总览图  Base UIBehaviour BaseClass: MonoBehaviour **Interface: 无 ** I...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg05e3c1f.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-02</div><div class="info-item-2">数据结构</div></div><div class="info-2"><div class="info-item-1">定义数据结构 (data structure) 是带有结构特性的数据元素的集合，它研究的是数据的 逻辑结构 和数据的 物理结构 以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带 “结构” 的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为 逻辑结构 和 存储结构 。 数据的 逻辑结构 和 物理结构 是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的 逻辑结构 ，而算法的实现依赖于指定的 存储结构 。 数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是 分解 与 抽象 。通过 分解 可以划分出数据的 3 个层次；再通过 抽象 ，舍弃数据元素的具体内容，就得到 逻辑结构 。类似地，通过 分解 将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为 数据结构 。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加...</div></div></div></a><a class="pagination-related" href="/Research/Memorizing/%E8%B4%B9%E6%9B%BC%E6%8A%80%E5%B7%A7/" title="费曼技巧"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/t01a6cfe8d66657d084.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-08</div><div class="info-item-2">费曼技巧</div></div><div class="info-2"><div class="info-item-1">前言费曼技巧是一种「以教为学」的学习方式，能够帮助你提高知识的吸收效率，真正理解并学会运用知识。这个学习方法其实很简单，就是验证你是否真正掌握一个知识，看你能否用直白浅显的语言把复杂深奥的问题和知识讲清楚。 正文 ** 费曼技巧，是最高效，最实用的学习方法 **。     先说一个故事：1918 年，一个叫做马克斯. 普朗克的物理学家，获得诺贝尔物理学奖。之后他在全德国做巡回报告，不管被邀请到哪里，他都会对新的量子力学演讲一番，他的司机也渐渐对他的报告烂熟于心。于是就告诉他：普朗克教授，老做同样的报告，你一定觉得很无聊，我建议，在慕尼黑由我代理做报告，你坐最前排，带上我的司机帽，让我们换一换花样。   普朗克听了兴致盎然，欣然同意。于是司机就为一群专家级听众，做了一番有关于量子力学的长篇报告。同样也获得了大家的掌声，之后有一位物理学教授举手提问，司机回答说，我真没有想到，在慕尼黑这样先进的城市里，还会有人提出这么简单的问题，那我就请我的司机来回答这个问题吧。  在这个故事中，因为司机一遍又一遍的听普朗克的演讲，使自己可以完全代替普朗克做报告演讲，** 但区别就在于，司机的知识只是...</div></div></div></a><a class="pagination-related" href="/Research/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/" title="考研英语作文"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/t0160443c71f945c7fb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-29</div><div class="info-item-2">考研英语作文</div></div><div class="info-2"><div class="info-item-1">前言考研英语的大纲要求：  要求根据所规定的情景或给出的提纲，写出一篇 150 词左右的英语说明文或议论文。提供的场景的形式一般为 [图表](# 往年图表形式分析) 。共 15 分。   往年图表形式分析   年份 图表形式 主题    2010 柱状图 发展中国家和发达国家手机用户量增长情况对比   2011 柱状图 国内汽车市场部分品牌份额变化   2012 表格 某公司不同年龄人群的工作满意度调查   2013 柱状图 大学生兼职比例逐年级递增   2014 柱状图 20 年间城市人口与农村人口的变化   2015 饼状图 居民春节期间花销比例情况   2016 饼状图 高校学生旅行目的调查   2017 折线图 博物馆数量和参观人数的变化   2018 饼状图 顾客就餐时的考虑因素   2019 柱状图 高校本科毕业生的去向变化    柱状图： Bar Chart表格： Table饼状图： Pie Chart折线图： Line Chart  结论：  主要考察数据图表；   既有动态的数据变化图（柱状图、折线图）又有静态的比例分配图（饼状图、表格） 话题聚焦生活场景与校园...</div></div></div></a><a class="pagination-related" href="/Research/%E7%A7%91%E7%A0%94%E4%BC%A6%E7%90%86%E4%B8%8E%E5%AD%A6%E6%9C%AF%E8%A7%84%E8%8C%83/%E7%A7%91%E7%A0%94%E4%BC%A6%E7%90%86%E4%B8%8E%E5%AD%A6%E6%9C%AF%E8%A7%84%E8%8C%83%E7%AD%94%E6%A1%88/" title="科研伦理与学术规范答案"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-ce1b9b7.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-07</div><div class="info-item-2">科研伦理与学术规范答案</div></div><div class="info-2"><div class="info-item-1">前言这里是科研伦理与学术规范答题。 正文![](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post / 微信截图_20210407230514.png) ![](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post / 微信截图_20210407231032.png) ![](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post / 微信截图_20210407231226.png) ![](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post / 微信截图_20210407231411.png) ![](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post / 微信...</div></div></div></a><a class="pagination-related" href="/Research/Math/MathJax/MathJax%E5%BC%95%E6%93%8E%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E/" title="MathJax 引擎数学符号说明"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/longsahidsa.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-08</div><div class="info-item-2">MathJax 引擎数学符号说明</div></div><div class="info-2"><div class="info-item-1">关于 MathJax 使用 MathJax 渲染 LaTex 数学公式，详见 math.stackexchange.com，在 Markdown 中输入数学公式需要 LaTeX 语法的支持。   例如:  行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ 块级公式：$$x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$  更多 LaTex 语法请参考 这里. 基本语法公式出现的位置 正文行内的 LaTex 公式或符号使用 $...$ 表示   　例如：\$X\$ ，显示为　$X$  单独成行显示的 LaTeX 公式或符号用 \$\$...\$\$ 定义，此时公式或符号居中并放大显示  　例如:\$\$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \$\$ , 显示为   $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 常见的希腊字母** 若不是特别说明, 默认使用行内符号，即用 \$...\$ 显示...</div></div></div></a><a class="pagination-related" href="/Research/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%B8%AD%E5%8D%97%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%80%83%E7%A0%94%E9%A2%98%E5%9E%8B/" title="中南大学软件工程考研题型"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/yuiohjgf.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-09</div><div class="info-item-2">中南大学软件工程考研题型</div></div><div class="info-2"><div class="info-item-1">选择题型 瀑布模型是以文档为驱动、适合于（软件需求确定的）软件项目的开发。      需求分析的基本任务是（确定用户需要软件做什么）。    若有一个计算类型的程序，它的输入量只有一个 X，其范围是［-1.0，1.0］，现从输入的角度考虑一组测试用例：-1.001，-1.0，1.0，1.001。设计这组测试用例的方法是（边界值分析法）。    根据程序流程图划分的模块通常是（过程）内聚的模块。  软件的分类，按其功能可分为：系统软件、（支撑软件）和应用软件。   UML 的定义包括 UML 语义和（UML 表示法 ）两个部分。  客观世界中的若干类，通常有两种主要的结构关系：即分类结构和(整体与部分结构)。   IDEF1X 图用来描述系统的（数据）模型，主要有实体、联系和（属性）三种成分，其中实体可分为独立实体和（从属实体），且一个实体只能在图中出现一次。   软件是计算机程序、（描述计算机程序的文档）及（数据）的完整集合，将其统称为软件配置，这些项称为软件配置项。通过正式复审的软件配置项称为（基线），只有通过正式的变化控制过程才能改变它。   通常，将软件生命周期全过程中使用...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Tamsiree</div><div class="author-info-description">勇于尝试才有可能迈向成功</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">201</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">143</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/tamsiree"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Tamsiree" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github-square"></i></a><a class="social-icon" href="mailto:tamsiree.com@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope-square"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只有用心灵才能看得清事物的本质，真正重要的东西是肉眼无法看见的。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#R-B-Tree-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">**R-B Tree 简介 **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">** 红黑树的应用 **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%9B%B8%E5%85%B3%E8%AF%81%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">** 红黑树的时间复杂度和相关证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E4%B8%80-%E5%B7%A6%E6%97%8B%E5%92%8C%E5%8F%B3%E6%97%8B"><span class="toc-number">1.4.</span> <span class="toc-text">** 红黑树的基本操作(一) 左旋和右旋 **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E4%BA%8C-%E6%B7%BB%E5%8A%A0"><span class="toc-number">1.5.</span> <span class="toc-text">** 红黑树的基本操作(二) 添加 **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E4%B8%89-%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.</span> <span class="toc-text">** 红黑树的基本操作(三) 删除 **</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">2.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Hexo%E4%B8%ADWaline%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/" title="Hexo 中 Waline 故障修复指南"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/Konachan.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo 中 Waline 故障修复指南"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Hexo%E4%B8%ADWaline%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/" title="Hexo 中 Waline 故障修复指南">Hexo 中 Waline 故障修复指南</a><time datetime="2026-02-05T07:25:41.000Z" title="发表于 2026-02-05 15:25:41">2026-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/" title="独立游戏的成功之母"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/552b1999aa4d5a2e75352fa2f6e93d51.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="独立游戏的成功之母"/></a><div class="content"><a class="title" href="/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/" title="独立游戏的成功之母">独立游戏的成功之母</a><time datetime="2025-11-11T05:08:38.000Z" title="发表于 2025-11-11 13:08:38">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="Docker 中 MongoDB 数据库的备份与恢复"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/cdd893c83169033d6b4a8354f1ab9d37.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker 中 MongoDB 数据库的备份与恢复"/></a><div class="content"><a class="title" href="/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="Docker 中 MongoDB 数据库的备份与恢复">Docker 中 MongoDB 数据库的备份与恢复</a><time datetime="2025-11-06T00:49:58.000Z" title="发表于 2025-11-06 08:49:58">2025-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity 多线程渲染导致部分手机崩溃"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/9408053447.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 多线程渲染导致部分手机崩溃"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity 多线程渲染导致部分手机崩溃">Unity 多线程渲染导致部分手机崩溃</a><time datetime="2023-11-09T11:55:51.000Z" title="发表于 2023-11-09 19:55:51">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的 CDN 之 jsDelivr"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/20b24a69649941669d83bb997b01fed6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="好用的 CDN 之 jsDelivr"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的 CDN 之 jsDelivr">好用的 CDN 之 jsDelivr</a><time datetime="2023-10-16T07:00:56.000Z" title="发表于 2023-10-16 15:00:56">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2016 - 2026 By Tamsiree</span></div><div class="footer_custom_text">不要盯着我看，已经到底啦～</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/js/tw_cn.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"placeholder":"留下你的脚印与心声~","pageSize":10,"lang":"zh-CN","requiredFields":["nick"],"avatar":"wavatar"}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.tamsiree.com',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !true) {
    if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8688374801147098" crossorigin="anonymous"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>