<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Socket 入门 | Tamsiree</title><meta name="author" content="Tamsiree,tamsiree.com@gmail.com"><meta name="copyright" content="Tamsiree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行**通信**的**一种约定**或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket 入门">
<meta property="og:url" content="https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/">
<meta property="og:site_name" content="Tamsiree">
<meta property="og:description" content="在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行**通信**的**一种约定**或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg">
<meta property="article:published_time" content="2020-06-25T04:28:11.000Z">
<meta property="article:modified_time" content="2025-11-05T13:53:39.374Z">
<meta property="article:author" content="Tamsiree">
<meta property="article:tag" content="Socket">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Socket 入门",
  "url": "https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/",
  "image": "https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg",
  "datePublished": "2020-06-25T04:28:11.000Z",
  "dateModified": "2025-11-05T13:53:39.374Z",
  "author": [
    {
      "@type": "Person",
      "name": "Tamsiree",
      "url": "https://tamsiree.com"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png"><link rel="canonical" href="https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-8688374801147098',
  enable_page_level_ads: 'true'
});</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Tamsiree","link":"链接: ","source":"来源: Tamsiree","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Socket 入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><script>if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') { window.location.href = window.location.href.replace('http:', 'https:'); }</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="Tamsiree" type="application/atom+xml">
</head><body><div class="bg-animation" id="web_bg" style="background-color: #f0f0f0;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">201</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">143</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Tamsiree</span></a><a class="nav-page-title" href="/"><span class="site-name">Socket 入门</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Socket 入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-25T04:28:11.000Z" title="发表于 2020-06-25 12:28:11">2020-06-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-05T13:53:39.374Z" title="更新于 2025-11-05 21:53:39">2025-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Socket/">Socket</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行 ** 通信 ** 的 ** 一种约定 ** 或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。<br>　　socket 起源于 Unix，而 Unix/Linux 基本哲学之一就是 “一切皆文件”，都可以用“打开 open –&gt; 读写 write/read –&gt; 关闭 close” 模式来操作。<br>　　我的理解就是 Socket 就是该模式的一个实现：即 socket 是一种特殊的文件，一些 socket 函数就是对其进行的操作（读 / 写 IO、打开、关闭）。<br>　　Socket()函数返回一个整型的 Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Socket-原理"><a href="#Socket-原理" class="headerlink" title="Socket 原理"></a>Socket 原理</h2><h4 id="1、网络中进程如何通信"><a href="#1、网络中进程如何通信" class="headerlink" title="**1、网络中进程如何通信 **"></a>**1、网络中进程如何通信 **</h4><p>既然 Socket 主要是用来解决网络通信的，那么我们就来理解网络中进程是如何通信的。</p>
<h6 id="1-1、本地进程间通信"><a href="#1-1、本地进程间通信" class="headerlink" title="1.1、本地进程间通信"></a>1.1、本地进程间通信</h6><p>a、消息传递（管道、消息队列、FIFO）<br>　　b、同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）？【不是很明白】<br>　　c、共享内存（匿名的和具名的，eg:channel）<br>　　d、远程过程调用(RPC)</p>
<h6 id="1-2、网络中进程如何通信"><a href="#1-2、网络中进程如何通信" class="headerlink" title="1.2、网络中进程如何通信"></a>1.2、网络中进程如何通信</h6><p>我们要理解网络中进程如何通信，得解决两个问题：<br>　　ａ、我们要如何标识一台主机，即怎样确定我们将要通信的进程是在那一台主机上运行。<br>　　ｂ、我们要如何标识唯一进程，本地通过 pid 标识，网络中应该怎样标识？<br>解决办法：<br>　　ａ、TCP/IP 协议族已经帮我们解决了这个问题，网络层的 “ip 地址” 可以唯一标识网络中的主机<br>　　ｂ、传输层的 “协议 + 端口” 可以唯一标识主机中的应用程序（进程），因此，我们利用三元组（ip 地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互</p>
<h4 id="2、Socket-怎么通信"><a href="#2、Socket-怎么通信" class="headerlink" title="**2、Socket 怎么通信 **"></a>**2、Socket 怎么通信 **</h4><p>现在，我们知道了网络中进程间如何通信，即利用三元组【ip 地址，协议，端口】可以进行网络间通信了，那我们应该怎么实现了，因此，我们 socket 应运而生，它就是利用三元组解决网络通信的一个中间件工具，就目前而言，几乎所有的应用程序都是采用 socket，如 UNIX BSD 的套接字（socket）和 UNIX System V 的 TLI（已经被淘汰）。<br>Socket 通信的数据传输方式，常用的有两种：<br>　　ａ、SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。<br>　　ｂ、SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。<br>　　例如：QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响</p>
<h4 id="3、TCP-IP-协议"><a href="#3、TCP-IP-协议" class="headerlink" title="**3、TCP/IP 协议 **"></a>**3、TCP/IP 协议 **</h4><h6 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a>3.1、概念</h6><p>TCP/IP【TCP（传输控制协议）和 IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层 OSI 模型。</p>
<p>它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。</p>
<p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证 IP 地址、端口、物理链路等正确无误，为数据的传输开辟通道。<br>TCP 建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p>
<pre><code>[Shake 1] 套接字 A：“你好，套接字 B，我这里有数据要传送给你，建立连接吧。”
[Shake 2] 套接字 B：“好的，我这边已准备就绪。”
[Shake 3] 套接字 A：“谢谢你受理我的请求。
</code></pre>
<h6 id="3-2、TCP-的粘包问题以及数据的无边界性：-https-blog-csdn-net-m0-37947204-article-details-80490512"><a href="#3-2、TCP-的粘包问题以及数据的无边界性：-https-blog-csdn-net-m0-37947204-article-details-80490512" class="headerlink" title="3.2、TCP 的粘包问题以及数据的无边界性：　https://blog.csdn.net/m0_37947204/article/details/80490512"></a>3.2、TCP 的粘包问题以及数据的无边界性：　<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/m0_37947204/article/details/80490512">https://blog.csdn.net/m0_37947204/article/details/80490512</a></h6><h6 id="3-4、TCP-数据报结构："><a href="#3-4、TCP-数据报结构：" class="headerlink" title="3.4、TCP 数据报结构："></a>3.4、TCP 数据报结构：</h6><p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-bf1bffccd9cceaff.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/369/format/webp"></p>
<p>20180529001000428.jpeg</p>
<p>带阴影的几个字段需要重点说明一下：<br>　　(1) 序号：Seq（Sequence Number）序号占 32 位，用来标识从计算机 A 发送到计算机 B 的数据包的序号，计算机发送数据时对此进行标记。<br>　　(2) 确认号：Ack（Acknowledge Number）确认号占 32 位，客户端和服务器端都可以发送，Ack = Seq + 1。<br>　　(3) 标志位：每个标志位占用 1Bit，共有 6 个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：</p>
<pre><code>（1）URG：紧急指针（urgent pointer）有效。
（2）ACK：确认序号有效。
（3）PSH：接收方应该尽快将这个报文交给应用层。
（4）RST：重置连接。
（5）SYN：建立一个新连接。
（6）FIN：断开一个连接。
</code></pre>
<h6 id="3-5、连接的建立（三次握手）："><a href="#3-5、连接的建立（三次握手）：" class="headerlink" title="3.5、连接的建立（三次握手）："></a>3.5、连接的建立（三次握手）：</h6><p>使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：  </p>
<p>　　</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-75c208edcfb986fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp"></p>
<p>20180529001324885.jpeg</p>
<p>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于 CLOSED 状态；服务器端调用 listen() 函数后，套接字进入 LISTEN 状态，开始监听客户端请求<br>这时客户端发起请求：<br>　　1) 当客户端调用 connect() 函数后，TCP 协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充 “序号（Seq）” 字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了 SYN-SEND 状态。<br>　　2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包<br>　　服务器生成一个随机数 2000，填充 “序号（Seq）” 字段。2000 和客户端数据包没有关系。<br>　　服务器将客户端数据包序号（1000）加 1，得到 1001，并用这个数字填充 “确认号（Ack）” 字段。<br>　　服务器将数据包发出，进入 SYN-RECV 状态<br>　　3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的 “确认包”。客户端会检测“确认号（Ack）” 字段，看它的值是否为 1000+1，如果是就说明连接建立成功。<br>　　接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的 “确认包”。同时，将刚才服务器发来的数据包序号（2000）加 1，得到 2001，并用这个数字来填充“确认号（Ack）” 字段。<br>　　客户端将数据包发出，进入 ESTABLISED 状态，表示连接已经成功建立。<br>　　4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的 “确认包”。服务器会检测“确认号（Ack）” 字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入 ESTABLISED 状态。<br>　　至此，客户端和服务器都进入了 ESTABLISED 状态，连接建立成功，接下来就可以收发数据了。</p>
<h6 id="3-6、TCP-四次握手断开连接"><a href="#3-6、TCP-四次握手断开连接" class="headerlink" title="3.6、TCP 四次握手断开连接"></a>3.6、TCP 四次握手断开连接</h6><p>建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。<br>断开连接需要四次握手，可以形象的比喻为下面的对话：</p>
<pre><code>[Shake 1] 套接字 A：“任务处理完毕，我希望断开连接。”
[Shake 2] 套接字 B：“哦，是吗？请稍等，我准备一下。”
等待片刻后……
[Shake 3] 套接字 B：“我准备好了，可以断开连接了。”
[Shake 4] 套接字 A：“好的，谢谢合作。”
</code></pre>
<p>下图演示了客户端主动断开连接的场景：</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-63aad9661131a2a8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp"></p>
<p>20180529001837204.jpeg</p>
<p>建立连接后，客户端和服务器都处于 ESTABLISED 状态。这时，客户端发起断开连接的请求：</p>
<ol>
<li> 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入 FIN_WAIT_1 状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</li>
<li>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入 CLOSE_WAIT 状态。<br> 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</li>
<li> 客户端收到 “确认包” 后进入 FIN_WAIT_2 状态，等待服务器准备完毕后再次发送数据包。</li>
<li> 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入 LAST_ACK 状态。</li>
<li> 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入 TIME_WAIT 状态。</li>
<li> 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入 CLOSED 状态。</li>
</ol>
<h6 id="3-7、关于-TIME-WAIT-状态的说明"><a href="#3-7、关于-TIME-WAIT-状态的说明" class="headerlink" title="3.7、关于 TIME_WAIT 状态的说明"></a>3.7、关于 TIME_WAIT 状态的说明</h6><p>客户端最后一次发送 ACK 包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？</p>
<p>TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器 A 每次向机器 B 发送数据包后，都要求机器 B”确认“，回传 ACK 包，告诉机器 A 我收到了，这样机器 A 才能知道数据传送成功了。如果机器 B 没有回传 ACK 包，机器 A 会重新发送，直到机器 B 回传 ACK 包。</p>
<p>客户端最后一次向服务器回传 ACK 包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到 ACK 包了，所以客户端需要等待片刻、确认对方收到 ACK 包后才能进入 CLOSED 状态。那么，要等待多久呢？</p>
<p>数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包</p>
<h6 id="3-８-优雅的断开连接–shutdown"><a href="#3-８-优雅的断开连接–shutdown" class="headerlink" title="3.８. 优雅的断开连接–shutdown()"></a>3.８. 优雅的断开连接–shutdown()</h6><p>close()/closesocket()和 shutdown()的区别<br>确切地说，close() / closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与 C 语言中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP 协议会自动触发关闭连接的操作。</p>
<p>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。<br>调用 close()/closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。</p>
<p>默认情况下，close()/closesocket() 会立即向网络中发送 FIN 包，不管输出缓冲区中是否还有数据，而 shutdown() 会等输出缓冲区中的数据传输完毕再发送 FIN 包。也就意味着，调用 close()/closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会</p>
<h4 id="4、OSI-模型"><a href="#4、OSI-模型" class="headerlink" title="**4、OSI 模型 **"></a>**4、OSI 模型 **</h4><p>TCP/IP 对 OSI 的网络模型层进行了划分如下：</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-d6275ac25abac5cc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/395/format/webp"></p>
<p>20150615140039701.jpeg</p>
<p>TCP/IP 协议参考模型把所有的 TCP/IP 系列协议归类到四个抽象层中<br>　　应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等<br>　　传输层：TCP，UDP<br>　　网络层：IP，ICMP，OSPF，EIGRP，IGMP<br>　　数据链路层：SLIP，CSLIP，PPP，MTU<br>　　每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的  </p>
<p>　　</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-2d26013c75ee45e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp"></p>
<p>20150615140707753.png</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-157a39882f263361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/612/format/webp"></p>
<p>20150615141705040.png</p>
<h4 id="5、Socket-常用函数接口及其原理"><a href="#5、Socket-常用函数接口及其原理" class="headerlink" title="**5、Socket 常用函数接口及其原理 **"></a>**5、Socket 常用函数接口及其原理 **</h4><p>图解 socket 函数：</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-31d594363f8cafa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp"></p>
<p>20150615150446559.png</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-ec76f69e2ea76d41.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/478/format/webp"></p>
<p>20150615150618996.jpeg</p>
<h6 id="5-1、使用-socket-函数创建套接字"><a href="#5-1、使用-socket-函数创建套接字" class="headerlink" title="5.1、使用 socket()函数创建套接字"></a>5.1、使用 socket()函数创建套接字</h6><pre><code>int socket(int af, int type, int protocol);
</code></pre>
<ol>
<li>af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是 “Address Family” 的简写，INET 是 “Inetnet” 的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。<br> 大家需要记住 127.0.0.1，它是一个特殊 IP 地址，表示本机地址，后面的教程会经常用到。</li>
<li> type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAM</li>
<li> protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议</li>
</ol>
<h6 id="5-2、使用-bind-和-connect-函数"><a href="#5-2、使用-bind-和-connect-函数" class="headerlink" title="5.2、使用 bind()和 connect()函数"></a>5.2、使用 bind()和 connect()函数</h6><p>socket() 函数用来创建套接字，确定套接字的各种属性，然后服务器端要用 **bind() 函数 ** 将套接字与特定的 IP 地址和端口绑定起来，只有这样，流经该 IP 地址和端口的数据才能交给套接字处理；而客户端要用 connect() 函数建立连接</p>
<pre><code>int bind(int sock, struct sockaddr *addr, socklen_t addrlen);  
</code></pre>
<p>sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出<br>下面的代码，将创建的套接字与 IP 地址 127.0.0.1、端口 1234 绑定：</p>
<pre><code>// 创建套接字
int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
// 创建 sockaddr_in 结构体变量
struct sockaddr_in serv_addr;
memset(&amp;serv_addr, 0, sizeof(serv_addr));  // 每个字节都用 0 填充
serv_addr.sin_family = AF_INET;  // 使用 IPv4 地址
serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  // 具体的 IP 地址
serv_addr.sin_port = htons(1234);  // 端口
// 将套接字和 IP、端口绑定
bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));
</code></pre>
<p>connect() 函数用来建立连接，它的原型为：</p>
<pre><code>int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); 
</code></pre>
<h6 id="5-3、使用-listen-和-accept-函数"><a href="#5-3、使用-listen-和-accept-函数" class="headerlink" title="5.3、使用 listen()和 accept()函数"></a>5.3、使用 listen()和 accept()函数</h6><p>于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。<br>通过 ** listen() 函数 ** 可以让套接字进入被动监听状态，它的原型为：</p>
<pre><code>int listen(int sock, int backlog); 
</code></pre>
<p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。<br>所谓被动监听，是指当没有客户端请求时，套接字处于 “睡眠” 状态，只有当接收到客户端请求时，套接字才会被 “唤醒” 来响应请求。</p>
<p>请求队列<br>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</p>
<p>缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是 10 或者 20。</p>
<p>如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</p>
<p>当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误</p>
<p>注意：listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。</p>
<p>当套接字处于监听状态时，可以通过 **accept() 函数 ** 来接收客户端请求。它的原型为：</p>
<pre><code>int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); 
</code></pre>
<p>它的参数与 listen() 和 connect() 是相同的：sock 为服务器端套接字，addr 为 sockaddr_in 结构体变量，addrlen 为参数 addr 的长度，可由 sizeof() 求得。</p>
<p>accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的 IP 地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。</p>
<p>最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</p>
<h6 id="5-4、socket-数据的接收和发送"><a href="#5-4、socket-数据的接收和发送" class="headerlink" title="5.4、socket 数据的接收和发送"></a>5.4、socket 数据的接收和发送</h6><p>Linux 下数据的接收和发送<br>Linux 不区分套接字文件和普通文件，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。</p>
<p>前面我们说过，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。<br>write() 的原型为：</p>
<pre><code>ssize_t write(int fd, const void *buf, size_t nbytes);
</code></pre>
<p>fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。<br>write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。<br>read() 的原型为：</p>
<pre><code>ssize_t read(int fd, void *buf, size_t nbytes);
</code></pre>
<p>fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。</p>
<p>read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回 0），失败则返回 -1。</p>
<h6 id="5-5、socket-缓冲区以及阻塞模式"><a href="#5-5、socket-缓冲区以及阻塞模式" class="headerlink" title="5.5、socket 缓冲区以及阻塞模式"></a>5.5、socket 缓冲区以及阻塞模式</h6><p>socket 缓冲区<br>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p>
<p>write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。</p>
<p>TCP 协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</p>
<p>read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取</p>
<p><img src="/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-d4be2dd4bb3a26b8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/697/format/webp"></p>
<p>20180528234331238.jpeg</p>
<p>这些 I/O 缓冲区特性可整理如下：</p>
<pre><code>（1）I/O 缓冲区在每个 TCP 套接字中单独存在；
（2）I/O 缓冲区在创建套接字时自动生成；
（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
（4）关闭套接字将丢失输入缓冲区中的数据。
</code></pre>
<p>输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：</p>
<pre><code>unsigned optVal;
int optLen = sizeof(int);
getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&amp;optVal, &amp;optLen);
printf(&quot;Buffer length: %d\n&quot;, optVal);
</code></pre>
<p>阻塞模式<br>对于 TCP 套接字（默认情况下），当使用 write()/send() 发送数据时：</p>
<pre><code>1) 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。
2) 如果 TCP 协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。
3) 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。
4) 直到所有数据被写入缓冲区 write()/send() 才能返回。
</code></pre>
<p>当使用 read()/recv() 读取数据时：</p>
<pre><code>1) 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。
2) 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。
3) 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。
这就是 TCP 套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。
</code></pre>
<p>TCP 套接字默认情况下是阻塞模式</p>
<hr>
<blockquote>
<p>to be continued…</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tamsiree.com">Tamsiree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/">https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://tamsiree.com" target="_blank">Tamsiree</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Socket/">Socket</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/TechnicalResearch/Python/DeepLearning/ECG/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84ECG%E5%BF%83%E5%BE%8B%E5%A4%B1%E5%B8%B8%E5%88%86%E7%B1%BB%E5%85%A5%E9%97%A8/" title="基于深度学习的 ECG 心律失常分类入门"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-8c6afe1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基于深度学习的 ECG 心律失常分类入门</div></div><div class="info-2"><div class="info-item-1">ECG 分析: 基于深度学习的 ECG 心律失常分类入门 本文主要用于备份保存。  写作动机由于受突发疫情的影响，开学时间推迟了（在此特向奋斗在前线的各行各业的工作者们致以崇高的敬意！）。前天晚上刚好看到一篇新出的论文，跟自己之前做的方向类似，当时想着抽个时间复现一下，一方面是为了做一个备忘笔记，另一方面，考虑到有一部分后来者可能也是 ECG 算法研究相关的方向，所以做这个简单的入门探讨，也许会起到一丁点的作用。这个是从数据获取到最后的结果评估，还是比较完整的，主要特点是内容简单，写的代码也是没有经过封装的，还是比较容易上手的。特别强调，** 只适合小白食用，大佬请绕行！！哈哈哈…**。 深度医疗随着 “人工智能” 的兴起，“深度医疗”这个概念也被提了出来，越来越多的基于机器 / 深度学习的医学研究项目已经展开，比如基于深度学习处理医学图像，对特定医学病变做诊断识别等。如果在未来这类研究真的大面积落地了，那真将是一件大快人心的事情，很大程度上解决了很多现实问题，比如节约了医疗资源等等。 本篇主要是介绍基于深度学习进行心电图（ECG）疾病分类的应用，用的数据库是 MIT-BIH A...</div></div></div></a><a class="pagination-related" href="/Software/Windows10%E8%87%AA%E5%B8%A6%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0Gmail/" title="Windows10 自带邮件添加 Gmail"><img class="cover" src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-21960ed.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Windows10 自带邮件添加 Gmail</div></div><div class="info-2"><div class="info-item-1">前言这里是前言介绍。 正文**0. 添加前的准备工作 **** 这一部分非常重要！** ** 这一部分非常重要！！** ** 这一部分非常重要！！！** 很多人不能成功添加 gmail 账户很可能就是因为 gmail 中的必要设置没做。 首先，你当然是需要有一个 gmail 账号的，然后登录 gmail 邮箱，点击右上角的图标进入设置界面   点击“转发和 POP/IMAP 并启用 IMAP 服务”。   相信上面这些 gmail 设置中的步骤大部分人都知道，下面还需要对 gmail 账户进行设置！ 点击网页右上角我的账户进入 google 账户   此时分 ** 两种 ** 情况：启用了两步验证的账户和未启用两步验证的账户（建议开启两步验证，附录中会简要介绍开启方法） **0.1 未启用两步验证的账户 ** 选择 “登录与安全” 中的 “关联的应用和网站”， 将“允许安全性更低的应用” 设置为“开” ，然后关闭窗口     **0.2 启用了两步验证的账户 ** 选择 “登录 google”，进入“应用专用密码” 子栏     按实际情况选择设备和应用，生成应用专用密码并复制，...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Tamsiree</div><div class="author-info-description">勇于尝试才有可能迈向成功</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">201</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">143</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/tamsiree"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Tamsiree" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github-square"></i></a><a class="social-icon" href="mailto:tamsiree.com@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope-square"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只有用心灵才能看得清事物的本质，真正重要的东西是肉眼无法看见的。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">Socket 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">**1、网络中进程如何通信 **</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1%E3%80%81%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1.1、本地进程间通信</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">1.2、网络中进程如何通信</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Socket-%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text">**2、Socket 怎么通信 **</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.3.</span> <span class="toc-text">**3、TCP&#x2F;IP 协议 **</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">3.1、概念</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2%E3%80%81TCP-%E7%9A%84%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E8%BE%B9%E7%95%8C%E6%80%A7%EF%BC%9A-https-blog-csdn-net-m0-37947204-article-details-80490512"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">3.2、TCP 的粘包问题以及数据的无边界性：　https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_37947204&#x2F;article&#x2F;details&#x2F;80490512</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4%E3%80%81TCP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">3.4、TCP 数据报结构：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-5%E3%80%81%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89%EF%BC%9A"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">3.5、连接的建立（三次握手）：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-6%E3%80%81TCP-%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.3.5.</span> <span class="toc-text">3.6、TCP 四次握手断开连接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-7%E3%80%81%E5%85%B3%E4%BA%8E-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.3.6.</span> <span class="toc-text">3.7、关于 TIME_WAIT 状态的说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%EF%BC%98-%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E2%80%93shutdown"><span class="toc-number">2.1.3.7.</span> <span class="toc-text">3.８. 优雅的断开连接–shutdown()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81OSI-%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">**4、OSI 模型 **</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Socket-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.5.</span> <span class="toc-text">**5、Socket 常用函数接口及其原理 **</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#5-1%E3%80%81%E4%BD%BF%E7%94%A8-socket-%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">5.1、使用 socket()函数创建套接字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-2%E3%80%81%E4%BD%BF%E7%94%A8-bind-%E5%92%8C-connect-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">5.2、使用 bind()和 connect()函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-3%E3%80%81%E4%BD%BF%E7%94%A8-listen-%E5%92%8C-accept-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">5.3、使用 listen()和 accept()函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-4%E3%80%81socket-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">5.4、socket 数据的接收和发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-5%E3%80%81socket-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%A5%E5%8F%8A%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">5.5、socket 缓冲区以及阻塞模式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Hexo%E4%B8%ADWaline%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/" title="Hexo 中 Waline 故障修复指南"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/Konachan.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo 中 Waline 故障修复指南"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Hexo%E4%B8%ADWaline%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/" title="Hexo 中 Waline 故障修复指南">Hexo 中 Waline 故障修复指南</a><time datetime="2026-02-05T07:25:41.000Z" title="发表于 2026-02-05 15:25:41">2026-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/" title="独立游戏的成功之母"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/552b1999aa4d5a2e75352fa2f6e93d51.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="独立游戏的成功之母"/></a><div class="content"><a class="title" href="/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/" title="独立游戏的成功之母">独立游戏的成功之母</a><time datetime="2025-11-11T05:08:38.000Z" title="发表于 2025-11-11 13:08:38">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="Docker 中 MongoDB 数据库的备份与恢复"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/cdd893c83169033d6b4a8354f1ab9d37.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker 中 MongoDB 数据库的备份与恢复"/></a><div class="content"><a class="title" href="/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="Docker 中 MongoDB 数据库的备份与恢复">Docker 中 MongoDB 数据库的备份与恢复</a><time datetime="2025-11-06T00:49:58.000Z" title="发表于 2025-11-06 08:49:58">2025-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity 多线程渲染导致部分手机崩溃"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/9408053447.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 多线程渲染导致部分手机崩溃"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity 多线程渲染导致部分手机崩溃">Unity 多线程渲染导致部分手机崩溃</a><time datetime="2023-11-09T11:55:51.000Z" title="发表于 2023-11-09 19:55:51">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的 CDN 之 jsDelivr"><img src="/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/20b24a69649941669d83bb997b01fed6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="好用的 CDN 之 jsDelivr"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的 CDN 之 jsDelivr">好用的 CDN 之 jsDelivr</a><time datetime="2023-10-16T07:00:56.000Z" title="发表于 2023-10-16 15:00:56">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2016 - 2026 By Tamsiree</span></div><div class="footer_custom_text">不要盯着我看，已经到底啦～</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/js/tw_cn.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"placeholder":"留下你的脚印与心声~","pageSize":10,"lang":"zh-CN","requiredFields":["nick"],"avatar":"wavatar"}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.tamsiree.com',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !true) {
    if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8688374801147098" crossorigin="anonymous"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>