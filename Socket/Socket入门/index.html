<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Socket入门 | Tamsiree</title><meta name="keywords" content="Socket"><meta name="author" content="Tamsiree,tamsiree.com@gmail.com"><meta name="copyright" content="Tamsiree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行**通信**的**一种约定**或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket入门">
<meta property="og:url" content="https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Tamsiree">
<meta property="og:description" content="在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行**通信**的**一种约定**或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg">
<meta property="article:published_time" content="2020-06-25T04:28:11.000Z">
<meta property="article:modified_time" content="2024-09-25T07:07:27.983Z">
<meta property="article:author" content="Tamsiree">
<meta property="article:tag" content="Socket">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png"><link rel="canonical" href="https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Tamsiree","link":"链接: ","source":"来源: Tamsiree","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Socket入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-25 15:07:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8688374801147098" crossorigin="anonymous"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Tamsiree" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">137</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">139</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tamsiree</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-keyboard"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-torah"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-leaf"></i><span> 风向标</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-dragon"></i><span> 寻龙尺</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-icons"></i><span> 回味</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 神秘链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-clipboard-list"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-id-badge"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/night_sky/"><i class="fa-fw fas fa-magic"></i><span> 冥想空间</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Socket入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-25T04:28:11.000Z" title="发表于 2020-06-25 12:28:11">2020-06-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-25T07:07:27.983Z" title="更新于 2024-09-25 15:07:27">2024-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Socket/">Socket</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Socket入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行<strong>通信</strong>的<strong>一种约定</strong>或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。<br>　　socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。<br>　　我的理解就是Socket就是该模式的一个实现：即socket是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。<br>　　Socket()函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Socket原理"><a href="#Socket原理" class="headerlink" title="Socket原理"></a>Socket原理</h2><h4 id="1、网络中进程如何通信"><a href="#1、网络中进程如何通信" class="headerlink" title="1、网络中进程如何通信"></a><strong>1、网络中进程如何通信</strong></h4><p>既然Socket主要是用来解决网络通信的，那么我们就来理解网络中进程是如何通信的。</p>
<h6 id="1-1、本地进程间通信"><a href="#1-1、本地进程间通信" class="headerlink" title="1.1、本地进程间通信"></a>1.1、本地进程间通信</h6><p>a、消息传递（管道、消息队列、FIFO）<br>　　b、同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）？【不是很明白】<br>　　c、共享内存（匿名的和具名的，eg:channel）<br>　　d、远程过程调用(RPC)</p>
<h6 id="1-2、网络中进程如何通信"><a href="#1-2、网络中进程如何通信" class="headerlink" title="1.2、网络中进程如何通信"></a>1.2、网络中进程如何通信</h6><p>我们要理解网络中进程如何通信，得解决两个问题：<br>　　ａ、我们要如何标识一台主机，即怎样确定我们将要通信的进程是在那一台主机上运行。<br>　　ｂ、我们要如何标识唯一进程，本地通过pid标识，网络中应该怎样标识？<br>解决办法：<br>　　ａ、TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机<br>　　ｂ、传输层的“协议+端口”可以唯一标识主机中的应用程序（进程），因此，我们利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互</p>
<h4 id="2、Socket怎么通信"><a href="#2、Socket怎么通信" class="headerlink" title="2、Socket怎么通信"></a><strong>2、Socket怎么通信</strong></h4><p>现在，我们知道了网络中进程间如何通信，即利用三元组【ip地址，协议，端口】可以进行网络间通信了，那我们应该怎么实现了，因此，我们socket应运而生，它就是利用三元组解决网络通信的一个中间件工具，就目前而言，几乎所有的应用程序都是采用socket，如UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰）。<br>Socket通信的数据传输方式，常用的有两种：<br>　　ａ、SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。<br>　　ｂ、SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。<br>　　例如：QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响</p>
<h4 id="3、TCP-IP协议"><a href="#3、TCP-IP协议" class="headerlink" title="3、TCP/IP协议"></a><strong>3、TCP/IP协议</strong></h4><h6 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a>3.1、概念</h6><p>TCP/IP【TCP（传输控制协议）和IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p>
<p>它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。</p>
<p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。<br>TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p>
<pre><code>[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”
[Shake 2] 套接字B：“好的，我这边已准备就绪。”
[Shake 3] 套接字A：“谢谢你受理我的请求。
</code></pre>
<h6 id="3-2、TCP的粘包问题以及数据的无边界性：-https-blog-csdn-net-m0-37947204-article-details-80490512"><a href="#3-2、TCP的粘包问题以及数据的无边界性：-https-blog-csdn-net-m0-37947204-article-details-80490512" class="headerlink" title="3.2、TCP的粘包问题以及数据的无边界性：　https://blog.csdn.net/m0_37947204/article/details/80490512"></a>3.2、TCP的粘包问题以及数据的无边界性：　<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/m0_37947204/article/details/80490512">https://blog.csdn.net/m0_37947204/article/details/80490512</a></h6><h6 id="3-4、TCP数据报结构："><a href="#3-4、TCP数据报结构：" class="headerlink" title="3.4、TCP数据报结构："></a>3.4、TCP数据报结构：</h6><p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-bf1bffccd9cceaff.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/369/format/webp"></p>
<p>20180529001000428.jpeg</p>
<p>带阴影的几个字段需要重点说明一下：<br>　　(1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。<br>　　(2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。<br>　　(3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：</p>
<pre><code>（1）URG：紧急指针（urgent pointer）有效。
（2）ACK：确认序号有效。
（3）PSH：接收方应该尽快将这个报文交给应用层。
（4）RST：重置连接。
（5）SYN：建立一个新连接。
（6）FIN：断开一个连接。
</code></pre>
<h6 id="3-5、连接的建立（三次握手）："><a href="#3-5、连接的建立（三次握手）：" class="headerlink" title="3.5、连接的建立（三次握手）："></a>3.5、连接的建立（三次握手）：</h6><p>使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：  </p>
<p>　　</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-75c208edcfb986fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp"></p>
<p>20180529001324885.jpeg</p>
<p>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求<br>这时客户端发起请求：<br>　　1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。<br>　　2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包<br>　　服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。<br>　　服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。<br>　　服务器将数据包发出，进入SYN-RECV状态<br>　　3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。<br>　　接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。<br>　　客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。<br>　　4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。<br>　　至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。</p>
<h6 id="3-6、TCP四次握手断开连接"><a href="#3-6、TCP四次握手断开连接" class="headerlink" title="3.6、TCP四次握手断开连接"></a>3.6、TCP四次握手断开连接</h6><p>建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。<br>断开连接需要四次握手，可以形象的比喻为下面的对话：</p>
<pre><code>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”
[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”
等待片刻后……
[Shake 3] 套接字B：“我准备好了，可以断开连接了。”
[Shake 4] 套接字A：“好的，谢谢合作。”
</code></pre>
<p>下图演示了客户端主动断开连接的场景：</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-63aad9661131a2a8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp"></p>
<p>20180529001837204.jpeg</p>
<p>建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：</p>
<ol>
<li> 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</li>
<li>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。<br> 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</li>
<li> 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。</li>
<li> 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。</li>
<li> 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。</li>
<li> 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。</li>
</ol>
<h6 id="3-7、关于-TIME-WAIT-状态的说明"><a href="#3-7、关于-TIME-WAIT-状态的说明" class="headerlink" title="3.7、关于 TIME_WAIT 状态的说明"></a>3.7、关于 TIME_WAIT 状态的说明</h6><p>客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？</p>
<p>TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。</p>
<p>客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？</p>
<p>数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包</p>
<h6 id="3-８-优雅的断开连接–shutdown"><a href="#3-８-优雅的断开连接–shutdown" class="headerlink" title="3.８.优雅的断开连接–shutdown()"></a>3.８.优雅的断开连接–shutdown()</h6><p>close()/closesocket()和shutdown()的区别<br>确切地说，close() / closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与C语言中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。</p>
<p>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。<br>调用 close()/closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。</p>
<p>默认情况下，close()/closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()/closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会</p>
<h4 id="4、OSI模型"><a href="#4、OSI模型" class="headerlink" title="4、OSI模型"></a><strong>4、OSI模型</strong></h4><p>TCP/IP对OSI的网络模型层进行了划分如下：</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-d6275ac25abac5cc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/395/format/webp"></p>
<p>20150615140039701.jpeg</p>
<p>TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中<br>　　应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等<br>　　传输层：TCP，UDP<br>　　网络层：IP，ICMP，OSPF，EIGRP，IGMP<br>　　数据链路层：SLIP，CSLIP，PPP，MTU<br>　　每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的  </p>
<p>　　</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-2d26013c75ee45e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp"></p>
<p>20150615140707753.png</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-157a39882f263361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/612/format/webp"></p>
<p>20150615141705040.png</p>
<h4 id="5、Socket常用函数接口及其原理"><a href="#5、Socket常用函数接口及其原理" class="headerlink" title="5、Socket常用函数接口及其原理"></a><strong>5、Socket常用函数接口及其原理</strong></h4><p>图解socket函数：</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-31d594363f8cafa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp"></p>
<p>20150615150446559.png</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-ec76f69e2ea76d41.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/478/format/webp"></p>
<p>20150615150618996.jpeg</p>
<h6 id="5-1、使用socket-函数创建套接字"><a href="#5-1、使用socket-函数创建套接字" class="headerlink" title="5.1、使用socket()函数创建套接字"></a>5.1、使用socket()函数创建套接字</h6><pre><code>int socket(int af, int type, int protocol);
</code></pre>
<ol>
<li>af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。<br> 大家需要记住127.0.0.1，它是一个特殊IP地址，表示本机地址，后面的教程会经常用到。</li>
<li> type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAM</li>
<li> protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议</li>
</ol>
<h6 id="5-2、使用bind-和connect-函数"><a href="#5-2、使用bind-和connect-函数" class="headerlink" title="5.2、使用bind()和connect()函数"></a>5.2、使用bind()和connect()函数</h6><p>socket() 函数用来创建套接字，确定套接字的各种属性，然后服务器端要用 <strong>bind() 函数</strong>将套接字与特定的IP地址和端口绑定起来，只有这样，流经该IP地址和端口的数据才能交给套接字处理；而客户端要用 connect() 函数建立连接</p>
<pre><code>int bind(int sock, struct sockaddr *addr, socklen_t addrlen);  
</code></pre>
<p>sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出<br>下面的代码，将创建的套接字与IP地址 127.0.0.1、端口 1234 绑定：</p>
<pre><code>//创建套接字
int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
//创建sockaddr_in结构体变量
struct sockaddr_in serv_addr;
memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充
serv_addr.sin_family = AF_INET;  //使用IPv4地址
serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址
serv_addr.sin_port = htons(1234);  //端口
//将套接字和IP、端口绑定
bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));
</code></pre>
<p>connect() 函数用来建立连接，它的原型为：</p>
<pre><code>int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); 
</code></pre>
<h6 id="5-3、使用listen-和accept-函数"><a href="#5-3、使用listen-和accept-函数" class="headerlink" title="5.3、使用listen()和accept()函数"></a>5.3、使用listen()和accept()函数</h6><p>于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。<br>通过** listen() 函数**可以让套接字进入被动监听状态，它的原型为：</p>
<pre><code>int listen(int sock, int backlog); 
</code></pre>
<p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。<br>所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p>
<p>请求队列<br>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</p>
<p>缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。</p>
<p>如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</p>
<p>当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误</p>
<p>注意：listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。</p>
<p>当套接字处于监听状态时，可以通过 <strong>accept() 函数</strong>来接收客户端请求。它的原型为：</p>
<pre><code>int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); 
</code></pre>
<p>它的参数与 listen() 和 connect() 是相同的：sock 为服务器端套接字，addr 为 sockaddr_in 结构体变量，addrlen 为参数 addr 的长度，可由 sizeof() 求得。</p>
<p>accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。</p>
<p>最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</p>
<h6 id="5-4、socket数据的接收和发送"><a href="#5-4、socket数据的接收和发送" class="headerlink" title="5.4、socket数据的接收和发送"></a>5.4、socket数据的接收和发送</h6><p>Linux下数据的接收和发送<br>Linux 不区分套接字文件和普通文件，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。</p>
<p>前面我们说过，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。<br>write() 的原型为：</p>
<pre><code>ssize_t write(int fd, const void *buf, size_t nbytes);
</code></pre>
<p>fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。<br>write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。<br>read() 的原型为：</p>
<pre><code>ssize_t read(int fd, void *buf, size_t nbytes);
</code></pre>
<p>fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。</p>
<p>read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。</p>
<h6 id="5-5、socket缓冲区以及阻塞模式"><a href="#5-5、socket缓冲区以及阻塞模式" class="headerlink" title="5.5、socket缓冲区以及阻塞模式"></a>5.5、socket缓冲区以及阻塞模式</h6><p>socket缓冲区<br>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p>
<p>write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</p>
<p>TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</p>
<p>read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取</p>
<p><img src= "/images/loading.gif" data-lazy-src="//upload-images.jianshu.io/upload_images/11362584-d4be2dd4bb3a26b8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/697/format/webp"></p>
<p>20180528234331238.jpeg</p>
<p>这些I/O缓冲区特性可整理如下：</p>
<pre><code>（1）I/O缓冲区在每个TCP套接字中单独存在；
（2）I/O缓冲区在创建套接字时自动生成；
（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
（4）关闭套接字将丢失输入缓冲区中的数据。
</code></pre>
<p>输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：</p>
<pre><code>unsigned optVal;
int optLen = sizeof(int);
getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&amp;optVal, &amp;optLen);
printf(&quot;Buffer length: %d\n&quot;, optVal);
</code></pre>
<p>阻塞模式<br>对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时：</p>
<pre><code>1) 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。
2) 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。
3) 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。
4) 直到所有数据被写入缓冲区 write()/send() 才能返回。
</code></pre>
<p>当使用 read()/recv() 读取数据时：</p>
<pre><code>1) 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。
2) 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。
3) 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。
这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。
</code></pre>
<p>TCP套接字默认情况下是阻塞模式</p>
<hr>
<blockquote>
<p>to be continued…</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:tamsiree.com@gmail.com" rel="external nofollow noreferrer">Tamsiree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/">https://tamsiree.com/Socket/Socket%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tamsiree.com" target="_blank">Tamsiree</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Socket/">Socket</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/lixianggup.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Function/qrcode_alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/TechnicalResearch/Python/DeepLearning/ECG/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84ECG%E5%BF%83%E5%BE%8B%E5%A4%B1%E5%B8%B8%E5%88%86%E7%B1%BB%E5%85%A5%E9%97%A8/"><img class="prev-cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-8c6afe1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于深度学习的ECG心律失常分类入门</div></div></a></div><div class="next-post pull-right"><a href="/Software/Windows10%E8%87%AA%E5%B8%A6%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0Gmail/"><img class="next-cover" src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg-21960ed.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows10自带邮件添加Gmail</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Avatar/avatar_sky_circle.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tamsiree</div><div class="author-info__description">勇于尝试才有可能迈向成功</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">137</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">139</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/tamsiree"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tamsiree" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github-square"></i></a><a class="social-icon" href="mailto:tamsiree.com@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope-square"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">只有用心灵才能看得清事物的本质，真正重要的东西是肉眼无法看见的。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">Socket原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">1、网络中进程如何通信</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1%E3%80%81%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.0.1.0.1.</span> <span class="toc-text">1.1、本地进程间通信</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.0.1.0.2.</span> <span class="toc-text">1.2、网络中进程如何通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Socket%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">2、Socket怎么通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81TCP-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">3、TCP&#x2F;IP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.0.3.0.1.</span> <span class="toc-text">3.1、概念</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2%E3%80%81TCP%E7%9A%84%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E8%BE%B9%E7%95%8C%E6%80%A7%EF%BC%9A-https-blog-csdn-net-m0-37947204-article-details-80490512"><span class="toc-number">2.1.0.3.0.2.</span> <span class="toc-text">3.2、TCP的粘包问题以及数据的无边界性：　https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_37947204&#x2F;article&#x2F;details&#x2F;80490512</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4%E3%80%81TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">2.1.0.3.0.3.</span> <span class="toc-text">3.4、TCP数据报结构：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-5%E3%80%81%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89%EF%BC%9A"><span class="toc-number">2.1.0.3.0.4.</span> <span class="toc-text">3.5、连接的建立（三次握手）：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-6%E3%80%81TCP%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.0.3.0.5.</span> <span class="toc-text">3.6、TCP四次握手断开连接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-7%E3%80%81%E5%85%B3%E4%BA%8E-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.0.3.0.6.</span> <span class="toc-text">3.7、关于 TIME_WAIT 状态的说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%EF%BC%98-%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E2%80%93shutdown"><span class="toc-number">2.1.0.3.0.7.</span> <span class="toc-text">3.８.优雅的断开连接–shutdown()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81OSI%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.0.4.</span> <span class="toc-text">4、OSI模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Socket%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.0.5.</span> <span class="toc-text">5、Socket常用函数接口及其原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#5-1%E3%80%81%E4%BD%BF%E7%94%A8socket-%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.1.0.5.0.1.</span> <span class="toc-text">5.1、使用socket()函数创建套接字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-2%E3%80%81%E4%BD%BF%E7%94%A8bind-%E5%92%8Cconnect-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.0.5.0.2.</span> <span class="toc-text">5.2、使用bind()和connect()函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-3%E3%80%81%E4%BD%BF%E7%94%A8listen-%E5%92%8Caccept-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.0.5.0.3.</span> <span class="toc-text">5.3、使用listen()和accept()函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-4%E3%80%81socket%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81"><span class="toc-number">2.1.0.5.0.4.</span> <span class="toc-text">5.4、socket数据的接收和发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-5%E3%80%81socket%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%A5%E5%8F%8A%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.0.5.0.5.</span> <span class="toc-text">5.5、socket缓冲区以及阻塞模式</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity多线程渲染导致部分手机崩溃"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/Konachan.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity多线程渲染导致部分手机崩溃"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/" title="Unity多线程渲染导致部分手机崩溃">Unity多线程渲染导致部分手机崩溃</a><time datetime="2023-11-09T11:55:51.000Z" title="发表于 2023-11-09 19:55:51">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的CDN之jsDelivr"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/20b24a69649941669d83bb997b01fed6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="好用的CDN之jsDelivr"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/" title="好用的CDN之jsDelivr">好用的CDN之jsDelivr</a><time datetime="2023-10-16T07:00:56.000Z" title="发表于 2023-10-16 15:00:56">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" title="Unity坐标系统"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/wallhaven-z8rqjo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity坐标系统"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" title="Unity坐标系统">Unity坐标系统</a><time datetime="2023-10-14T06:11:46.000Z" title="发表于 2023-10-14 14:11:46">2023-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E7%9A%84ShaderLab%E7%9D%80%E8%89%B2%E5%99%A8%E5%85%A5%E9%97%A8/" title="Unity的ShaderLab着色器入门"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/wallhaven-kxj3l1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity的ShaderLab着色器入门"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E7%9A%84ShaderLab%E7%9D%80%E8%89%B2%E5%99%A8%E5%85%A5%E9%97%A8/" title="Unity的ShaderLab着色器入门">Unity的ShaderLab着色器入门</a><time datetime="2023-10-12T10:18:23.000Z" title="发表于 2023-10-12 18:18:23">2023-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/C-%E4%B8%ADReadOnly%E5%92%8CConst%E7%9A%84%E5%8C%BA%E5%88%AB/" title="C#中ReadOnly和Const的区别"><img src= "/images/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/78dc5761ab8c4b55b940967ae24ebe3a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#中ReadOnly和Const的区别"/></a><div class="content"><a class="title" href="/%E9%9A%8F%E6%89%8B%E8%AE%B0/C-%E4%B8%ADReadOnly%E5%92%8CConst%E7%9A%84%E5%8C%BA%E5%88%AB/" title="C#中ReadOnly和Const的区别">C#中ReadOnly和Const的区别</a><time datetime="2022-11-04T06:08:52.000Z" title="发表于 2022-11-04 14:08:52">2022-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2024 By Tamsiree</div><div class="footer_custom_text">不要盯着我看，已经到底啦～</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://comment.tamsiree.com',
      path: location.pathname,
      visitor: true,
      dark: 'html[data-theme="dark"]'
    }, {"placeholder":"留下你的脚印与心声~","pageSize":10,"lang":"zh-CN","requiredFields":["nick"]}))
  }

  if (typeof Waline === 'function') initWaline()
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/talking/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>