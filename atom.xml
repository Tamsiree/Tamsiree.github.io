<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tamsiree</title>
  <icon>https://www.gravatar.com/avatar/6f05c6132e630e969d55a8ea105fd562</icon>
  
  <link href="https://tamsiree.com/atom.xml" rel="self"/>
  
  <link href="https://tamsiree.com/"/>
  <updated>2026-02-05T07:34:38.159Z</updated>
  <id>https://tamsiree.com/</id>
  
  <author>
    <name>Tamsiree</name>
    <email>tamsiree.com@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo 中 Waline 故障修复指南</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Hexo%E4%B8%ADWaline%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Hexo%E4%B8%ADWaline%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/</id>
    <published>2026-02-05T07:25:41.000Z</published>
    <updated>2026-02-05T07:34:38.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="Hexo-Butterfly-Waline-Supabase-全链路故障修复与维护手册"><a href="#Hexo-Butterfly-Waline-Supabase-全链路故障修复与维护手册" class="headerlink" title="Hexo Butterfly + Waline + Supabase 全链路故障修复与维护手册"></a>Hexo Butterfly + Waline + Supabase 全链路故障修复与维护手册</h1><p>** 文档版本：** 2026 年 2 月（完整修订版）<br>** 适用场景：** Hexo 博客（Butterfly 主题）更新后，评论系统迁移至 Vercel + Supabase 架构，解决留言板失效、数据库连接报错及数据迁移问题。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="第一阶段：前端配置-Hexo-Butterfly-主题"><a href="#第一阶段：前端配置-Hexo-Butterfly-主题" class="headerlink" title="第一阶段：前端配置 (Hexo Butterfly 主题)"></a>第一阶段：前端配置 (Hexo Butterfly 主题)</h2><p>** 问题背景：** 更新 Butterfly 主题或更换 Waline 后端地址后，评论区消失，或者留言板加载不出以前的评论。</p><h3 id="1-核心配置检查-config-butterfly-yml"><a href="#1-核心配置检查-config-butterfly-yml" class="headerlink" title="1. 核心配置检查 (_config.butterfly.yml)"></a>1. 核心配置检查 (<code>_config.butterfly.yml</code>)</h3><p>在主题配置文件中，必须准确填写 Waline 的新后端地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.butterfly.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Waline</span>  <span class="comment"># 确保启用了 Waline</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span>   <span class="comment"># 是否显示评论按钮</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span> <span class="comment"># 推荐开启懒加载</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span>  <span class="comment"># 显示评论数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">serverURL:</span> [<span class="string">https:// 你的 Vercel 自定义域名. com</span>]<span class="string">(https:// 你的 Vercel 自定义域名. com)</span>  <span class="comment"># ❌ 不要填 Vercel 原始域名，✅ 填绑定好的自定义域名</span></span><br><span class="line">  <span class="attr">pageview:</span> <span class="literal">true</span> <span class="comment"># 文章阅读量统计</span></span><br><span class="line">  <span class="attr">option:</span></span><br><span class="line">    <span class="comment"># 其他可选配置...</span></span><br></pre></td></tr></table></figure><h3 id="2-留言板-Message-Board-路径映射问题-关键！"><a href="#2-留言板-Message-Board-路径映射问题-关键！" class="headerlink" title="2. 留言板 (Message Board) 路径映射问题 (关键！)"></a>2. 留言板 (Message Board) 路径映射问题 (关键！)</h3><p>** 痛点：** 留言板是自定义页面，Waline 依靠 <code>path</code>（路径）来识别评论归属。如果你更新主题后，页面的访问路径变了（比如从 <code>/messageboard/</code> 变成了 <code>/guestbook/</code>），旧评论就会“消失”。</p><ul><li>** 现象 **：文章页评论正常，但 “留言板 | Tamsiree” 显示 0 条评论。</li><li>** 排查依据 **：根据你的备份文件 <code>waline.json</code>，留言板的历史评论全部存储在 <strong><code>/messageboard/</code></strong> 这个路径下。</li><li>** 解决方案 **：<ul><li>** 检查 Front-matter**：打开你博客源码中的 <code>source/messageboard/index.md</code>（或 <code>guestbook/index.md</code>）。</li><li>** 强制指定 path**：为了防止主题生成的链接带 <code>index.html</code> 或结尾斜杠不一致，建议在 Front-matter 中显式指定 Waline 的 path。</li></ul>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">留言板</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-01-01</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mw_path:</span> <span class="string">/messageboard/</span>  <span class="comment"># 部分主题支持显式指定 path，或者依靠文件夹名称</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><ul><li>** 验证方法 **：在浏览器访问你的留言板，F12 打开控制台，看 Waline 发出的请求是否包含 <code>path=/messageboard/</code>。</li></ul></li></ul><hr><h2 id="第二阶段：域名与网络基础"><a href="#第二阶段：域名与网络基础" class="headerlink" title="第二阶段：域名与网络基础"></a>第二阶段：域名与网络基础</h2><p>** 问题背景：** Vercel 默认域名被阻断，或后端无法连接。</p><h3 id="1-域名策略"><a href="#1-域名策略" class="headerlink" title="1. 域名策略"></a>1. 域名策略</h3><ul><li>** 必须绑定自定义域名 **：在 Vercel 后台 <code>Settings -&gt; Domains</code> 绑定 <code>comment.yourdomain.com</code>。</li><li>**DNS 解析 **：在 Cloudflare/Dnspod 添加 CNAME 记录指向 <code>cname.vercel-dns.com</code>。</li><li>** 前端调用 **：Hexo 主题配置里的 <code>serverURL</code> 必须用这个自定义域名。</li></ul><hr><h2 id="第三阶段：后端连接-Vercel-lt-gt-Supabase"><a href="#第三阶段：后端连接-Vercel-lt-gt-Supabase" class="headerlink" title="第三阶段：后端连接 (Vercel &lt;-&gt; Supabase)"></a>第三阶段：后端连接 (Vercel &lt;-&gt; Supabase)</h2><p>** 问题背景：** 报错 <code>500: Not initialized</code> 或 <code>Not IPv4 compatible</code>。Vercel 无法连接 Supabase 的 IPv6 直连地址。</p><h3 id="✅-解决方案：环境变量拆分"><a href="#✅-解决方案：环境变量拆分" class="headerlink" title="✅ 解决方案：环境变量拆分"></a>✅ 解决方案：环境变量拆分</h3><p>在 Vercel 后台 (<code>Settings</code> -&gt; <code>Environment Variables</code>)，** 禁用 ** 单一的 <code>DATABASE_URL</code>，改为 ** 拆分填写 **：</p><table><thead><tr><th align="left">变量名</th><th align="left">填写值示例</th><th align="left">关键说明</th></tr></thead><tbody><tr><td align="left"><strong><code>PG_HOST</code></strong></td><td align="left"><code>aws-0...pooler.supabase.com</code></td><td align="left">** 核心！** 必须用 <code>pooler</code> 地址（aws 开头），不能用 <code>db.</code> 开头。</td></tr><tr><td align="left"><strong><code>PG_PORT</code></strong></td><td align="left"><code>5432</code></td><td align="left">必须用 Session 模式端口 <code>5432</code>。</td></tr><tr><td align="left"><strong><code>PG_USER</code></strong></td><td align="left"><code>postgres. 你的项目 ID</code></td><td align="left">** 易错！** 必须包含中间的点（Supabase Pooler 用户名格式）。</td></tr><tr><td align="left"><strong><code>PG_PASSWORD</code></strong></td><td align="left"><code>******</code></td><td align="left">数据库密码。</td></tr><tr><td align="left"><strong><code>PG_DB</code></strong></td><td align="left"><code>postgres</code></td><td align="left">默认数据库名。</td></tr><tr><td align="left"><strong><code>PG_SSL</code></strong></td><td align="left"><strong><code>true</code></strong></td><td align="left">** 必填！** 显式开启 SSL 加密。</td></tr></tbody></table><hr><h2 id="第四阶段：数据库结构-SQL-修复"><a href="#第四阶段：数据库结构-SQL-修复" class="headerlink" title="第四阶段：数据库结构 (SQL 修复)"></a>第四阶段：数据库结构 (SQL 修复)</h2><p>** 问题背景：** 报错 <code>relation &quot;wl_Counter&quot; does not exist</code> 或缺少 <code>github</code> 等字段。</p><h3 id="✅-解决方案：SQL-补全"><a href="#✅-解决方案：SQL-补全" class="headerlink" title="✅ 解决方案：SQL 补全"></a>✅ 解决方案：SQL 补全</h3><p>登录 Supabase -&gt; <strong>SQL Editor</strong> 执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建计数表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> wl_Counter (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    url <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    <span class="type">time</span> <span class="type">INTEGER</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    updated_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 补全社交字段（防止导入报错）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> wl_Users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;2fa&quot; <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> wl_Users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;github&quot; <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> wl_Users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;twitter&quot; <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> wl_Users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;facebook&quot; <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> wl_Users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;google&quot; <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> wl_Users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;weibo&quot; <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> wl_Users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;qq&quot; <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="第五阶段：数据迁移-导入报错修复"><a href="#第五阶段：数据迁移-导入报错修复" class="headerlink" title="第五阶段：数据迁移 (导入报错修复)"></a>第五阶段：数据迁移 (导入报错修复)</h2><p>** 问题背景：** 导入 <code>waline.json</code> 时报错 <code>duplicate key value violates unique constraint</code>。</p><h3 id="✅-解决方案：清洗流程"><a href="#✅-解决方案：清洗流程" class="headerlink" title="✅ 解决方案：清洗流程"></a>✅ 解决方案：清洗流程</h3><ol><li>** 清洗备份文件 **：<ul><li>问题源头：备份文件中 <code>Counter</code> 数组存在重复 URL（如两条 <code>/</code> 首页记录）。</li><li>操作：使用脚本去重，保留 <code>time</code>（阅读量）最大的记录。</li></ul></li><li>** 清空残留数据 **：<ul><li><em>Supabase SQL:</em> <code>TRUNCATE TABLE wl_Counter, wl_Comment, wl_Users RESTART IDENTITY;</code></li></ul></li><li> ** 重新导入 **：上传清洗后的 json 文件。</li></ol><hr><h2 id="第六阶段：长期维护-防休眠保活"><a href="#第六阶段：长期维护-防休眠保活" class="headerlink" title="第六阶段：长期维护 (防休眠保活)"></a>第六阶段：长期维护 (防休眠保活)</h2><p>** 问题背景：** Supabase 免费版 7 天无请求会自动暂停，导致评论区报错。</p><h3 id="✅-解决方案：UptimeRobot-监控"><a href="#✅-解决方案：UptimeRobot-监控" class="headerlink" title="✅ 解决方案：UptimeRobot 监控"></a>✅ 解决方案：UptimeRobot 监控</h3><p>配置定时任务，伪装成 Hexo 前端去 “戳” 一下数据库。</p><ul><li>** 工具 **：<a href="https://uptimerobot.com/">UptimeRobot</a></li><li>** 类型 **：<code>HTTP(s)</code></li><li>** 频率 **：<code>5 min</code></li><li>**URL (核心配置)**：  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:// 你的 Vercel 自定义域名 / api/comment?path=/messageboard/</span><br></pre></td></tr></table></figure><blockquote><p>** 为什么填这个？** 必须访问 <code>/api/comment</code> 接口，并带上 <code>?path=/messageboard/</code>（留言板路径），强制触发数据库读取操作，从而重置 7 天倒计时。</p></blockquote></li></ul><hr><h3 id="🎉-故障排查速查表"><a href="#🎉-故障排查速查表" class="headerlink" title="🎉 故障排查速查表"></a>🎉 故障排查速查表</h3><ol><li> ** 评论区转圈 / 500** -&gt; 检查 Vercel 环境变量（SSL/Pooler 地址）。</li><li> ** 提示表不存在 ** -&gt; 去 Supabase 执行 SQL 建表。</li><li> ** 导入报 Key 重复 ** -&gt; 清洗 JSON 文件，清空数据库重试。</li><li> ** 留言板没评论 ** -&gt; 检查 Hexo 页面 URL 是否与数据库 path 一致。</li><li> ** 过几天突然挂了 ** -&gt; 检查 UptimeRobot 是否正常运行，去 Supabase 后台点击 “Restore”。</li></ol><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>独立游戏的成功之母</title>
    <link href="https://tamsiree.com/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/"/>
    <id>https://tamsiree.com/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E6%AF%8D/</id>
    <published>2025-11-11T05:08:38.000Z</published>
    <updated>2025-11-11T13:36:56.368Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="🎲-独立游戏的高失败率与成功秘诀"><a href="#🎲-独立游戏的高失败率与成功秘诀" class="headerlink" title="🎲 独立游戏的高失败率与成功秘诀"></a>🎲 独立游戏的高失败率与成功秘诀</h2><p><img src="https://bibigpt-apps.chatvid.ai/screenshots/bilibili.com/BV14P2cBaE81/0.jpg" alt="章节截图 00:00"></p><p>为什么这款游戏会失败？或者这款，或者那款？感觉是五五开。如果你开发独立游戏，完全不知道骰子会怎么落，情况只会更糟。当你意识到只有 4% 的游戏能盈利，这概率简直糟糕透了！</p><p>但有些却成功了，所以我为什么不能？我…… 这就是老生常谈的问题。肯定有方法在其中，某种能让游戏畅销的秘诀。</p><p>正如本杰明 · 安德森所说，如果你在寻找独立游戏开发大师，有制胜法宝或简单技巧，想成为成功开发者——然而，** 存在经过验证的商业流程 **，遵循后可大幅降低失败风险，确保独立游戏具备成功潜力的基础步骤。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="💡-转变热情：从想法到开发过程"><a href="#💡-转变热情：从想法到开发过程" class="headerlink" title="💡 转变热情：从想法到开发过程"></a>💡 转变热情：从想法到开发过程</h2><p><img src="https://bibigpt-apps.chatvid.ai/screenshots/bilibili.com/BV14P2cBaE81/42.jpg" alt="章节截图 00:42"></p><p>这一切始于转变你的热情。所有开发者遇到的第一个问题，就是过于专注想法。充满热情的项目，通常以他们热爱的游戏为模板。这些开发者初期很顺利，梦想游戏驱动他们前进，但随后遇到一些障碍。这些开发者意识到编程很难，或发现自己不够艺术，或音乐不够出色。无论怎样，自我怀疑的感觉涌上心头。这些曾经热情的开发者陷入“冒名顶替综合征”，觉得自己无法完成，或游戏开发不适合自己。</p><p>即使完成游戏的开发者也常犯错，因为当游戏上线无人问津时，他们选择放弃，认为自己是失败者。这种心态导致 Steam 平台 75% 的开发者仅发布一款游戏。投入时间和学习技能开发游戏，你本应从中学习，继续尝试。但他们不会，因为大多数开发者逐渐失去创作热情，将心血投入注定沉寂的作品。</p><p>这种挫败感源于优先级错误。不要把热情寄托在想法上，而是在创作过程中，充满建造的热情，进行测试、制作。这些都是你在开发游戏或任何事物时，需要学会热爱的要素。</p><p>我最喜欢的这种心态例子是 ** 约翰 · 罗梅罗 ** 及其软件，<strong>《毁灭战士》</strong> 的创作者。当年他们可是猛兽级人物。** 约翰 · 罗梅罗 ** 在书中提到：“ ** 卡马克 <strong>、</strong> 汤姆 **，我和他各自在合作前已有十年游戏开发经验。我们直到几年后才做出 <strong>《毁灭战士》</strong>，而这正是我的第九十款游戏。” ** 约翰 ** 在制作 <strong>《毁灭战士》</strong> 前已开发了九十款游戏。</p><p>但更有趣的是，直到近十五年后，** 约翰 ** 和他的团队才获得全球成功。当被问及成功之道时，** 约翰 · 罗梅罗 ** 说：“执行才是关键。成功不取决于创意本身，而是取决于执行创意的能力。”</p><p>给自己时间提升技艺，不要被挫折动摇。游戏开发如同游戏玩法：加载存档，再试一次。第一步是转变你的热情，改变你的思维方式。当然要对正在制作的游戏充满热情，但更要热衷于游戏制作的过程。引用 <strong>《巨人的陨落》</strong> 中的名言。</p><hr><h2 id="🗣️-倾听玩家：避免-“荷马式”-失败"><a href="#🗣️-倾听玩家：避免-“荷马式”-失败" class="headerlink" title="🗣️ 倾听玩家：避免 “荷马式” 失败"></a>🗣️ 倾听玩家：避免 “荷马式” 失败</h2><p><img src="https://bibigpt-apps.chatvid.ai/screenshots/bilibili.com/BV14P2cBaE81/172.jpg" alt="章节截图 02:52"></p><p>我最爱的书籍之一是 <em><strong>《旅程重于目的地》</strong></em> 。但就像所有旅程，你需要明确目标方向。在独立开发语境下，你需要清楚谁会购买并游玩你的游戏。</p><p>开发者往往只关注自身需求，甚至亲密少数朋友想要的，而非多数人的真实需求。打造类似霍默的汽车，和 <strong>《辛普森一家》</strong> 的泡泡与多角车灯，以及所有其他怪异装饰。</p><p>我要重复对数百人说过的话：我曾建议霍默和他的半兄，在制作这辆车时，停止开发去与人交流。这是避免霍默式失败的第二步。这个避免失败的层级，应在编写第一行代码前完成。将创意带给玩家，了解他们喜欢什么，也要知道他们不喜欢什么，获取反馈。</p><p>不要听那些说这话的人的建议：“如果福特曾问人们想要什么，他们只会要一匹更快的马，而不是汽车。”我讨厌名言。我可以保证福特会和人们交谈，当他听到人们说想要更快的马，他足够聪明能透过字面理解他们真正想要更快的旅行。</p><p>做同样的事：倾听人们的诉求，不仅仅是字面意思，还有他们的感受。这会带来无数灵感，并帮助你创造看似 ** 不可能 ** 的事物。不要自以为比他人更懂。</p><p>我在第一家公司犯了错误。我创立了一家名为 <strong>Speech Cloud</strong> 的广告科技公司。我对市场做了各种假设，因为我没有验证这些假设，最终导致失败并不得不转型。我太冲动，认为我最在行，而且懒得出门和人交流。</p><p><strong>Battlebot</strong> 团队也犯了错误。他们过于专注于开发小队竞技游戏，没意识到社区不需要他们正在制作的内容，因为他们未验证和倾听玩家。这让他们耗费多年开发。</p><p><strong>Filament</strong> 的早期版本完全硬核，当时几乎失败，因为没有受众喜欢极端硬核方块游戏。我们将其改为休闲模式。</p><p>要意识到你并不知道人们想要什么。直接询问，不要全盘接受所有意见，但尽可能多学习。这能帮助你在开发中避开重大陷阱。</p><p>以为自己有酷炫的东西？发布游戏？天，这家伙真差劲！</p><hr><h2 id="📊-了解市场：成为创业者而非纯开发者"><a href="#📊-了解市场：成为创业者而非纯开发者" class="headerlink" title="📊 了解市场：成为创业者而非纯开发者"></a>📊 了解市场：成为创业者而非纯开发者</h2><p><img src="https://bibigpt-apps.chatvid.ai/screenshots/bilibili.com/BV14P2cBaE81/303.jpg" alt="章节截图 05:03"></p><p>但即使这样，如何确定背后吼叫的人值得倾听？如何确保在和正确的人对话？我们常从永远不会玩我们游戏的人那里征求反馈，向讨厌 JRPG 的人询问我们的 JRPG。我们还得完成七个土豆支线任务，这样我的角色才能游得快 3%。</p><p>** 找到正确玩家群体，你需要研究市场，具体研究你所参与的类型。** 这些信息将成为你构建游戏的基础，帮助你确定开发方向。这是避免失败的第三步： ** 了解你的市场 **。</p><p>现在，这听起来对一些人来说太忙碌了，他们认为我只是游戏开发者，我不需要了解市场，我只需要专注于制作优秀游戏。如果你有这种心态，嗯，我希望能改变你的想法。因为你不仅仅是开发者，你是创业者，你正在开创事业。这项事业需要你超越单纯的程序员或艺术家。你需要身兼数职，从开发到营销，至少要掌握几项技能，如果你有团队的话。而你或团队成员需要了解市场。</p><p>现在有些人在问，市场到底是什么？我如何确定自己在接触正确的玩家群体？我如何判断市场的潜力？我会尽力解释，用例子说明，简单的事例。</p><p>想象你喜欢匹配类游戏，想自己开发一款，比如《糖果传奇》。嗯，所有游戏都属于某种基础类型，无论是解谜类、平台跳跃类、射击类或其它类型。我们知道《糖果传奇》属于解谜游戏市场，因为 Steam 标签、应用商店分类和大量其他标签。因此，确定你的市场或类型，你需要寻找类似的游戏，通过查看标签，并倾听玩家如何分类相似作品。</p><p>但解谜游戏形态各异，《传送门》和《糖果传奇》都被归为解谜类。我可以告诉你，我的《糖果传奇》最爱奶奶的版本不会很快推出《传送门》。因此，目标群体差异显著。这就是为什么需要细分标签，通常称为 ** 子市场 ** 或 ** 子类型 ** ，如《传送门》、《糖果传奇》以及各种独立分类。而拥有自己玩家群体的《传送门》以解谜平台游戏闻名，而《糖果粉碎传奇》是三消类益智游戏。所以以我们的例子，我们需要关注三消子市场，而非平台解谜类，以确定目标玩家群体。</p><p>只需浏览网站或 Steam，你将发现各类三消游戏的数据与信息。这是我找到的：60% 的三消玩家为女性玩家，且多数年龄在 25 至 34 岁之间（另一网站数据）。他们分析了三消玩家的典型画像，揭示人们为何玩三消游戏。另一研究显示哪种匹配风格更成功在某些国家。我还可以继续，三消游戏有大量人口统计数据，说实话有点令人不安。但你能获取所有信息。这些数据和研究告诉我目标玩家是谁，以及三消游戏的成功与不足。某些类型数据较少，需要进一步挖掘。</p><p>但我的市场潜力如何？如何判断开发此游戏值得投入？嗯，假设没有其他益智游戏存在，所有益智市场玩家都购买你的《糖果粉碎传奇》，你将赚取 150 亿美元。根据最新益智市场收入数据，确实很可观，但这当然不现实。正如我之前所说，益智市场玩家群体有多种变体。因此，无论你的益智游戏多么出色，也无法赚取 150 亿美元，因为玩家品味各不相同。</p><p>所以我们需分析游戏子市场的真实潜力。若查看三消类收入数据，市场年均约 10 亿至 20 亿美元，而非 150 亿，但这仍是一大份额。</p><p>现在，我们了解市场及其最高潜力，需确定游戏在三消类中的表现。这正是之前研究的作用：哪些游戏与你的类似？它们表现如何？它们在哪些平台表现优异？</p><p>如果我们看看表现最高的三消游戏，我们可以看到前五名占据了 85% 的市场份额。这说明三消类游戏主要由少数公司主导，独立游戏很难迅速打入市场。如果我们看看榜单的后五名，他们的收入增长明显放缓。如果我们也看看平均三消游戏，大多数下载量不超过五千，每款游戏收入不足五千美元，根据安卓和 Steam 的数据。我发现这些信息揭示了发生的情况：你的游戏即便爆红，也可能只赚取几千美元。</p><p>所以如果你计划开发三消游戏，需要一年时间和五十万美元投资，大概率会商业失败。但如果用两百美元在月内开发，则大获成功。这些信息并非要劝阻你做游戏，而是提供帮助，让你做出明智决策并设定合理预期。</p><p>在最近与独立开发者的一次对话中，我们讨论了他的平台格斗游戏项目。他告诉我已开发这款游戏几年，只需两万美元就能完成游戏。这立刻引起了我的警觉。于是我问他市场规模有多大？他并不完全确定。但通过研究我们发现，前 10% 的独立平台格斗游戏平均收入四到八万美元。还不错，但这只是前 10%，不是平均水平。开发者花了几年时间制作平台格斗游戏，试图获得数十万美元投资，最终仅赚回略超投资金额。这很糟糕。没有正规发行商或投资者会投入这笔钱，投资回报率如此之低。你需要了解市场并设定合理预期。</p><p>但为何 3A 游戏表现如此出色？</p><hr><h2 id="📢-有效营销：精准触达目标受众"><a href="#📢-有效营销：精准触达目标受众" class="headerlink" title="📢 有效营销：精准触达目标受众"></a>📢 有效营销：精准触达目标受众</h2><p><img src="https://bibigpt-apps.chatvid.ai/screenshots/bilibili.com/BV14P2cBaE81/637.jpg" alt="章节截图 10:37"></p><p>而许多独立游戏却困难重重。</p><p><strong>3A</strong> 与独立游戏的主要区别在于，这是我们的第四，也是最后一点：大多数独立游戏失败源于营销不足。大多数独立游戏失败，因为开发者不营销游戏，或营销方式不当。</p><p>现在，要覆盖营销和独立开发领域的问题需要整个视频。如果你对视频感兴趣，订阅并告诉我你的兴趣；或者你可以查看我们的 Patreon 内容，获取深入解析。但我们现在先保持简单。</p><p>独立工作室挣扎是因为在营销上投入的时间和资金不足。当他们开始营销时，却像我之前解释的那样，对错误人群推广。大多数开发者并不清楚目标玩家群体是谁，只是随意在社交媒体发布内容，以为有人会看到他们的帖子，就能像热卖商品一样卖出游戏。 <strong>“宝宝需要一双新鞋！”</strong> 可惜，这样行不通。</p><p>营销在于创造价值，特别是内容营销。当你制作社交媒体帖子或开发日志时，要问自己：观众从这段视频或文章中获得什么价值？是否具有启发性？是否具有教育性？是否具有娱乐性？在火车上玩耍？别告诉我你的游戏。 ** 提供某种价值 **，如果你想让我观看，或让我想阅读。</p><p>其次，要精准触达目标受众。即使视频获得十万次播放，也不代表这些流量能转化为愿望清单或销量。</p><p>最近视频中提到的独立游戏就是很好的例子—— <strong>《坦克但没有坦克》</strong>。我一直在和托马斯聊天，这位开发者正在接受免费咨询。他最大的问题是知名度不足，像大多数独立开发者一样。所以我给了他一些建议，并告诉他我们会在他的游戏中做一期视频推荐，以吸引更多人访问他的 Steam 页面。顺便说一下，我已将他的游戏链接在下方。</p><p>我随意选择了托马斯的游戏 <strong>《坦克但没有坦克》</strong>。但视频中没有坦克。当时我在制作的视频 <strong>《反恐精英》</strong> 本该早已结束，视频表现良好，获得了百万级播放量。奇怪的是，尽管托马斯的游戏获得了大量曝光，<strong>《坦克但没有坦克》</strong> 却仅从 <strong>《反恐精英》</strong> 视频中获得少量销量。这是我的营销失败的典型案例。</p><p><strong>《坦克但没有坦克》</strong> 更像是派对游戏，你会在任天堂主机上玩这类游戏。这不是竞技射击类游戏，玩家不会像玩 <strong>《反恐精英》</strong> 那样流汗。所以我搞砸了。</p><p>想象一下另一种情况：如果我做关于老式经典 Wii 游戏的视频，讲述它们的乐趣，展示坦克，但结尾却没有坦克，你觉得他的转化效果会怎样？</p><p>那 ** 你觉得 ** 他的转化效果会怎样？如果我以更相关的方式谈论他的游戏，在视频中而非结尾部分（人们流失的地方）。就像我现在正在做的，这是营销的关键。</p><p>你需要了解受众在哪里，他们使用的社交平台是什么，你能提供什么价值，以及为什么他们应该关心。</p><p>说到这里，必须记住游戏不仅是商业。某些游戏失败的原因并非那么简单，而另一些却成功，其中还涉及情感、文化和社会影响等因素。但许多独立游戏失败的原因在于忘记游戏是艺术与商业的结合。你 ** 可以 ** 制作最 <strong>amazing</strong> 的游戏，但若无法触达正确受众，一切都毫无意义。</p><hr><h2 id="🚀-艺术与商业的结合：持续迭代走向成功"><a href="#🚀-艺术与商业的结合：持续迭代走向成功" class="headerlink" title="🚀 艺术与商业的结合：持续迭代走向成功"></a>🚀 艺术与商业的结合：持续迭代走向成功</h2><p><img src="https://bibigpt-apps.chatvid.ai/screenshots/bilibili.com/BV14P2cBaE81/814.jpg" alt="章节截图 13:34"></p><p>你需要调整你的热情、研究市场、确定潜力，向正确受众推广游戏。如果你做到这一点，将大幅降低失败几率。记住，失败九成是视角问题。</p><p>如果你想发布你的独立游戏，而这正是你想要达成的，那么游戏是否盈利无关紧要，只要这是你的目标。人的失败是另一种成功。所以，要像 ** 约翰 · 罗梅洛 ** 那样，只享受创作的过程。如果你这样做，并在独立游戏的商业方面投入努力，不要感到意外，当你发现自己成功开发了独立游戏。要像最初提到的三位失败游戏的开发者那样，持续制作游戏直到成功。</p><p>现在结束视频，我们要再给 ** 托马斯 ** 一些关注。他在游戏上付出了很多努力，他立志长期成为独立开发者。所以，去拿一本坦克的书，但没有坦克，并告诉你的朋友：祝所有独立开发者们好运，继续努力实现目标。再见！</p><hr><blockquote><p>参考来源：<a href="https://www.bilibili.com/video/BV14P2cBaE81">为什么 96% 的独立游戏会失败</a></p></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="游戏" scheme="https://tamsiree.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="独立游戏" scheme="https://tamsiree.com/categories/%E6%B8%B8%E6%88%8F/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="https://tamsiree.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="独立游戏" scheme="https://tamsiree.com/tags/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker 中 MongoDB 数据库的备份与恢复</title>
    <link href="https://tamsiree.com/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>https://tamsiree.com/Docker/MongoDB/Docker%E4%B8%ADMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</id>
    <published>2025-11-06T00:49:58.000Z</published>
    <updated>2025-11-11T13:42:10.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实际开发和部署过程中，我们经常需要在 Docker 环境中管理 MongoDB 数据库。本文将详细介绍如何在 Docker 中备份和恢复 MongoDB 数据库，并解决在此过程中可能遇到的各种问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-MongoDB-数据库导出"><a href="#1-MongoDB-数据库导出" class="headerlink" title="1. MongoDB 数据库导出"></a>1. MongoDB 数据库导出</h2><h3 id="1-1-导出工具选择"><a href="#1-1-导出工具选择" class="headerlink" title="1.1 导出工具选择"></a>1.1 导出工具选择</h3><table><thead><tr><th>工具</th><th>格式</th><th>适用场景</th><th>数据保真度</th></tr></thead><tbody><tr><td>mongodump</td><td>二进制 BSON</td><td>完整备份 / 迁移</td><td>高，保留所有数据类型</td></tr><tr><td>mongoexport</td><td>JSON/CSV</td><td>数据分析 / 交换</td><td>可能损失部分数据类型</td></tr></tbody></table><h3 id="1-2-使用-mongodump-进行完整备份"><a href="#1-2-使用-mongodump-进行完整备份" class="headerlink" title="1.2 使用 mongodump 进行完整备份"></a>1.2 使用 mongodump 进行完整备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Docker 容器内执行 mongodump</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;mongodb_container_name&gt; mongodump -h 127.0.0.1:27017 --authenticationDatabase=admin -u &lt;username&gt; -p &lt;password&gt; -d &lt;database_name&gt; -o /tmp/mongodb_backup --gzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在我本机使用的命令 </span></span><br><span class="line">docker <span class="built_in">exec</span> -it b85158ed3a6c mongodump -h 127.0.0.1:27017 --authenticationDatabase=admin -u mongo_tBF2DfnRVqrW -p xh1JJqbwFn739EfIO9yJCnkj -o /tmp/mongodb_backup --gzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将备份文件从容器复制到宿主机 </span></span><br><span class="line">docker <span class="built_in">cp</span> &lt;mongodb_container_name&gt;:/tmp/mongodb_backup /path/on/your/host/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在我本机使用的命令 </span></span><br><span class="line">docker <span class="built_in">cp</span> b85158ed3a6c:/tmp/mongodb_backup /tmp/</span><br></pre></td></tr></table></figure><h3 id="1-3-使用-mongoexport-导出特定集合"><a href="#1-3-使用-mongoexport-导出特定集合" class="headerlink" title="1.3 使用 mongoexport 导出特定集合"></a>1.3 使用 mongoexport 导出特定集合</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出特定集合为 JSON 格式 </span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;mongodb_container_name&gt; mongoexport -h 127.0.0.1:27017 --authenticationDatabase=admin -u &lt;username&gt; -p &lt;password&gt; -d &lt;database_name&gt; -c &lt;collection_name&gt; --<span class="built_in">type</span>=json --out /tmp/&lt;collection_name&gt;.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到宿主机 </span></span><br><span class="line">docker <span class="built_in">cp</span> &lt;mongodb_container_name&gt;:/tmp/&lt;collection_name&gt;.json /path/on/your/host/</span><br></pre></td></tr></table></figure><h2 id="2-MongoDB-数据库导入"><a href="#2-MongoDB-数据库导入" class="headerlink" title="2. MongoDB 数据库导入"></a>2. MongoDB 数据库导入</h2><h3 id="2-1-导入工具选择"><a href="#2-1-导入工具选择" class="headerlink" title="2.1 导入工具选择"></a>2.1 导入工具选择</h3><table><thead><tr><th>工具</th><th>源格式</th><th>适用场景</th><th>对应导出工具</th></tr></thead><tbody><tr><td>mongorestore</td><td>BSON</td><td>完整备份恢复</td><td>mongodump</td></tr><tr><td>mongoimport</td><td>JSON/CSV</td><td>逻辑数据导入</td><td>mongoexport</td></tr></tbody></table><h3 id="2-2-Windows-环境下的导入操作"><a href="#2-2-Windows-环境下的导入操作" class="headerlink" title="2.2 Windows 环境下的导入操作"></a>2.2 Windows 环境下的导入操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：目录挂载（推荐）</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -it -v C:\Users\Tamsiree\Desktop\fsdownload\mongodb_backup:/tmp/restore mongo:6.0 bash -c <span class="string">&#x27;mongorestore -h host.docker.internal --authenticationDatabase admin -u mongo_yr3ZiF -p mongo_A55pcm --gzip --drop /tmp/restore&#x27;</span></span><br><span class="line"></span><br><span class="line">docker run --<span class="built_in">rm</span> -it -v C:\Users\Tamsiree\Desktop\fsdownload\mongodb_backup:/tmp/restore mongo:6.0 bash -c <span class="string">&#x27;mongorestore -h host.docker.internal:17177 --authenticationDatabase admin -u mongo_tBF2DfnRVqrW -p xh1JJqbwFn739EfIO9yJCnkj --gzip --drop /tmp/restore&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：文件复制到运行中的容器 </span></span><br><span class="line">docker <span class="built_in">cp</span> <span class="string">&quot;C:\Users\Tamsiree\Desktop\fsdownload\mongodb_backup&quot;</span> mongo-local:/tmp/restore</span><br><span class="line">docker <span class="built_in">exec</span> -it mongo-local mongorestore -h 127.0.0.1:27017 --authenticationDatabase admin -u mongo_yr3ZiF -p mongo_A55pcm --gzip --drop /tmp/restore</span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>通过本文的介绍，我们全面了解了在 Docker 环境中管理 MongoDB 数据库的完整流程，包括备份、恢复的解决方案。掌握这些技能将帮助您更有效地管理和维护基于 Docker 的 MongoDB 数据库，确保业务的连续性和数据的安全性。</p><p>记住，在进行任何数据库操作之前，确保你有完整的备份，并在测试环境中验证操作流程，这样才能最大限度地减少生产环境中的风险。</p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Docker" scheme="https://tamsiree.com/categories/Docker/"/>
    
    <category term="MongoDB" scheme="https://tamsiree.com/categories/Docker/MongoDB/"/>
    
    
    <category term="Docker" scheme="https://tamsiree.com/tags/Docker/"/>
    
    <category term="MongoDB" scheme="https://tamsiree.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Unity 多线程渲染导致部分手机崩溃</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%B4%A9%E6%BA%83/</id>
    <published>2023-11-09T11:55:51.000Z</published>
    <updated>2025-11-11T13:46:01.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>测试环境：</p><p>Unity2021.3.24f1</p><p><img src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20231109-200048.jpg"></p><p>崩溃堆栈 Logcat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"> E  *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  Version &#x27;2021.3.24f1 (cf10dcf7010d)&#x27;, Build type &#x27;Release&#x27;, Scripting Backend &#x27;il2cpp&#x27;, CPU &#x27;arm64-v8a&#x27;</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  Build fingerprint: &#x27;Xiaomi/grus/grus:11/RKQ1.200826.002/V12.5.4.0.RFBCNXM:user/release-keys&#x27;</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  Revision: &#x27;0&#x27;</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  ABI: &#x27;arm64&#x27;</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  Timestamp: 2023-11-09 20:12:11+0800</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  pid: 30483, tid: 30516, name: UnityMain  &gt;&gt;&gt; com.xxxx.yyyy &lt;&lt;&lt;</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  uid: 10319</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  Cause: null pointer dereference</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x0  0000007e82509ce8  x1  0000007e807c22b8  x2  0000000000000000  x3  0000000000000000</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x4  0000007cf9c064e0  x5  0000007e807c22f8  x6  0000007e8250ad20  x7  0000007cf9c00f80</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x8  0000007e5046aea8  x9  0000000000000000  x10 0000000000000000  x11 0000000000000001</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x12 0000007ee4981e0e  x13 0000000000000001  x14 0000007e811dc0c4  x15 0000000100000000</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x16 0000007e823af210  x17 0000007f7b8b6aa4  x18 0000007e310eb5c8  x19 0000007e807c2210</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x20 0000007e82509cc8  x21 0000000000003fe1  x22 0000007ee49d7b80  x23 0000000000000021</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x24 000000000001ffff  x25 0000000000000013  x26 ffffffffffffffff  x27 aaaaaaaaaaaaaaab</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      x28 0000000000000030  x29 0000000000000001</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E      sp  0000007e807c2160  lr  0000007e80d85814  pc  0000007e80dd354c</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E  backtrace:</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #00 pc 000000000060a54c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #01 pc 00000000005bc810  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #02 pc 00000000005bc6b4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #03 pc 00000000005ae29c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #04 pc 0000000000609e20  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #05 pc 0000000000609b58  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #06 pc 0000000000609a60  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #07 pc 0000000000574d88  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #08 pc 00000000005ab45c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #09 pc 00000000005a927c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #10 pc 00000000005c3a4c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #11 pc 00000000005c3a7c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #12 pc 00000000005f5098  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #13 pc 00000000005f4f00  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #14 pc 00000000011562cc  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #15 pc 000000000058ec1c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #16 pc 000000000058ea90  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #17 pc 00000000002c6b44  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #18 pc 000000000031bcec  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #19 pc 0000000000321158  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #20 pc 0000000000320dcc  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.697 30483-30516 CRASH                   com.xxxx.yyyy                  E        #21 pc 00000000003213a4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #22 pc 00000000003215d4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #23 pc 000000000032181c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #24 pc 00000000004381a8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #25 pc 00000000004380c4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #26 pc 0000000000430308  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #27 pc 000000000010b130  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #28 pc 00000000009983a8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #29 pc 00000000009baeb4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #30 pc 000000000072597c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #31 pc 000000000073cff0  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #32 pc 0000000000884084  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #33 pc 0000000000883f88  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #34 pc 00000000009adb88  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #35 pc 00000000009ade18  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #36 pc 0000000000764a24  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #37 pc 0000000000764368  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #38 pc 0000000000700520  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #39 pc 0000000000d7a884  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #40 pc 000000000073ddf4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #41 pc 000000000073dcc4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #42 pc 0000000000d7ab30  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #43 pc 0000000000d7a884  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #44 pc 000000000074f6b0  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.698 30483-30516 CRASH                   com.xxxx.yyyy                  E        #45 pc 00000000007dbb74  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #46 pc 00000000007dd164  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #47 pc 00000000007c19c4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #48 pc 00000000007c1250  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #49 pc 00000000007c105c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #50 pc 00000000007c4788  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #51 pc 000000000058ec1c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #52 pc 000000000058ea90  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #53 pc 00000000002c6918  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #54 pc 00000000002d45dc  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #55 pc 00000000002e1f10  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #56 pc 0000000000168100  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #57 pc 0000000000206970  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #58 pc 00000000002069b0  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #59 pc 0000000000206be8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #60 pc 000000000034ee48  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.699 30483-30516 CRASH                   com.xxxx.yyyy                  E        #61 pc 00000000003650f8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #62 pc 000000000013ced4  /apex/com.android.art/lib64/libart.so (art_quick_generic_jni_trampoline+148) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #63 pc 0000000000133564  /apex/com.android.art/lib64/libart.so (art_quick_invoke_stub+548) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #64 pc 0000000000197e94  /apex/com.android.art/lib64/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+204) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #65 pc 0000000000305328  /apex/com.android.art/lib64/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+376) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #66 pc 0000000000300440  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+884) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #67 pc 0000000000635e20  /apex/com.android.art/lib64/libart.so (MterpInvokeDirect+592) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #68 pc 000000000012d914  /apex/com.android.art/lib64/libart.so (mterp_op_invoke_direct+20) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #69 pc 00000000006368bc  /apex/com.android.art/lib64/libart.so (MterpInvokeStatic+1120) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #70 pc 000000000012d994  /apex/com.android.art/lib64/libart.so (mterp_op_invoke_static+20) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #71 pc 00000000006354c8  /apex/com.android.art/lib64/libart.so (MterpInvokeInterface+1840) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #72 pc 000000000012da14  /apex/com.android.art/lib64/libart.so (mterp_op_invoke_interface+20) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #73 pc 0000000000633b34  /apex/com.android.art/lib64/libart.so (MterpInvokeVirtual+1440) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #74 pc 000000000012d814  /apex/com.android.art/lib64/libart.so (mterp_op_invoke_virtual+20) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #75 pc 00000000006368bc  /apex/com.android.art/lib64/libart.so (MterpInvokeStatic+1120) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.700 30483-30516 CRASH                   com.xxxx.yyyy                  E        #76 pc 000000000012d994  /apex/com.android.art/lib64/libart.so (mterp_op_invoke_static+20) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #77 pc 00000000002f7e1c  /apex/com.android.art/lib64/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame&amp;, art::JValue, bool, bool) (.llvm.3736212632490021415)+268) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #78 pc 000000000062250c  /apex/com.android.art/lib64/libart.so (artQuickToInterpreterBridge+796) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #79 pc 000000000013cff8  /apex/com.android.art/lib64/libart.so (art_quick_to_interpreter_bridge+88) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #80 pc 0000000000133564  /apex/com.android.art/lib64/libart.so (art_quick_invoke_stub+548) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #81 pc 0000000000197e94  /apex/com.android.art/lib64/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+204) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #82 pc 000000000052aefc  /apex/com.android.art/lib64/libart.so (art::(anonymous namespace)::InvokeWithArgArray(art::ScopedObjectAccessAlreadyRunnable const&amp;, art::ArtMethod*, art::(anonymous namespace)::ArgArray*, art::JValue*, char const*)+104) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #83 pc 000000000052c0fc  /apex/com.android.art/lib64/libart.so (art::JValue art::InvokeVirtualOrInterfaceWithJValues&lt;art::ArtMethod*&gt;(art::ScopedObjectAccessAlreadyRunnable const&amp;, _jobject*, art::ArtMethod*, jvalue const*)+440) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.702 30483-30516 CRASH                   com.xxxx.yyyy                  E        #84 pc 0000000000579474  /apex/com.android.art/lib64/libart.so (art::Thread::CreateCallback(void*)+1272) (BuildId: 18756d0085f48483aa21a8893ef770c4)</span><br><span class="line">2023-11-09 20:12:11.703 30483-30516 CRASH                   com.xxxx.yyyy                  E        #85 pc 00000000000f4204  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+64) (BuildId: c8c0e7a907b8f5c93a00f9f8ca41ddef)</span><br><span class="line">2023-11-09 20:12:11.703 30483-30516 CRASH                   com.xxxx.yyyy                  E        #86 pc 000000000008ec64  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64) (BuildId: c8c0e7a907b8f5c93a00f9f8ca41ddef)</span><br><span class="line">2023-11-09 20:12:12.129 30483-30516 CRASH                   com.xxxx.yyyy                  E  Tombstone written to: /storage/emulated/0/Android/data/com.xxxx.yyyy/files/tombstone_00</span><br><span class="line">2023-11-09 20:12:12.129 30483-30516 CRASH                   com.xxxx.yyyy                  E  Forwarding signal 11</span><br><span class="line">2023-11-09 20:12:12.277 30483-30627 AudioTrack              com.xxxx.yyyy                  I  isLongTimeZoreData zoer date time 12 Seconds</span><br><span class="line">--------- beginning of crash</span><br><span class="line">2023-11-09 20:12:12.281 30483-30516 libc                    com.xxxx.yyyy                  A  Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0 in tid 30516 (UnityMain), pid 30483 (swhite.quiztrip)</span><br><span class="line">2023-11-09 20:12:12.673 30745-30745 DEBUG                   pid-30745                            A  pid: 30483, tid: 30516, name: UnityMain  &gt;&gt;&gt; com.xxxx.yyyy &lt;&lt;&lt;</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #00 pc 000000000060a54c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #01 pc 00000000005bc810  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #02 pc 00000000005bc6b4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #03 pc 00000000005ae29c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #04 pc 0000000000609e20  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #05 pc 0000000000609b58  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #06 pc 0000000000609a60  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #07 pc 0000000000574d88  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #08 pc 00000000005ab45c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #09 pc 00000000005a927c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #10 pc 00000000005c3a4c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #11 pc 00000000005c3a7c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #12 pc 00000000005f5098  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #13 pc 00000000005f4f00  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #14 pc 00000000011562cc  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #15 pc 000000000058ec1c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #16 pc 000000000058ea90  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #17 pc 00000000002c6b44  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #18 pc 000000000031bcec  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #19 pc 0000000000321158  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.822 30745-30745 DEBUG                   pid-30745                            A        #20 pc 0000000000320dcc  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #21 pc 00000000003213a4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #22 pc 00000000003215d4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #23 pc 000000000032181c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #24 pc 00000000004381a8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #25 pc 00000000004380c4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #26 pc 0000000000430308  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #27 pc 000000000010b130  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #28 pc 00000000009983a8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #29 pc 00000000009baeb4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #30 pc 000000000072597c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #31 pc 000000000073cff0  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #32 pc 0000000000884084  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #33 pc 0000000000883f88  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #34 pc 00000000009adb88  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #35 pc 00000000009ade18  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #36 pc 0000000000764a24  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #37 pc 0000000000764368  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #38 pc 0000000000700520  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #39 pc 0000000000d7a884  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #40 pc 000000000073ddf4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #41 pc 000000000073dcc4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #42 pc 0000000000d7ab30  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #43 pc 0000000000d7a884  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #44 pc 000000000074f6b0  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #45 pc 00000000007dbb74  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #46 pc 00000000007dd164  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #47 pc 00000000007c19c4  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #48 pc 00000000007c1250  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #49 pc 00000000007c105c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #50 pc 00000000007c4788  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #51 pc 000000000058ec1c  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #52 pc 000000000058ea90  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libil2cpp.so (BuildId: 88d66738f9ae086983cd014ddbb83cece5dda9c1)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #53 pc 00000000002c6918  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #54 pc 00000000002d45dc  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #55 pc 00000000002e1f10  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #56 pc 0000000000168100  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #57 pc 0000000000206970  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #58 pc 00000000002069b0  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #59 pc 0000000000206be8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #60 pc 000000000034ee48  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #61 pc 00000000003650f8  /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/lib/arm64/libunity.so (BuildId: 82902cec7920793316b11248c1a270f30ff02a44)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #69 pc 000000000075a024  [anon:dalvik-classes2.dex extracted in memory from /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/base.apk!classes2.dex] (com.unity3d.player.UnityPlayer.access$500)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #72 pc 0000000000759374  [anon:dalvik-classes2.dex extracted in memory from /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/base.apk!classes2.dex] (com.unity3d.player.UnityPlayer$e$1.handleMessage+252)</span><br><span class="line">2023-11-09 20:12:12.823 30745-30745 DEBUG                   pid-30745                            A        #81 pc 0000000000759708  [anon:dalvik-classes2.dex extracted in memory from /data/app/~~e8pDeCv26ER0pRgDUraXJA==/com.xxxx.yyyy-UFCgVjFN3TJ6sfIySXL9lQ==/base.apk!classes2.dex] (com.unity3d.player.UnityPlayer$e.run+40)</span><br><span class="line">---------------------------- PROCESS STARTED (30747) for package com.xxxx.yyyy ----------------------------</span><br></pre></td></tr></table></figure><p>arm64 + 开启多线程渲染 游戏会崩溃会卡死<br>arm64 + 关闭多线程渲染 游戏不会崩溃很稳定</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>解决方案：<br>第一种：关闭多线程渲染<br>第二种：升级 Unity 版本</p><hr><blockquote><p>相关资料<br><a href="https://answer.uwa4d.com/question/5f1668490314525f3f1dd866">https://answer.uwa4d.com/question/5f1668490314525f3f1dd866</a><br><a href="https://answer.uwa4d.com/question/62b02ad09b935a01f583ac56">https://answer.uwa4d.com/question/62b02ad09b935a01f583ac56</a></p></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>好用的 CDN 之 jsDelivr</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84CDN%E4%B9%8BjsDelivr/</id>
    <published>2023-10-16T07:00:56.000Z</published>
    <updated>2025-11-05T13:53:39.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。——百度百科</p><p>由于某些原因，很多公用免费的 CDN 资源在中国大陆并不很好用，就算是付费的，也有一定的限制，例如每天的刷新次数有限之类的。那有没有一款造福人类的，或者造福中国大陆的公用 CDN 呢？</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="jsDelivr"><a href="#jsDelivr" class="headerlink" title="jsDelivr"></a>jsDelivr</h2><p>先看看官方的介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/1365470-20200119104921111-1131459704.png"></p><p>这是在中国大陆唯一有 license 的公有 CDN，而且实际使用中的访问速度也是极快的（虽然官网打开速度慢</p><h2 id="与-Github、NPM、WorldPress-整合"><a href="#与-Github、NPM、WorldPress-整合" class="headerlink" title="与 Github、NPM、WorldPress 整合"></a>与 Github、NPM、WorldPress 整合</h2><p>官网地址：<a href="https://liubing.me/goto/https://www.jsdelivr.com">https://www.jsdelivr.com</a> 没梯子访问可能有点慢，不过 CDN 的节点是很快的 可以引用的资源包括 NPM、github、wordpress 的所有资源，github 可以是任意体积小于 50M 的仓库。</p><p>以 github 为例，只需要通过符合 JSDelivr 规则的 URL 引用，即可直接使用 Github 中的资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 用户名 / 仓库名 @版本号 / 文件名 </span><br><span class="line">https://cdn.jsdelivr.net/gh/user/repo@version/file</span><br><span class="line">// load jQuery v3.2.1</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</span><br><span class="line"></span><br><span class="line">// 使用一个范围内的版本 </span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</span><br><span class="line"></span><br><span class="line">// 忽略版本号则默认使用最新版 </span><br><span class="line">// you should NOT use this in production</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在任意 JS/CSS 文件后添加 .min 能得到一个缩小版 </span><br><span class="line">// 如果它本身不存在，我们将会为你生成 </span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</span><br><span class="line"></span><br><span class="line">// 在末尾加 / 则得到目录列表 </span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery/</span><br></pre></td></tr></table></figure><p>详细规则参考官网：<a href="https://www.jsdelivr.com/">https://www.jsdelivr.com/</a></p><p>以我一张图片为例：<br>原 github 链接：<a href="https://raw.githubusercontent.com/Tamsiree/Assets/master/DeskTop/4e0f6b142732b595eacf1be7b549e1f0.jpg">https://raw.githubusercontent.com/Tamsiree/Assets/master/DeskTop/4e0f6b142732b595eacf1be7b549e1f0.jpg</a></p><p>CDN 后的链接：<a href="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/4e0f6b142732b595eacf1be7b549e1f0.jpg">https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/DeskTop/4e0f6b142732b595eacf1be7b549e1f0.jpg</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了 <code>jsdelivr</code>， 推荐几个免费的且不限流量的 CDN，还有 <code>staticaly</code> <code>githack</code> 都是全球通用的，</p><h3 id="staticaly"><a href="#staticaly" class="headerlink" title="staticaly"></a>staticaly</h3><p>官网地址：<a href="https://www.staticaly.com/">https://www.staticaly.com</a><br>轻松地从 GitHub / GitLab / Bitbucket 等加载您的项目 没有流量限制或限制。</p><p>文件通过超快速全球 CDN 提供。 在 URL（不是分支）中使用特定标记或提交哈希。<br>根据 URL 永久缓存文件。 除 master 分支外，文件在浏览器中缓存 1 年。 具体用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># GitHub CDN</span><br><span class="line">https://cdn.staticaly.com/gh/:user/:repo/:tag/:file</span><br><span class="line">https://cdn.staticaly.com/gh/growvv/growvv.github.io/master/README.md</span><br><span class="line"></span><br><span class="line"># GitLab CDN</span><br><span class="line">https://cdn.staticaly.com/gl/:user/:repo/:tag/:file</span><br><span class="line"></span><br><span class="line"># Bitbucket CDN</span><br><span class="line">https://cdn.staticaly.com/bb/:user/:repo/:tag/:file</span><br><span class="line"></span><br><span class="line"># WordPress CDN</span><br><span class="line">https://cdn.staticaly.com/wp/c/:version/wp-includes/:file  </span><br><span class="line">https://cdn.staticaly.com/wp/p/:plugin\_name/:version/:file  </span><br><span class="line">https://cdn.staticaly.com/wp/t/:theme\_name/:version/:file</span><br><span class="line"></span><br><span class="line"># Imgpx CDN</span><br><span class="line">https://cdn.staticaly.com/img/:image\_url</span><br><span class="line"></span><br><span class="line"># Favicons CDN</span><br><span class="line">https://cdn.staticaly.com/favicons/:favicon\_url</span><br></pre></td></tr></table></figure><h3 id="githack"><a href="#githack" class="headerlink" title="githack"></a>githack</h3><p>直接从 GitHub，Bitbucket 或 GitLab 提供原始文件<br>官网地址：<a href="http://raw.githack.com/">http://raw.githack.com/</a> 具体用法和上面的 <code>staticaly</code> 很类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Github CDN</span><br><span class="line">// 主分支 </span><br><span class="line">https://rawcdn.githack.com/liub1934/LB-Blog/master/wp-content/themes/Memory/emoji/xiaodianshi/baiyan.png</span><br><span class="line"></span><br><span class="line">// 版本分支 </span><br><span class="line">https://rawcdn.githack.com/liub1934/LB-Blog/8806f440d3f9a7cc3e6125d7d75564e40262c6a8/wp-content/themes/Memory/emoji/xiaodianshi/baiyan.png</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/lfri/p/12212878.html">快速免费的公用 CDN —— jsDelivr</a></li><li><a href="https://segmentfault.com/a/1190000020239193">很好用的免费公用 CDN 资源 JSDelivr</a></li><li><a href="https://blog.csdn.net/qq_36759224/article/details/86936453">免费 CDN：jsDelivr+Github 使用方法</a></li><li><a href="https://liubing.me/recommend-several-free-unlimited-cdns.html">推荐几款免费且不限流量的全球 CDN</a></li><li><a href="https://fileem.com/jsdelivr-free-public-cdn-acceleration-service">https://fileem.com/jsdelivr-free-public-cdn-acceleration-service</a></li></ul></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity 坐标系统</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-10-14T06:11:46.000Z</published>
    <updated>2025-11-05T13:53:39.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文会详细介绍三维软件中 7 种坐标的特点与关系，还有在脚本编辑和 shader 系统中的使用方法后续更新</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="不同空间中坐标的转换方法"><a href="#不同空间中坐标的转换方法" class="headerlink" title="不同空间中坐标的转换方法"></a><a href="https://blog.csdn.net/lengyoumo/article/details/104091416">不同空间中坐标的转换方法</a></h2><h2 id="七种坐标系简介"><a href="#七种坐标系简介" class="headerlink" title="七种坐标系简介"></a>七种坐标系简介</h2><blockquote><p>unity 使用的是左手坐标系，即：<br>↑=Y，↓=-Y，前 = Z，后 =-Z，←=-X，→=X。<br>总共有七种坐标系，分别是模型坐标、世界坐标、观察坐标、裁剪坐标、屏幕坐标、ui 坐标，uv 坐标这七种坐标会按照一定顺序转换在程序中运行，实际上这就是模型从计算到在屏幕上显示的过程。</p></blockquote><h3 id="一-模型坐标"><a href="#一-模型坐标" class="headerlink" title="一 模型坐标"></a>一 模型坐标</h3><blockquote><p>Local Space (模型坐标)：就是一个模型自己的坐标，如果该模型下有子模型，则子模型也拥有自己的模型坐标，多个子模型在父模型下共享父坐标。<br>坐标：<br>模型原点为（0,0）<br>需要说明的是一个模型坐标的原点位置在创建模型的时候就定义好了。如果需要更改只能在 blender 或 3dmax 等建模软件中设定。unity 是不能设置模型坐标原点的。<br>获取方式：<br>在 unity 脚本中：<br>transform.localPosition<br>在 unity shader 中：<br>顶点着色器默认输入的就是模型坐标</p></blockquote><h3 id="二-世界坐标"><a href="#二-世界坐标" class="headerlink" title="二 世界坐标"></a>二 世界坐标</h3><blockquote><p>World Space（世界坐标）：场景中的一切物体，包括模型，灯具，相机都共享一个绝对位置，这就是世界坐标。所有在模型坐标中的变化最终都会映射到世界坐标中。<br>坐标：<br>世界的中心点：0,0<br>获取方式：<br>在 unity 脚本中：<br>使用 transform.position 可以获得该位置坐标。<br>在 unity shader 中：<br>需要 将模型坐标转换为世界坐标才能获得。</p></blockquote><h3 id="三-观察坐标（视口坐标）"><a href="#三-观察坐标（视口坐标）" class="headerlink" title="三 观察坐标（视口坐标）"></a>三 观察坐标（视口坐标）</h3><blockquote><p>ViewPort Space （观察坐标）：每个相机都是一个观察者，每个观察者都有自己的视界。<br>到这一步，会把世界坐标转换为以摄像机为参考的原点和方向。<br>坐标：<br>左下角为（0，0）<br>右上角为（1，1）<br>Z 的位置是以相机的世界单位来衡量的。<br>获取方式：</p></blockquote><h3 id="四-裁剪坐标"><a href="#四-裁剪坐标" class="headerlink" title="四 裁剪坐标"></a>四 裁剪坐标</h3><blockquote><p>Clip Space (裁剪坐标)：裁剪坐标是将观察世界的一部分截取出来。摄像机在取景的时候使用一个六面体去处理可视的区域，所有在这个区域的物体才会被显示。那么你肯定会有以为，为什么不直接用观察坐标，为什么一定要用这个裁剪呢？ 首先，相机有两种模式，即透视相机与正交镜头（没有近大远小的透视效果）。这两种模式的切换会在裁剪坐标中处理。其次裁剪坐标规定了那些模型计算后可以显示，那些模型计算后但不用显示。所以必须有这个步骤。</p></blockquote><h3 id="五-屏幕坐标"><a href="#五-屏幕坐标" class="headerlink" title="五 屏幕坐标"></a>五 屏幕坐标</h3><blockquote><p>Screen Space（屏幕坐标）: 屏幕坐标用于将裁剪坐标中的物体信息映射到屏幕上。我们知道三维世界是立体的，但不管是几维世界，只要实在屏幕上显示的就一定是 2d 的。<br>坐标：<br>左下角为（0，0）点<br>右上角为（Screen.width，Screen.height）<br>获取方式：<br>Z 的位置是以相机的世界单位来衡量的。<br>　　Screen.width = Camera.pixelWidth<br>　　Screen.height = Camera.pixelHeigth</p></blockquote><h3 id="六-ui-坐标"><a href="#六-ui-坐标" class="headerlink" title="六 ui 坐标"></a>六 ui 坐标</h3><blockquote><p>ui 坐标是特殊的坐标系统，专门用于处理 ui 组件。ui 坐标系是可视化窗口的最顶层，世界坐标系的物体都会被 ui 坐标系遮挡。<br>坐标：<br>左下角为（0，0）点<br>右上角为（Screen.width，Screen.height）<br>Z 轴影响显示层级位置<br>获取方式：</p></blockquote><h3 id="七-uv-坐标"><a href="#七-uv-坐标" class="headerlink" title="七 uv 坐标"></a>七 uv 坐标</h3><blockquote><p>相比之前的六种坐标系，uv 坐标系只负责定位贴图和模型的关系<br>坐标：<br>左下角为（0，0）<br>右上角为（1，1）<br>获取方式：</p></blockquote><h2 id="【坐标系的转换】"><a href="#【坐标系的转换】" class="headerlink" title="【坐标系的转换】"></a>【坐标系的转换】</h2><h3 id="1、世界坐标→屏幕坐标："><a href="#1、世界坐标→屏幕坐标：" class="headerlink" title="1、世界坐标→屏幕坐标："></a>1、世界坐标→屏幕坐标：</h3><p>camera.WorldToScreenPoint(transform.position); 这样可以将世界坐标转换为屏幕坐标。其中 camera 为场景中的 camera 对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Follow_2d3d</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject f2d;</span><br><span class="line">    <span class="keyword">public</span> GameObject f3d;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos_3d = f3d.transform.localPosition;</span><br><span class="line">        Vector3 screen_point = gameObject.GetComponent&lt;Camera&gt;().WorldToScreenPoint(pos_3d);</span><br><span class="line">        f2d.transform.position = screen_point;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码实现效果：ui 中的 2d 元素会与三维物体重合，移动三维物体，2d 元素会跟着移动</p><h3 id="2、屏幕坐标→视口坐标："><a href="#2、屏幕坐标→视口坐标：" class="headerlink" title="2、屏幕坐标→视口坐标："></a>2、屏幕坐标→视口坐标：</h3><p>camera.ScreenToViewportPoint(Input.GetTouch(0).position); 这样可以将屏幕坐标转换为视口坐标。其中 camera 为场景中的 camera 对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Follow_2d3d</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject f2d;</span><br><span class="line">    <span class="keyword">public</span> GameObject f3d;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos_2d = f2d.transform.position;</span><br><span class="line">        Vector3 world_point = gameObject.GetComponent&lt;Camera&gt;().ScreenToWorldPoint(pos_2d);</span><br><span class="line">        f3d.transform.position = world_point;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码实现效果：ui 中的 2d 元素会与三维物体重合，移动 2d 元素，三维物体会跟着移动</p><h3 id="3、视口坐标→屏幕坐标："><a href="#3、视口坐标→屏幕坐标：" class="headerlink" title="3、视口坐标→屏幕坐标："></a>3、视口坐标→屏幕坐标：</h3><p>camera.ViewportToScreenPoint();</p><h3 id="4、视口坐标→世界坐标："><a href="#4、视口坐标→世界坐标：" class="headerlink" title="4、视口坐标→世界坐标："></a>4、视口坐标→世界坐标：</h3><p>camera.ViewportToWorldPoint();<br>鼠标拖拽 ui，不能直接使用 position 赋值。需要通过相机转换。</p><hr><blockquote><p>参考链接：<a href="https://blog.csdn.net/lengyoumo/article/details/80772323">[ unity 七种坐标系统详解与互相转换的方法 模型坐标、世界坐标、观察坐标（视口坐标）、裁剪坐标、屏幕坐标、ui 坐标、uv 坐标 ]</a></p></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
    <summary type="html">[ unity 七种坐标系统详解与互相转换的方法 模型坐标、世界坐标、观察坐标（视口坐标）、裁剪坐标、屏幕坐标、ui坐标、uv坐标 ]</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity 的 ShaderLab 着色器入门</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E7%9A%84ShaderLab%E7%9D%80%E8%89%B2%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E7%9A%84ShaderLab%E7%9D%80%E8%89%B2%E5%99%A8%E5%85%A5%E9%97%A8/</id>
    <published>2023-10-12T10:18:23.000Z</published>
    <updated>2025-11-05T13:53:39.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你对 cg glsl hlsl 顶点 <a href="https://so.csdn.net/so/search?q=%E7%9D%80%E8%89%B2%E5%99%A8&spm=1001.2101.3001.7020">着色器</a> 片段着色器 表面着色器 固定渲染管线 等等有所疑惑，或是想学会 unity 的渲染，看这一篇就足够了。另外我博客的 shader 分类中还有很多 shader 教程和源码，每篇源码都有实现思路、语法功能注释，还在不断更新添加中。感兴趣的请自行查看</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="让-vs-支持-shader"><a href="#让-vs-支持-shader" class="headerlink" title="让 vs 支持 shader"></a>让 vs 支持 <a href="https://so.csdn.net/so/search?q=shader&spm=1001.2101.3001.7020">shader</a></h2><p>点击 vs 的工具 &gt; 扩展和更新 &gt; 联机 &gt; visual studio marketplace<br>搜素 shader<br>点击下载<br>重启 vs<br>弹出 installer，点击修改 即可。</p><h2 id="一，基础知识"><a href="#一，基础知识" class="headerlink" title="一，基础知识"></a>一，基础知识</h2><h3 id="关于着色器语言与-Shader-Lab"><a href="#关于着色器语言与-Shader-Lab" class="headerlink" title="关于着色器语言与 Shader Lab"></a>关于着色器语言与 Shader Lab</h3><blockquote><p>着色器语言有三种：<br><em>hlsl（DirectX）</em><br><em>glsl（OpenGL）</em><br><em>cg（支持以上两种）</em><br>Shader Lab 是 unity 封装了 cg、hlsl、glsl 的 unity 专有着色器语言。shaderlab 具有跨平台、图形化编程、便于着色器与 unity 通信等优点。在 unity2018.3.5f 以后版本，可以使用图形化工具 shader graph 来大幅缩减 shader 编程成本，使这个令人头疼的语言走入寻常百姓家。。。。。但作为一个 unityer 最好具有基本的 Shader Lab 编程能力，至少了解基本效果的代码实现过程。</p></blockquote><h3 id="mesh、材质、着色器的与模型的关系"><a href="#mesh、材质、着色器的与模型的关系" class="headerlink" title="mesh、材质、着色器的与模型的关系"></a>mesh、材质、着色器的与模型的关系</h3><blockquote><p>把模型比作一只兔子，那 mesh 就是兔子的骨架，顶点就是骨架的端点，片段就是由顶点组成的面，材质就是皮肉用来装饰片段的，shader 就是用来控制如何显示材质的。</p></blockquote><h3 id="关于顶点、片段处理器"><a href="#关于顶点、片段处理器" class="headerlink" title="关于顶点、片段处理器"></a>关于顶点、片段处理器</h3><blockquote><p>顶点着色器和片段着色器都有自己独立的硬件处理单元。该硬件处理单元拥有非常强大的并行运算能力，非常擅长矩阵计算，片段处理器还可以告诉查询纹理信息。</p></blockquote><p>白话：顶点着色器负责定位像素位置！片段着色器负责修改像素颜色！！</p><blockquote><p>顶点着色程序与片断着色程序通常是同时存在，相互配合，前者的输出作为后者的输入。不过，也可以只有顶点着色程序。如果只有顶点着色程序，那么只对输入的顶点进行操作，而顶点内部的点则按照硬件默认的方式自动插值。例如，输入一个三角面片，顶点着色程序对其进行 phong 光照计算，只计算三个顶点的光照颜色，而三角面片内部点的颜色按照硬件默认的算法（Gourand 明暗处理或者快速 phong 明暗处理）进行插值，如果图形硬件比较先进，默认的处理算法较好（快速 phong 明暗处理），则效果也会较好；如果图形硬件使用 Gourand 明暗处理算法，则会出现马赫带效应（条带化）。<br>而片断着色程序是对每个片断进行独立的颜色计算，并且算法由自己编写，不但可控性好，而且可以达到更好的效果。<br>由于 GPU 对数据进行并行处理，所以每个数据都会执行一次 shader 程序程序。即，每个顶点数据都会执行一次顶点程序；每个片段都会执行一次片段程序。<br>片段就是所有三维顶点在光栅化之后的数据集合，这些数据没有经过深度值比较，而屏幕显示的像素是经过深度比较的。</p></blockquote><h3 id="顶点着色器、片段着色器与表面着色器的关系"><a href="#顶点着色器、片段着色器与表面着色器的关系" class="headerlink" title="顶点着色器、片段着色器与表面着色器的关系"></a>顶点着色器、片段着色器与表面着色器的关系</h3><p>作用</p><blockquote><p>顶点着色器负责顶点坐标变换，片段着色器负责像素的颜色计算。顶点着色器计算好坐标信息后传入片段着色器计算颜色。所以顶点着色器和片段着色器是合作关系。<br>表面着色器是封装了顶点和片段着色器的新 api。与他们属于上下层关系。<br>shader 编译时会将表面渲染代码编译成多个 pass 代码块，再分解成顶点 / 片元着色器。</p></blockquote><p>区别</p><blockquote><p>顶点着色器用于处理顶点。片段着色器用于处理面。<br>表面着色器是对顶点着色器与片段着色器的进一步封装。<br>即是说，表面着色器有一套即成的处理办法，不用去搞那些细节。<br>而顶点着色器和片段着色器更接近底层，可以处理一些细节问题。</p></blockquote><h3 id="着色器的工作流程"><a href="#着色器的工作流程" class="headerlink" title="着色器的工作流程"></a>着色器的工作流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/A20231014154645.png" alt="着色器的工作流程"></p><h2 id="二，Shader-Lab-语法"><a href="#二，Shader-Lab-语法" class="headerlink" title="二，Shader Lab 语法"></a>二，Shader Lab 语法</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;path/name&quot; &#123;</span><br><span class="line"> Properties&#123;</span><br><span class="line"> //_CG 变量名 (&quot;unity 可见的变量名 & quot;, 属性类型) = 值 </span><br><span class="line"> _Color (&quot;My Color&quot;, Color) = (1, 1, 1, .5) </span><br><span class="line">  &#125; </span><br><span class="line">  Subshader&#123;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><ul><li>  path/name ：unity 编辑器中检索的位置和 shader 名。shader 名尽量与 shader 文件名一样。</li><li>  Properties：shader 属性，用于 cg 与 unity 通信。</li><li>  Subshader：shader 解决方案。每个 shader 程序包含至少一个 subshader，用于解决硬件性能兼容问题。shader 的主代码部分都写在这里</li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><em>Properties</em></h3><blockquote><p>属性的结构：_CG 变量名 (“unity 可见的变量名”, 属性类型) = 值<br>例：_Color (“My Color”, Color) = (1, 1, 1, .5)</p></blockquote><p>属性类型表</p><table><thead><tr><th>类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Int</td><td>整型</td><td>(.1, 2)</td></tr><tr><td>Float</td><td>浮点数</td><td>.5</td></tr><tr><td>Vector</td><td>四维向量</td><td>(.5, 1 , 1, 0.5)</td></tr><tr><td>Range</td><td>范围 1-2.3 的浮点数</td><td>(1, 2.3)</td></tr><tr><td>Color</td><td>RGBA 颜色</td><td>(1,1,1,.5)</td></tr><tr><td>2D</td><td>2d 贴图, 2d 纹理，默认值可以为一个代表默认 tint 颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump” 中的一个</td><td>”white”{}</td></tr><tr><td>3D</td><td>3d 贴图</td><td></td></tr><tr><td>Cube</td><td>6 面立方贴图</td><td>”white”{}</td></tr><tr><td>Rect</td><td>矩形贴图</td><td>”white”{}</td></tr></tbody></table><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a><em>SubShader</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123; </span><br><span class="line">Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &quot;ForceNoShadowCasting&quot; = &quot;True&quot; &quot;IgnoreProjector&quot; = &quot;True&quot;&#125;   </span><br><span class="line">LOD 100</span><br><span class="line"> Pass&#123;</span><br><span class="line"> Fog&#123;Mode OFF&#125;</span><br><span class="line"> </span><br><span class="line"> // 固定渲染器 </span><br><span class="line">Material&#123;</span><br><span class="line">               Diffuse[_Color]  // 设置漫反射 </span><br><span class="line">       &#125;      </span><br><span class="line">            Lighting On</span><br><span class="line">        SeparateSpecular On   // 启用高光颜色 </span><br><span class="line">            // 设置纹理 </span><br><span class="line">            SetTexture[_MainTex]&#123;</span><br><span class="line"> // 表面渲染器 </span><br><span class="line"> #pragma surface surf Lambert</span><br><span class="line"> // 顶点渲染器 </span><br><span class="line">#pragma vertexvert</span><br><span class="line">// 片段渲染器 </span><br><span class="line"> #pragma fragment frag</span><br><span class="line"> &#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a><em>Tags</em></h3><p>tags 可以填写多个命令，可以控制渲染时机。可以通过在 unity 的 asset 窗口中点击 shader 查看 tags 生效情况。</p><table><thead><tr><th>标签</th><th>说明</th><th>值</th></tr></thead><tbody><tr><td>“RenderType”=“Opaque”</td><td>系统在渲染不透明物体时调用该 shader</td><td></td></tr><tr><td>“RenderType” = “Transparent”</td><td>系统在渲染透明物体时调用该 shader，绝大部分透明的物体、包括粒子特效都使用这个</td><td></td></tr><tr><td>“RenderType” = “Background”</td><td>系统渲染背景时调用，天空盒都使用这个</td><td></td></tr><tr><td>“RenderType” = “Overlay”</td><td>系统渲染 gui 镜头时调用，GUI、镜头光晕都使用这个</td><td></td></tr><tr><td>“IgnoreProjector”=“True”</td><td>忽略 Projectors</td><td></td></tr><tr><td>“ForceNoShadowCasting”=“True”</td><td>不生成阴影</td><td></td></tr><tr><td>“Queue”=“xxx”</td><td>指定渲染队列顺序，下面有详细说明</td><td></td></tr></tbody></table><p>Queue 的说明</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Background</td><td>最先调用的，用来渲染天空盒或背景</td></tr><tr><td>Geometry</td><td>默认值，用来渲染非透明物体（一般情况下，场景中的绝大多数物体应该是非透明的）</td></tr><tr><td>AlphaTest</td><td>用来渲染经过 Alpha Test 的像素，单独为 AlphaTest 设定一个 Queue 是出于对效率的考虑</td></tr><tr><td>Transparent</td><td>以从后往前的顺序渲染透明物体</td></tr><tr><td>Overlay</td><td>用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）</td></tr></tbody></table><blockquote><p>这些预定义的值本质上是一组定义整数，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后 Overlay = 4000。在我们实际设置 Queue 值时，不仅能使用上面的几个预定义值，我们也可以指定自己的 Queue 值，写成类似这样：“Queue”=“Transparent+100”，表示一个在 Transparent 之后 100 的 Queue 上进行调用。通过调整 Queue 值，我们可以确保某些物体一定在另一些物体之前或者之后渲染，这个技巧有时候很有用处。(比如遮挡描边效果，应该就是这么来的)</p></blockquote><h3 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a><em>LOD</em></h3><blockquote><p>细节等级。大家玩吃鸡的时候，从飞机上跳下，这时看到地图上的建筑都是比较粗糙的块，当距离慢慢拉近，建筑模型变得越发精致，这就是 LOD 技术，根据不同的范围使用不同的模型。shader 的 LOD 也是同样用法，不同细节等级，使用不同的 LOD。在 Unity 的 Quality Settings 中可以设定最大 LOD 值，当当前 LOD 小于 shader LOD 时，那个 sub shader 就会失效.<br>VertexLit 及其系列 = 100<br>Decal, Reflective VertexLit = 150<br>Diffuse = 200<br>Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250<br>Bumped, Specular = 300<br>Bumped Specular = 400<br>Parallax = 500<br>Parallax Specular = 600### 三、实例</p></blockquote><h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a><em>pass</em></h3><blockquote><p>pass 是实现着色器具体代码的地方。一个 subshader 内可以有多个 pass。但尽可能用较少的 pass 实现是对性能的考虑。</p></blockquote><p>*pass 内的 tags 说明 *<br>pass 内的 tags 有别与 subshader 中的 tags</p><table><thead><tr><th>取值</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>Always</td><td>“LightMode”=“Always”</td><td>不管是用哪种渲染路径，该 pass 总是会被渲染。但不计算任何光照</td></tr><tr><td>Forwardbase</td><td>“LightMode”=“ForwardBase”</td><td>用于向前渲染，该 pass 会计算环境光，重要的平行光，逐顶点 / SH 光源和 lightmaps</td></tr><tr><td>ForwardAdd</td><td>“LightMode”=“ForwardAdd”</td><td>用于向前渲染，该 pass 会计算额外的逐像素光源，每个 pass 对应一个光源</td></tr><tr><td>Deferred</td><td>“LightMode”=“Deferred”</td><td>用于向前渲染，该 pass 会渲染 G 缓冲，G-buffer</td></tr><tr><td>ShadowCaster</td><td>“LightMode”=“ShadowCaster”</td><td>把物体的深度信息渲染到盈盈映射纹理（shadowmap）或一张深度纹理中，用于渲染产生阴影的物体</td></tr><tr><td>ShadowCollector</td><td>“LightMode”=“ShadowCollector”</td><td>用于收集物体阴影到屏幕坐标 Buff 里</td></tr><tr><td>PrepassBase</td><td></td><td>用于遗留的延迟渲染，该 pass 会渲染法线和高光反射的指数部分</td></tr><tr><td>PrepassFinal</td><td></td><td>用于遗留的延迟渲染，该 pass 通过合并纹理、光照和自发光来渲染得到最后的颜色</td></tr><tr><td>Vertex、VertexLMRGBM 和 VertexLM</td><td></td><td>用于遗留的顶点照明渲染</td></tr></tbody></table><p>pass 内的代码分为：固定渲染管线、可编程顶点 / 片段渲染管线，可编程表面渲染管线。<br>下面是对三种渲染管线的详细介绍。</p><h3 id="pass-中的-ragma"><a href="#pass-中的-ragma" class="headerlink" title="pass 中的 ragma"></a>pass 中的 ragma</h3><p>ragma 用于对渲染器的控制。<br>ragma 参数表</p><table><thead><tr><th>命令</th><th>参数</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>vertex</td><td></td><td>#pragma vertex name</td><td>将函数 name 的代码编译为顶点程序</td></tr><tr><td>fragment</td><td></td><td>#pragma fragment name</td><td>将函数 name 的代码编译为片元程序</td></tr><tr><td>geometry</td><td></td><td>#pragma geometry name</td><td>将函数 name 的代码编译为 DX10 的几何着色器</td></tr><tr><td>hull</td><td></td><td>#pragma hull name</td><td>将函数 name 的代码编译为 DX11hull 着色器</td></tr><tr><td>domain</td><td></td><td>#pragma domain name</td><td>将函数 name 的代码编译为 DX11 domain 着色器</td></tr><tr><td>fragmentoption option</td><td></td><td>#pragma fragmentoption option</td><td>添加选项到编译的 OpenGL 片段程序。对顶点程序或编译目标不是 opengl 的程序无效</td></tr><tr><td>target</td><td>target 2.0、target 3.0、target 4.0、target 5.0</td><td>#pragma target name</td><td>设置着色器的编译目标，对应不同版本的着色器模型</td></tr><tr><td>only_renderers space separated</td><td>d3d9（direct3d 9）、d3d11、opengl、gles(opengl 2s 2.0)、xbox360、ps3、flash</td><td>#pragma only_renderers space separated names</td><td>仅编译到指定的渲染平台</td></tr><tr><td>exclude_renderers space separated</td><td>d3d9（direct3d 9）、d3d11、opengl、gles(opengl 2s 2.0)、xbox360、ps3、flash</td><td>#pragma exclude_renderers space separated names</td><td>不编译到指定的渲染平台</td></tr><tr><td>glsl</td><td>#pragma glsl</td><td>为桌面系统的 opengl 进行编译时，将 cg/hlsl 代码转为 glsl 代码</td><td></td></tr><tr><td>glsl_no_auto_normalization</td><td>#pragma glsl_no_auto_normalization name</td><td>编译到移动平台 glsl 时（ios/android）, 关闭在定点着色器中对法线向量和切线向量自动进行规范化</td><td></td></tr></tbody></table><h2 id="着色器中的参数"><a href="#着色器中的参数" class="headerlink" title="着色器中的参数"></a>着色器中的参数</h2><h3 id="从应用阶段传递模型数据给顶点着色器时-常用的语义"><a href="#从应用阶段传递模型数据给顶点着色器时-常用的语义" class="headerlink" title="从应用阶段传递模型数据给顶点着色器时 常用的语义"></a>从应用阶段传递模型数据给顶点着色器时 常用的语义</h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>POSITION</td><td></td><td>模型空间中的顶点位置，一般是 float4 类型</td></tr><tr><td>NORMAL</td><td></td><td>顶点法线，float3 类型</td></tr><tr><td>TANGENT</td><td></td><td>顶点切线 float4</td></tr><tr><td>TEXCOORD0~N</td><td></td><td>该顶点纹理坐标，0 是第一组，一般是 flkoat2 或 float4 类型</td></tr><tr><td>COLOR</td><td></td><td>定点颜色，通常是 fixed4 或 float4 类型</td></tr></tbody></table><h3 id="从顶点着色器传递给片元着色器时-常用的语义"><a href="#从顶点着色器传递给片元着色器时-常用的语义" class="headerlink" title="从顶点着色器传递给片元着色器时 常用的语义"></a>从顶点着色器传递给片元着色器时 常用的语义</h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>SV_POSITION</td><td></td><td>裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量</td></tr><tr><td>COLOR0</td><td></td><td>用于输出第一组顶点颜色</td></tr><tr><td>COLOR1</td><td></td><td>通常用于输出第二组顶点颜色</td></tr><tr><td>TEXCOORD0~TEXCOORD7</td><td></td><td>通常用于输出纹理坐标</td></tr></tbody></table><h3 id="片元着色器输出给-unity-时常用的语义"><a href="#片元着色器输出给-unity-时常用的语义" class="headerlink" title="片元着色器输出给 unity 时常用的语义"></a>片元着色器输出给 unity 时常用的语义</h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>SV_Target</td><td></td><td>输出值将会存到渲染目标（render target）中</td></tr></tbody></table><h3 id="unity-内置的矩阵变换"><a href="#unity-内置的矩阵变换" class="headerlink" title="unity 内置的矩阵变换"></a>unity 内置的矩阵变换</h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>UNITY_MATRIX_MVP</td><td></td><td>当前的模型观察投影矩阵，用于将顶点 / 方向矢量从模型空间变换到裁剪空间</td></tr><tr><td>UNITY_MATRIX_MV</td><td></td><td>当前的模型观察矩阵，用于将顶点 / 方向矢量从模型空间变换到观察空间</td></tr><tr><td>UNITY_MATRIX_V</td><td></td><td>当前的观察矩阵，用于将顶点 / 方向矢量从世界空间变换到观察空间</td></tr><tr><td>UNITY_MATRIX_P</td><td></td><td>当前的投影矩阵，用于将顶点 / 方向矢量从观察空间变换到裁剪空间</td></tr><tr><td>UNITY_MATRIX_VP</td><td></td><td>当前的观察投影矩阵，用于将顶点 / 方向矢量从世界空间变换到裁剪空间</td></tr><tr><td>UNITY_MATRIX_T_MV</td><td></td><td>UNITY_MATRIX_MV 的转置矩阵</td></tr><tr><td>UNITY_MATRIX_IT_MV</td><td></td><td>UNITY_MATRIX_MV 的逆转置矩阵，用于将法线从模型空间变换到观察空间，也可以用于得到 UNITY_MATRIX_MV 的逆矩阵</td></tr><tr><td>_Object2World</td><td></td><td>当前的模型矩阵，用于将顶点 / 方向矢量从模型空间变换到世界空间</td></tr><tr><td>_World2Object</td><td></td><td>_Object2World 的逆转矩阵，用于将顶点 / 方向矢量从世界空间变换到模型空间</td></tr></tbody></table><h3 id="unity-顶点转换函数"><a href="#unity-顶点转换函数" class="headerlink" title="unity 顶点转换函数"></a>unity 顶点转换函数</h3><table><thead><tr><th>命令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>float4 UnityObjectToClipPos(float3 pos)</td><td>将一个点从 object 空间转换成相机在均匀坐标下的剪辑空间。这就相当于 mul(UNITY_MATRIX_MVP, float4(pos, 1.0)), 应该在它的位置上使用。</td><td></td></tr><tr><td>float3 UnityObjectToViewPos(float3 pos)</td><td>将一个点从 object 空间转换为 view 空间。这就相当于 mul(UNITY_MATRIX_MV, float4(pos, 1.0)).xyz, 应该在它的位置上使用。</td><td></td></tr></tbody></table><h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><table><thead><tr><th>命令</th><th>说明</th><th>实例</th></tr></thead></table><h3 id="unity-内置的摄像机和屏幕参数"><a href="#unity-内置的摄像机和屏幕参数" class="headerlink" title="unity 内置的摄像机和屏幕参数"></a>unity 内置的摄像机和屏幕参数</h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>float3 _WorldSpaceCameraPos</td><td></td><td>该摄像机在世界空间中的位置</td></tr><tr><td>float4 _ProjectionParams</td><td></td><td>x=1.0 或 - 1.0（使用反转的投影矩阵渲染时是负数），y=Near，z=Far，w= 1.0+1.0/Far, 其中 near 和 far 分别是近裁剪平面和远裁剪平面与摄像机的距离</td></tr><tr><td>float4 _ScreenParams</td><td></td><td>x=width,y=height,z=1.0+1.0/width,w=1.0+1.0/height, 其中 width 和 height 分别是该摄像机的渲染目标 (render target) 的像素宽度和高度</td></tr><tr><td>float4 _ZBufferParams</td><td></td><td>x=1-Far/near，yFar/Near， 最 x/Far，wy/Far，该变量用于线性化 Z 缓存中的深度值</td></tr><tr><td>floart4 unity_OrhoParams</td><td></td><td>x=width,y=height,z 无意义，w=1.0(该相机是正交相机) 或 w=0.0（透视相机），其中 width 和 height 是正交投影相机的宽和高</td></tr><tr><td>float4x4 unity_CameraProjection</td><td></td><td>该摄像机的投影矩阵</td></tr><tr><td>floart4x4 unity_CameraInvProjection</td><td></td><td>该摄像机的投影矩阵的逆矩阵</td></tr><tr><td>float4 unity_CameraWorldClipPlanes</td><td></td><td>该摄像机的 6 个裁剪屏幕在世界空间下的等式，按左右上下近远的顺序裁剪平面</td></tr></tbody></table><h3 id="时间变量"><a href="#时间变量" class="headerlink" title="时间变量"></a>时间变量</h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>float4 _Time</td><td>_Time.x;_Time.y; _Time.z; _Time.w;</td><td>t 是自该场景加载开始所经过的时间，4 个分量分别是 t/20,t,2t,3t</td></tr><tr><td>float4 _SinTime</td><td></td><td>t 是时间的正限制，4 个分量分别是 t/8,t/4,t/2,t</td></tr><tr><td>float4 _Costime</td><td></td><td>t 是时间的余弦值，t/8,t/4.t/2,t</td></tr><tr><td>float4 unity_DeltaTime</td><td></td><td>dt 是时间增量, 4 个值分别是 dt,1/dt,smoothDt,1/smoothDt</td></tr></tbody></table><h2 id="UnityCG-cginc-库"><a href="#UnityCG-cginc-库" class="headerlink" title="UnityCG.cginc 库"></a>UnityCG.cginc 库</h2><p>UnityCG.cginc 该文件中包含了很多即成的参数方法。使用十分方便</p><h3 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure><h3 id="unitycg-cginc-常用结构"><a href="#unitycg-cginc-常用结构" class="headerlink" title="unitycg.cginc 常用结构"></a>unitycg.cginc 常用结构</h3><table><thead><tr><th>命令</th><th>参数</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>appdata_base</td><td>顶点位置、顶点法线、第一组纹理坐标</td><td>float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord: TEXCOORD0;</td><td>可用于顶点着色器的输入</td></tr><tr><td>appdata_tan</td><td>顶点位置、顶点切线、顶点法线、第一组纹理坐标</td><td>float4 vertex : POSITION; float4 tangent : TANGENT; float3 normal : NORMAL; float4 texcoord : TEXCOORD0;</td><td>可用于顶点着色器的输入</td></tr><tr><td>appdata_full</td><td>顶点位置、顶点切线、顶点法线、四组（或更多）纹理坐标 i</td><td><code>cfloat4 vertex : POSITION; float4 tangent : TANGENT; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; float4 texcoord1 : TEXCOORD1; float4 texcoord2 : TEXCOORD2; float4 texcoord3 : TEXCOORD3; #if defined(SHADER_API_XBOX360) half4 texcoord4 : TEXCOORD4; half4 texcoord5 : TEXCOORD5; #endif fixed4 color : COLOR;</code></td><td>可用于顶点着色器的输入</td></tr><tr><td>appdata_img</td><td>可用于顶点着色器的输入</td><td>float4 vertex : POSITION; half2 texcoord : TEXCOORD0;</td><td>可用于顶点着色器的输入</td></tr><tr><td>v2f_img</td><td>裁剪空间中的位置、纹理坐标</td><td></td><td>可用于顶点着色器的输出</td></tr></tbody></table><h3 id="unitycg-cginc-常用函数"><a href="#unitycg-cginc-常用函数" class="headerlink" title="unitycg.cginc 常用函数"></a>unitycg.cginc 常用函数</h3><table><thead><tr><th>命令</th><th>参数</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>float4 WorldSpaceViewDir(float4 v)</td><td></td><td></td><td>输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向</td></tr><tr><td>float4 UnityWorldSpaceViewDir(float4 v)</td><td></td><td></td><td>输入一个世界空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向</td></tr><tr><td>float4 ObjSpaceViewDir(float4 v)</td><td></td><td></td><td>输入一个模型空间中的顶点位置，返回模型空间中从该店到摄像机的观察方向</td></tr><tr><td>float4 WorldSpace LightDir(flaot4 v)</td><td></td><td></td><td>仅用于向前渲染。 输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化</td></tr><tr><td>float4 ObjectSpaceLightDir(float4 v)</td><td></td><td></td><td>仅用于向前渲染中，输入一个模型空间中的顶点位置， 返回模型空间中从该点到光源的光照方向。没有被归一化</td></tr><tr><td>float4 UnityWorldSpaceLightDir(float4 v)</td><td></td><td></td><td>仅用于向前渲染中，输入一个世界空间中的顶点位置， 返回世界空间中从该点到光源的光照方向。没有被归一化</td></tr><tr><td>float3 UnityObjectToWorldNormal(float3 norm)</td><td></td><td></td><td>把法线方向从模型空间中转换到世界空间中</td></tr><tr><td>float3 UnityObjectToWorldDir(float3 dir)</td><td></td><td></td><td>把方向矢量从模型空间中变换到世界空间中</td></tr><tr><td>float3 Unity WorldToObjectDir(float3 dir)</td><td></td><td></td><td>把方向矢量从世界空间变换到模型空间中</td></tr></tbody></table><h3 id="shader-数学函数："><a href="#shader-数学函数：" class="headerlink" title="shader 数学函数："></a>shader 数学函数：</h3><table><thead><tr><th>函数</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>radians(degree)</td><td>角度变弧度 (一般默认都用弧度)</td><td></td></tr><tr><td>degrees(radian)</td><td>弧度变角度</td><td></td></tr><tr><td>sin(angle), cos(angle), tan(angle)</td><td>三角函数</td><td></td></tr><tr><td>asin(x)</td><td>arc sine, 返回弧度 [-PI/2, PI/2];</td><td></td></tr><tr><td>acos(x)</td><td>arc cosine, 返回弧度 [0, PI]</td><td></td></tr><tr><td>atan(y, x)</td><td>arc tangent, 返回弧度 [-PI, PI];</td><td></td></tr><tr><td>atan(y/x)</td><td>arc tangent, 返回弧度 [-PI/2, PI/2];</td><td></td></tr><tr><td>pow(x, y)</td><td>x 的 y 次方</td><td></td></tr><tr><td>exp(x)</td><td>指数, log(x)</td><td></td></tr><tr><td>exp2(x)</td><td>2 的 x 次方， log2(x)</td><td></td></tr><tr><td>sqrt(x)</td><td>x 的根号；</td><td></td></tr><tr><td>inversesqrt(x)</td><td>x 根号的倒数</td><td></td></tr><tr><td>abs(x)</td><td>绝对值</td><td></td></tr><tr><td>sign(x)</td><td>取当前数值的正负符号, 返回 1, 0 或 -1</td><td>（x&gt;0;x=0;x&lt;0）</td></tr><tr><td>floor(x)</td><td>底部取整</td><td></td></tr><tr><td>ceil(x)</td><td>顶部取整</td><td></td></tr><tr><td>fract(x)</td><td>取小数部分</td><td></td></tr><tr><td>mod(x, y)</td><td>取模， x - y*floor(x/y)</td><td></td></tr><tr><td>min(x, y)</td><td>取最小值</td><td></td></tr><tr><td>max(x, y)</td><td>取最大值</td><td></td></tr><tr><td>clamp(x, min, max)</td><td>min(max(x, min), max);</td><td></td></tr><tr><td>mix(x, y, a)</td><td>x, y 的线性混叠， x(1-a) + y*a;</td><td></td></tr><tr><td>step(edge, x)</td><td>如 x smoothstep(edge0, edge1, x): threshod smooth transition 时使用。 edge0&lt;=edge0 时为 0.0， x&gt;=edge1 时为 1.0</td><td></td></tr><tr><td>length(x)</td><td>向量长度</td><td></td></tr><tr><td>distance(p0, p1)</td><td>两点距离， length(p0-p1);</td><td></td></tr><tr><td>dot(x, y)</td><td>点积，各分量分别相乘 后 相加</td><td></td></tr><tr><td>cross(x, y)</td><td>差积</td><td>x[1]*y[2]-y[1]*x[2], x[2]*y[0] - y[2]*x[0], x[0]*y[1] - y[0]*x[1]</td></tr><tr><td>normalize(x)</td><td>归一化</td><td>length(x)=1;</td></tr><tr><td>faceforward(N, I, Nref)</td><td>如 dot(Nref, I)&lt; 0 则 N, 否则 -N</td><td></td></tr><tr><td>reflect(I, N)</td><td>I 的反射方向</td><td>I -2*dot(N, I)*N, N 必须先归一化</td></tr><tr><td>refract(I, N, eta)</td><td>折射</td><td>k=1.0-eta<em>eta</em>(1.0 - dot(N, I) * dot(N, I)); 如 k&lt;0.0 则 0.0，否则 eta<em>I - (eta</em>dot(N, I)+sqrt(k))*N</td></tr><tr><td>matrixCompMult(matX, matY)</td><td>矩阵相乘, 每个分量 自行相乘</td><td>r[j] = x[j]*y[j];</td></tr><tr><td>lessThan(vecX, vecY)</td><td>向量 每个分量比较 x &lt; y</td><td></td></tr><tr><td>lessThanEqual(vecX, vecY)</td><td>向量 每个分量比较 x&lt;=y</td><td></td></tr><tr><td>greaterThan(vecX, vecY)</td><td>向量 每个分量比较 x&gt;y</td><td></td></tr><tr><td>greaterThanEqual(vecX, vecY)</td><td>向量 每个分量比较 x&gt;=y</td><td></td></tr><tr><td>equal(vecX, vecY)</td><td>向量 每个分量比较 x==y</td><td></td></tr><tr><td>notEqual(vecX, vexY)</td><td>向量 每个分量比较 x!=y</td><td></td></tr><tr><td>any(bvecX)</td><td>只要有一个分量是 true， 则 true</td><td></td></tr><tr><td>all(bvecX)</td><td>所有分量是 true， 则 true</td><td></td></tr><tr><td>not(bvecX)</td><td>所有分量取反</td><td></td></tr></tbody></table><h2 id="三-着色器实例"><a href="#三-着色器实例" class="headerlink" title="三 着色器实例"></a>三 着色器实例</h2><h3 id="1-固定渲染管线"><a href="#1-固定渲染管线" class="headerlink" title="1. 固定渲染管线"></a>1. 固定渲染管线</h3><p>固定功能管线着色器的关键代码都在 Pass 的材质设置 Material{} 和纹理设置 SetTexture{} 部分。<br>目前固定着色器已经逐渐退出市场，只在为兼容一些老旧硬件设备而存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/VertexList&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">    <span class="comment">// 设置与 unity 通信的变量，用来通过 unity 编辑器获取素材资源及参数 </span></span><br><span class="line">        _Color(<span class="string">&quot;Main Color&quot;</span>,Color) = (<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0.5</span>)</span><br><span class="line">        _SpecColor(<span class="string">&quot;Spec Color&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Emission(<span class="string">&quot;Emissive Color&quot;</span>,Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        _Shininess(<span class="string">&quot;Shininess&quot;</span>,Range(<span class="number">0.01</span>,<span class="number">1</span>)) = <span class="number">0.7</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">                Material&#123;</span><br><span class="line">                       Diffuse[_Color]  <span class="comment">// 设置漫反射 </span></span><br><span class="line">                       Ambient[_Color]  <span class="comment">// 环境光 </span></span><br><span class="line">                       Shininess[_Shininess]  <span class="comment">// 光泽度 </span></span><br><span class="line">                       Specular[_SpecColor]  <span class="comment">// 高光色 </span></span><br><span class="line">                       Emission[_Emission]  <span class="comment">// 自发光 </span></span><br><span class="line">                &#125;      </span><br><span class="line">                Lighting On</span><br><span class="line">                SeparateSpecular On   <span class="comment">// 启用高光颜色 </span></span><br><span class="line">                <span class="comment">// 设置纹理 </span></span><br><span class="line">                SetTexture[_MainTex]&#123;</span><br><span class="line">                constantColor[_Color]   <span class="comment">// 设置颜色常量 </span></span><br><span class="line">                   <span class="comment">// 混合命令 </span></span><br><span class="line">                   combine texture * primary DOUBLE,</span><br><span class="line">                   texture *constant</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-顶点-片段渲染管线"><a href="#2-顶点-片段渲染管线" class="headerlink" title="2 . 顶点 / 片段渲染管线"></a>2 . 顶点 / 片段渲染管线</h3><p>功能强大，且用途最多的渲染器</p><blockquote><p>顶点 / 片段渲染管线 卸载 pass 块中，用 CGPROGRAM 标签包裹。</p></blockquote><p>该 shader 会实现根据观察方向而变色的效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader <span class="string">&quot;Custom/SurfaceShader&quot;</span>&#123;   </span><br><span class="line"> SubShader    &#123;        </span><br><span class="line"> Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;       </span><br><span class="line">LOD <span class="number">100</span></span><br><span class="line">Pass &#123;           </span><br><span class="line">         <span class="comment">//CG 代码块   </span></span><br><span class="line">         CGPROGRAM                </span><br><span class="line">         <span class="comment">// 一个 CGPROGRAM 块中必须有且只能有一个 vertex 和一个 fragment</span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> vertex vert                </span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">                <span class="comment">// 引入 unityCG 处理库 </span></span><br><span class="line">                <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">                <span class="comment">// 定义一个数据结构，该结构包含一个 4 维向量，一个三维向量      v2f 的意思是顶点 to 片元          </span></span><br><span class="line">                <span class="keyword">struct</span> v2f&#123; </span><br><span class="line">                <span class="comment">// 获取位置 </span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// 获取颜色                    </span></span><br><span class="line">                float2 color : COLOR0;                </span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 顶点程序代码，用于计算位置和颜色。   v2f 是刚才新建的数据结构，vert 是在 cgprogram 注册的用于顶点计算的程序名  </span></span><br><span class="line">                <span class="comment">// 该方法输入值 appdata_base v 是与模型关联后自动输入的，他的输出值会自动传入到片段代码块。所以相关联的顶点和片段方法的输出和输入类型一定要一致        </span></span><br><span class="line">                v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span>&#123;</span><br><span class="line">                <span class="comment">// 创建 v2f 数据 o</span></span><br><span class="line">                v2f o;                    </span><br><span class="line">                <span class="comment">// 计算位置                    </span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);                    </span><br><span class="line">                <span class="comment">// 计算颜色                    </span></span><br><span class="line">                o.color = v.normal* <span class="number">0.5</span> + <span class="number">0.5</span>;                    </span><br><span class="line">                <span class="comment">// 返回该 v2f 数据                    </span></span><br><span class="line">                <span class="keyword">return</span> o;                </span><br><span class="line">                 &#125;                </span><br><span class="line">                 <span class="comment">// 片段程序代码   </span></span><br><span class="line">                 <span class="comment">// 该代码块会自动接受顶点着色器的输出值，而他的输出值会交给像素着色器最终显示在屏幕上 </span></span><br><span class="line">                 half4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : COLOR&#123;</span><br><span class="line">                 <span class="comment">// 返回输入的颜色, 并设置透明度为 1                    </span></span><br><span class="line">                 <span class="keyword">return</span> half4(i.color,.<span class="number">5</span>,<span class="number">1</span>);                </span><br><span class="line">                 &#125;            </span><br><span class="line">                ENDCG        </span><br><span class="line">        &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 如果以上代码块失败，则用默认 vertexlit 渲染器 </span></span><br><span class="line">Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190806174142279.png" alt="总是按方向着色"></p><h3 id="3-表面渲染管线"><a href="#3-表面渲染管线" class="headerlink" title="3. 表面渲染管线"></a>3. 表面渲染管线</h3><p>备受 unity 宠爱的渲染器</p><blockquote><p>在 Unity 中，表面着色器的关键代码用 Cg/HLSL 语言编写，然后嵌在 ShaderLab 的结构代码中使用。使用表面着色器，用户仅需要编写最关键的表面函数，其余周边代码将由 Unity 自动生成，包括适配各种光源类型、渲染实时阴影以及集成到前向 / 延迟渲染管线中等。<br>光照模型可以是内置的 Lambert 和 BlinnPhong，或者是自定义的光照模型。<br>表面函数的作用是接收输入的 UV 或者附加数据，然后进行处理，最后将结构填充到输出结构体 SurfaceOutPut 中。</p></blockquote><ul><li>表面着色器的输入参数表 *</li></ul><table><thead><tr><th>数据类型</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>float3</td><td>viewDir</td><td>视角方向</td></tr><tr><td>float4</td><td>COLOR</td><td>每个顶点的插值颜色</td></tr><tr><td>float4</td><td>screenPos</td><td>屏幕坐标（使用. xy/.w 来获得屏幕 2D 坐标）</td></tr><tr><td>float3</td><td>worldPos</td><td>世界坐标</td></tr><tr><td>float3</td><td>worldRefl</td><td>世界坐标系中的反射向量</td></tr><tr><td>float3</td><td>worldNormal</td><td>世界坐标系中的法线向量</td></tr><tr><td></td><td>INTERNAL_DATA</td><td>当输入结构包含 worldRefl 或 worldNormal 且表面函数会写入输出结构的 Normal 字段是需包含此声明</td></tr></tbody></table><ul><li>表面着色器的输出参数表 *</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SurfaceOutput</span>&#123;</span></span><br><span class="line">    half3 Albedo;<span class="comment">// 反射光 </span></span><br><span class="line">    half3 Normal;<span class="comment">// 法线 </span></span><br><span class="line">    half3 Emission;<span class="comment">// 自发光 </span></span><br><span class="line">    half Specular;<span class="comment">// 高光 </span></span><br><span class="line">    half Gloss;<span class="comment">// 光泽度 </span></span><br><span class="line">    half Alpha;<span class="comment">// 透明度 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/surfShader&quot;</span></span><br><span class="line">Properties&#123;&#125;</span><br><span class="line">SubShader&#123;</span><br><span class="line"><span class="comment">// 当系统渲染不透明物体时 调用该 shader</span></span><br><span class="line">Tags&#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 表面着色器代码块  不放在 pass 中，编译后会分放至各个 pass 中 </span></span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">// 定义着色器类型为 surface（表面着色器），并使用光照模型 Lambert</span></span><br><span class="line"><span class="meta">#progma surface surf Lambert</span></span><br><span class="line"><span class="comment">// 定义输入数据的结构体 </span></span><br><span class="line"><span class="keyword">struct</span> Input &#123;</span><br><span class="line"><span class="type">float</span> color :COLOR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义输出数据的结构体 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SurfaceOutput</span>&#123;</span></span><br><span class="line">   half3 Albedo;<span class="comment">// 反射光 </span></span><br><span class="line">   half3 Normal;<span class="comment">// 法线 </span></span><br><span class="line">   half3 Emission;<span class="comment">// 自发光 </span></span><br><span class="line">   half Specular;<span class="comment">// 高光 </span></span><br><span class="line">   half Gloss;<span class="comment">// 光泽度 </span></span><br><span class="line">   half Alpha;<span class="comment">// 透明度 </span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 表面函数 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">surf</span><span class="params">(Input IN, inoutSurfaceOutput o)</span>&#123;</span><br><span class="line">o.Albedo = <span class="number">1</span>;<span class="comment">// 输出颜色 </span></span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">Fallback <span class="string">&quot;Diffuse&quot;</span><span class="comment">// 备选着色器 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四，着色器效果集"><a href="#四，着色器效果集" class="headerlink" title="四，着色器效果集"></a>四，着色器效果集</h2><p>该连接中包含很多着色器代码实例，具体的代码和详细的注释，不定时更新中<br><a href="https://blog.csdn.net/lengyoumo/article/details/99676462">https://blog.csdn.net/lengyoumo/article/details/99676462</a></p><h2 id="五，三大测试与剔除、透明混合"><a href="#五，三大测试与剔除、透明混合" class="headerlink" title="五，三大测试与剔除、透明混合"></a>五，三大测试与剔除、透明混合</h2><p>三大测试：深度测试、透明测试、模版测试<br>重点：三大测试与剔除都是决定是否显示像素条件！混合是指有透明物体的情况下像素该如何叠加显示<br>深度测试依据物体在镜头前的空间位置排序。<br>透明测试依据颜色透明度，也就是 alpha 值。<br>模版测试依据自定义的值，当同样带有模版值的元素叠加时触发</p><p>剔除与三种测试渲染顺序按先后排列。</p><h3 id="5-0-Cull-剔除"><a href="#5-0-Cull-剔除" class="headerlink" title="5.0 Cull 剔除"></a>5.0 Cull 剔除</h3><p>Cull 是剔除的意思。</p><table><thead><tr><th>命令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Off</td><td>绘制所有的面</td><td>Cull Off</td></tr><tr><td>Front</td><td>不绘制面向相机部分的面</td><td>Cull Front</td></tr><tr><td>Back</td><td>不绘制背对相机的面</td><td>Cull Back</td></tr></tbody></table><h3 id="5-1-透明测试-AlphaTest"><a href="#5-1-透明测试-AlphaTest" class="headerlink" title="5.1 透明测试 AlphaTest"></a>5.1 透明测试 AlphaTest</h3><p>当透明度到达指定值，就输出像素，否则抛弃<br>语法：</p><table><thead><tr><th>指令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Greater</td><td>大于，只渲染大于该值的像素。</td><td>alphatest greater [_alphaValue] // 类似于抠图</td></tr><tr><td>Less</td><td>小于，只渲染小于该值的像素。</td><td>类似于反向抠图</td></tr><tr><td>GEqual</td><td>大于等于</td><td></td></tr><tr><td>LEqual</td><td>小于等于</td><td></td></tr><tr><td>Equal</td><td>等于</td><td></td></tr><tr><td>NotEqual</td><td>不等于</td><td></td></tr><tr><td>Always</td><td>总是</td><td></td></tr><tr><td>Never</td><td>永不</td><td></td></tr><tr><td>Off</td><td>关闭</td><td>alphatest Off</td></tr></tbody></table><p>例 1 表面着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 实例，只要声明 alphatest greater [_alphaValue] 即可。</span><br><span class="line">Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _alphaValue(<span class="string">&quot;alphavalue&quot;</span>,range(<span class="number">0</span>,<span class="number">1</span>))=<span class="number">0.3</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">        alphatest greater [_alphaValue]</span><br><span class="line">        CGPROGRAM</span><br><span class="line">...............</span><br><span class="line">ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>例 2 片段着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span>:SV_Target&#123;</span><br><span class="line">fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">clip(texColor.a - _Cutoff);</span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="comment">//if((texColor.a - _Cutoff)&lt;0.0)&#123;</span></span><br><span class="line"><span class="comment">//discard;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-透明度混合-Blend"><a href="#5-1-2-透明度混合-Blend" class="headerlink" title="5.1.2 透明度混合 Blend"></a>5.1.2 透明度混合 Blend</h3><p>混合命令</p><table><thead><tr><th>指令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Blend Off</td><td>关闭混合</td><td></td></tr><tr><td>Blend SrcFactor DstFactor</td><td>开启混合，并设置混合因子，片元颜色胡 i 成因 SrcFactor，而已经存在颜色缓存中的颜色会诚意 DstFactor，然后把两者相加后再存入颜色缓冲中</td><td></td></tr><tr><td>Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td>上同，使用不同因子来混合透明通道</td><td></td></tr><tr><td>BlendOp BlendOperation</td><td>并非是把源颜色和目标颜色简单相加后混合，而是使用 BlendOperation 对他们进行其他操作</td><td></td></tr></tbody></table><p>混合因子</p><table><thead><tr><th>指令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>One</td><td>因子值为 1</td><td></td></tr><tr><td>Zero</td><td>因子值为 0</td><td></td></tr><tr><td>SrcColor</td><td>因子为源颜色值（当前片元），当用于混合 rgb 时，使用 SrcColor 的 RGb 分量作为混合因子，当用于混合 a 的混合等式时，使用 SrcColor 的 A 分量作为混合因子</td><td></td></tr><tr><td>SrcAlpha</td><td>因子为源颜色的透明度，A 通道</td><td></td></tr><tr><td>DstColor</td><td>因子为目标颜色（已经存在颜色缓存中的颜色），当用于混合 rgb 时，使用 DstColor 的 RGb 分量作为混合因子，当用于混合 a 的混合等式时，使用 DstColor 的 A 分量作为混合因子</td><td></td></tr><tr><td>DstAlpha</td><td>因子为源颜色的透明度，A 通道</td><td></td></tr><tr><td>OneMinusSrcColor</td><td>因子为 1 - 源颜色，其余与 SrcColor 相同</td><td></td></tr><tr><td>OneMinusSrcAlpha</td><td>因子为 1 - 源颜色的透明度值</td><td></td></tr><tr><td>OneMinusDstColor</td><td>因子为 1- 目标颜色, 其余与 DstColor 相同</td><td></td></tr><tr><td>OneMinusDstAlpha</td><td>因子为 1- 目标颜色透明度</td><td></td></tr></tbody></table><p>混合操作<br>BlendOp</p><table><thead><tr><th>指令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Add</td><td>将混合后的源颜色和目标颜色相加</td><td></td></tr><tr><td>Sub</td><td>将混合后的源颜色减去混合后的目标颜色</td><td></td></tr><tr><td>RevSub</td><td>用混合后的目标颜色减去混合后的源颜色</td><td></td></tr><tr><td>Min</td><td>使用源颜色和目标 i 颜色中较小的值</td><td></td></tr><tr><td>Max</td><td>使用源颜色和目标颜色中较大的值</td><td></td></tr></tbody></table><p>片段<br>正常：Blend SrcAlpha OneMunusSrcAlph<br>柔和相加 Blend OneMinusDstColor One<br>正片叠底：Blend DstColor Zero<br>两倍相乘：Blend DstColor SrcColor<br>变暗：BlendOp Min<br>Blend One One<br>变量：BlendOp Max<br>Blend One One<br>滤色：Blend OneMinusDstColor One 等偶同于 Blend One OneMinusSrcColor<br>线性减淡：Blend One One</p><h3 id="5-2-模板测试-StencilTest"><a href="#5-2-模板测试-StencilTest" class="headerlink" title="5.2 模板测试 StencilTest"></a>5.2 模板测试 StencilTest</h3><p>啥是模板测试，每个像素都有一个 stencil 值，在同一个像素上，所有 shader 的 stencil 都共享这一个值，当有其他带有遮罩像素与其重合时就能获取到该值，并根据自身的 stencil 值处理或。典型的应用就是遮罩显示。你可以选择每次重合都增加 1，然后再指定某个物体，当值达到某个数量级再显示。这样的场景，比如，有个隐身的怪物，你只有使用圣水喷雾才能让他现行，但必须喷 3 次才行，这样，空中就存在了 3 次叠加的雾，透过这个 3 层雾就能看到怪物了。但你偏一下角度，透过两层 wu 就看不到。<br>Stencil 完整语法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stencil&#123;</span><br><span class="line">Ref referenceValue <span class="comment">// 每个像素都有一个 stencil 值，在同一个像素上，所有 shader 的 stencil 都共享这一个值，当有其他带有遮罩像素与其重合时就能获取到该值，并根据自身的 stencil 值处理触发小狗 </span></span><br><span class="line">ReadMask  readMask  <span class="comment">// 读遮罩 </span></span><br><span class="line">WriteMask writeMask  <span class="comment">// 写遮罩 </span></span><br><span class="line">Comp comparisonFunction   <span class="comment">// 条件判断  大于小于等触发 </span></span><br><span class="line">Pass stencilOperation    <span class="comment">// 满足条件后，相应的处理办法   是替换值还是增长值等 </span></span><br><span class="line">Fail stencilOperation    <span class="comment">// 没有通过模板测试怎么办 </span></span><br><span class="line">ZFail stencilOperation    <span class="comment">// 通过了模板测试怎么办 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板语法</p><table><thead><tr><th>参数</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Ref</td><td>ref 用来设定参考值（范围 0-255）。这个值用来与 stencilbuffer 比较</td><td></td></tr><tr><td>ReadMask</td><td>ReadMask 从字面意思的理解就是读遮罩，readMask 将和 referenceValue 以及 stencilBufferValue 进行按位与（&amp;）操作，readMask 取值范围也是 0-255 的整数，默认值为 255，二进制位 11111111，即读取的时候不对 referenceValue 和 stencilBufferValue 产生效果，读取的还是原始值</td><td></td></tr><tr><td>WriteMask</td><td>WriteMask 是当写入模板缓冲时进行掩码操作（按位与【&amp;】），writeMask 取值范围是 0-255 的整数，默认值也是 255，即当修改 stencilBufferValue 值时，写入的仍然是原始值。</td><td></td></tr><tr><td>Comp</td><td>Comp 是定义参考值（referenceValue）与缓冲值（stencilBufferValue）比较的操作函数，默认值：always</td><td></td></tr><tr><td>Pass</td><td>Pass 是定义当模板测试（和深度测试）通过时，则根据（stencilOperation 值）对模板缓冲值（stencilBufferValue）进行处理，默认值：keep</td><td></td></tr><tr><td>Fail</td><td>Fail 是定义当模板测试（和深度测试）失败时，则根据（stencilOperation 值）对模板缓冲值（stencilBufferValue）进行处理，默认值：keep</td><td></td></tr><tr><td>ZFail</td><td>ZFail 是定义当模板测试通过而深度测试失败时，则根据（stencilOperation 值）对模板缓冲值（stencilBufferValue）进行处理，默认值：keep</td><td></td></tr></tbody></table><p>模板对比</p><table><thead><tr><th>指令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Greater</td><td>大于，只渲染大于该值的像素。</td><td>alphatest greater [_alphaValue] // 类似于抠图</td></tr><tr><td>Less</td><td>小于，只渲染小于该值的像素。</td><td>类似于反向抠图</td></tr><tr><td>GEqual</td><td>大于等于</td><td></td></tr><tr><td>LEqual</td><td>小于等于</td><td></td></tr><tr><td>Equal</td><td>等于</td><td></td></tr><tr><td>NotEqual</td><td>不等于</td><td></td></tr><tr><td>Always</td><td>总是</td><td></td></tr><tr><td>Never</td><td>永不</td><td></td></tr><tr><td>Off</td><td>关闭</td><td>alphatest Off</td></tr></tbody></table><p>模板操作</p><table><thead><tr><th>指令</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Keep</td><td>保留当前缓冲中的内容，即 stencilBufferValue 不变</td><td></td></tr><tr><td>Zero</td><td>将 0 写入缓冲，即 stencilBufferValue 值变为 0。</td><td></td></tr><tr><td>Replace</td><td>将参考值写入缓冲，即将 referenceValue 赋值给 stencilBufferValue。</td><td></td></tr><tr><td>IncrSat</td><td>stencilBufferValue 加 1，如果 stencilBufferValue 超过 255 了，那么保留为 255，即不大于 255。</td><td></td></tr><tr><td>DecrSat</td><td>stencilBufferValue 减 1，如果 stencilBufferValue 超过为 0，那么保留为 0，即不小于 0。</td><td></td></tr><tr><td>Invert</td><td>将当前模板缓冲值（stencilBufferValue）按位取反</td><td></td></tr><tr><td>IncrWrap</td><td>当前缓冲的值加 1，如果缓冲值超过 255 了，那么变成 0，（然后继续自增）</td><td></td></tr><tr><td>DecrWrap</td><td>当前缓冲的值减 1，如果缓冲值已经为 0，那么变成 255，（然后继续自减） 。</td><td></td></tr></tbody></table><p>实例：遮罩<br>将此 shader 付给遮罩物体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/st1&quot;</span> &#123;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry-1&quot;</span>&#125;</span><br><span class="line">CGINCLUDE</span><br><span class="line"><span class="keyword">struct</span> appdata &#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line">v2f <span class="title function_">vert</span><span class="params">(appdata v)</span> &#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">half4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line"><span class="keyword">return</span> half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">Pass &#123;</span><br><span class="line">ColorMask <span class="number">0</span></span><br><span class="line">ZWrite Off</span><br><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">Ref <span class="number">1</span></span><br><span class="line">Comp Always</span><br><span class="line">Pass Replace</span><br><span class="line">&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将此 shader 付给被遮罩物体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shader <span class="string">&quot;Custom/st2&quot;</span> &#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_MainTex(<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">LOD <span class="number">100</span></span><br><span class="line">Pass &#123;</span><br><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">Ref <span class="number">2</span></span><br><span class="line">Comp Equal</span><br><span class="line">&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">appdata_t</span> &#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float2 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">float4 vertex : SV_POSITION;</span><br><span class="line">half2 texcoord : TEXCOORD0;</span><br><span class="line">UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">v2f <span class="title function_">vert</span><span class="params">(<span class="type">appdata_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">fixed4 col = tex2D(_MainTex, i.texcoord);</span><br><span class="line">UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">UNITY_OPAQUE_ALPHA(col.a);</span><br><span class="line"><span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可完成</p><h3 id="5-3-深度测试-DepthTest"><a href="#5-3-深度测试-DepthTest" class="headerlink" title="5.3 深度测试 DepthTest"></a>5.3 深度测试 DepthTest</h3><p>根据深度值选择通过测试。<br>Cull Back | Front | Off</p><p>ZWrite On | Off：用于控制是否将对象的像素写入深度缓冲（默认开启），如果需要绘制纯色物体，便将此项打开。如需绘制半透明效果，则关闭深度缓冲。<br>开启深度写入：当两个像素重合时，根据深度缓冲中的值对比，剔除掉离相机较远的那个，留下最近的那个显示。<br>关闭深度写入：不剔除任何像素，按顺序覆盖像素。（半透明物体需要这个）</p><p>ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always<br>用于控制深度测试如何执行, 缺省值是 LEqual。如果要绘制的像素的 Z 值 小余等于深度缓冲区中的值，那么就用新的像素颜色值替换。</p><p>Offset Factor,Units<br>利用 Factor 和 Units 来定义深度偏移<br>Factor 参数表示 Z 缩放的最大斜率的值<br>Units 参数表示可分辨的最小深度缓冲区的值<br>利用该句法，我们就可以强制使位于同一位置上的两个集合体中的一个几何体绘制在另一个的上层<br>以上几个值可以行内写。</p><h2 id="懒人片段"><a href="#懒人片段" class="headerlink" title="* 懒人片段 *"></a>* 懒人片段 *</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器正文 </span></span><br><span class="line">v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">v2f o;</span><br><span class="line"><span class="comment">// 获取顶点的裁剪坐标 </span></span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);<span class="comment">// 将模型顶点坐标转换为裁剪坐标 </span></span><br><span class="line"><span class="comment">// 获取纹理坐标 </span></span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<span class="comment">// 贴图与顶点对应的 uv, 必须配合下面的 TRANSFER_SHADOW(o)</span></span><br><span class="line"><span class="comment">// 顶点法线 * 世界转模型法线  获取世界法线？</span></span><br><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"><span class="comment">// 获取世界顶点 </span></span><br><span class="line">o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">TRANSFER_SHADOW(o);</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">ColorMask <span class="number">0</span>   <span class="comment">// 屏蔽所有颜色 </span></span><br><span class="line">fiexed4 <span class="title function_">frag</span><span class="params">(v2f i)</span>:color&#123;</span><br><span class="line"><span class="comment">// 纹理寻址 </span></span><br><span class="line">fixed4 colo = tex2D(_MainTex, i.texcoord)；</span><br><span class="line"><span class="comment">// 给贴图上色 </span></span><br><span class="line">colo = _Color * col；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法解释："><a href="#语法解释：" class="headerlink" title="语法解释："></a>语法解释：</h3><p>SetTexture[_MainTex]{<br>Combine Primary * Texture<br>}</p><p>SeparateSpecular On</p><p>Blend SrcAlpha OneMinusSrcAlpha</p><p>该文章参考了下列文章：<br><a href="https://www.jianshu.com/p/5be2801e226c">https://www.jianshu.com/p/5be2801e226c</a><br><a href="https://docs.unity3d.com/Manual/SL-Pass.html">https://docs.unity3d.com/Manual/SL-Pass.html</a><br><a href="https://blog.csdn.net/weixin/_33973609/article/details/85751777">https://blog.csdn.net/weixin\_33973609/article/details/85751777</a><br><a href="https://blog.csdn.net/pizi0475/article/details/6574700">https://blog.csdn.net/pizi0475/article/details/6574700</a><br><a href="https://blog.csdn.net/zx1091515459/article/details/79262053">https://blog.csdn.net/zx1091515459/article/details/79262053</a><br><a href="https://blog.csdn.net/zyq20130118/article/details/52874639">https://blog.csdn.net/zyq20130118/article/details/52874639</a><br><a href="https://blog.csdn.net/qq/_38572472/article/details/79020122">https://blog.csdn.net/qq\_38572472/article/details/79020122</a><br><a href="https://www.cnblogs.com/Jason-c/p/8385946.html">https://www.cnblogs.com/Jason-c/p/8385946.html</a><br><a href="https://blog.csdn.net/qq826364410/article/details/81744032">https://blog.csdn.net/qq826364410/article/details/81744032</a> 关于测试<br>喜欢看书的同学，重点推荐冯乐乐的 shader 入门教程，虽然说是入门教程，但写的由浅入深阅读曲线十分不错。重点推荐。csdn 还有她的博客请自搜。</p><p>新地址<br><a href="https://github.com/QianMo/Awesome-Unity-Shader">https://github.com/QianMo/Awesome-Unity-Shader</a></p><p><a href="https://blog.csdn.net/lyh916/category/_6208767.html">https://blog.csdn.net/lyh916/category\_6208767.html</a></p><p><a href="https://blog.csdn.net/ynnmnm/article/details/69791337">https://blog.csdn.net/ynnmnm/article/details/69791337</a></p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C# 中 ReadOnly 和 Const 的区别</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/C-%E4%B8%ADReadOnly%E5%92%8CConst%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/C-%E4%B8%ADReadOnly%E5%92%8CConst%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-04T06:08:52.000Z</published>
    <updated>2025-11-05T13:53:39.343Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="C-基本知识点-Readonly-和-Const-的区别"><a href="#C-基本知识点-Readonly-和-Const-的区别" class="headerlink" title="C# 基本知识点 - Readonly 和 Const 的区别"></a>C# 基本知识点 - Readonly 和 Const 的区别</h1><h2 id="目录"><a href="#目录" class="headerlink" title="** 目录 **"></a>** 目录 **</h2><ul><li>  ** 什么是静态常量（Const）和动态常量（Readonly）**</li><li>  ** 静态常量（Const）和动态常量（Readonly）之间的区别 **</li><li>  ** 动态常量（Readonly）被赋值后不可以改变 **</li><li>  ** 总结 **</li></ul><h2 id="什么是静态常量（Const）和动态常量（Readonly）"><a href="#什么是静态常量（Const）和动态常量（Readonly）" class="headerlink" title="** 什么是静态常量（Const）和动态常量（Readonly）**"></a>** 什么是静态常量（Const）和动态常量（Readonly）**</h2><p>　　先解释下什么是静态常量（Const）以及什么是动态常量（Readonly）。 **　　静态常量（Const）** 是指编译器在编译时候会对常量进行解析，并将常量的值替换成初始化的那个值。 **　　动态常量（Readonly）** 的值则是在运行的那一刻才获得的，编译器编译期间将其标示为只读常量，而不用常量的值代替，这样动态常量不必在声明的时候就初始化，而可以延迟到构造函数中初始化。</p><h2 id="静态常量（Const）和动态常量（Readonly）之间的区别"><a href="#静态常量（Const）和动态常量（Readonly）之间的区别" class="headerlink" title="** 静态常量（Const）和动态常量（Readonly）之间的区别 **"></a>** 静态常量（Const）和动态常量（Readonly）之间的区别 **</h2><p>静态常量（Compile-time Constant）</p><p>动态常量（Runtime Constant）</p><p>定义</p><p>声明的同时要设置常量值。</p><p>声明的时候可以不需要进行设置常量值，可以在类的构造函数中进行设置。</p><p>类型限制</p><p>只能修饰基元类型，枚举类型或者字符串类型。</p><p>没有限制，可以用它定义任何类型的常量。</p><p>对于类对象而言</p><p>对于所有类的对象而言，常量的值是一样的。</p><p>对于类的不同对象而言，常量的值可以是不一样的。</p><p>内存消耗</p><p>无。</p><p>要分配内存，保存常量实体。</p><p>综述</p><p>性能要略高，无内存开销，但是限制颇多，不灵活。</p><p>灵活，方便，但是性能略低，且有内存开销。</p><ol><li> Const 修饰的常量在声明的时候必须初始化; Readonly 修饰的常量则可以延迟到构造函数初始化 。</li><li> Const 常量既可以声明在类中也可以在函数体内，但是 Static Readonly 常量只能声明在类中。Const 是静态常量，所以它本身就是 Static 的，因此不能手动再为 Const 增加一个 Static 修饰符。</li><li> Const 修饰的常量在编译期间就被解析，即：经过编译器编译后，我们都在代码中引用 Const 变量的地方会用 Const 变量所对应的实际值来代替; Readonly 修饰的常量则延迟到运行的时候。</li></ol><p>　　举个例子来说明一下</p><p>public static readonly int NumberA = NumberB * 10;<br>public static readonly int NumberB = 10;</p><p>public const int NumberC = NumberD*10;<br>public const int NumberD = 10;</p><p>static void Main(string[] args)<br>{<br>    Console.WriteLine(“NumberA is {0}, NumberB is {1}.”, NumberA, NumberB);//NumberA is 0, NumberB is 10.<br>    Console.WriteLine(“NumberC is {0}, NumberD is {1}.”, NumberC, NumberD);//NumberC is 100, NumberD is 10.<br>    Console.ReadKey();<br>    }</p><p>复制</p><p>以上是语法方面的应用，那在实际的用法上，还是有些微妙的变化，通常不易发觉. 　　举个例子来说明一下： 　　在程序集 DoTestConst.dll 中有一个类 MyClass，定义了一个公开的静态变量 Count</p><p>public static class MyClass<br>{<br>    public const int Count = 10;<br>    }<br>    　　然后另外一个应用程序中引用 DoTestConst.dll，并在代码中作如下调用：<br>    public static void Main(string[] args)<br>    {<br>        Console.WriteLine(DoTestConst.MyClass.Count);// 输出 10<br>        Console.ReadKey();<br>        }</p><p>复制</p><p>复制</p><p>　　毫无疑问，非常简单的代码，直接输出 10。 　　接下来更新 MyClass 的 Count 的值为 20，然后重新编译 DoTestConst.dll，并更新到应用程序的所在目录中，注意不要编译应用程序。那么这时候的输出结果按预期那么想应该是 20 才对，但实际上还是 10，为什么呢？ 　　这就是 Const 的特别之处，有多特别还是直接看生成的 IL，查看 IL 代码(假设这时候 Count 的值为 10)</p><p>　　IL_0000: nop IL_0001: ldc.i4.s 10 　　IL_0003: call void [mscorlib]System.Console::WriteLine(int32)</p><p>　　红色代码很明显的表明了，直接加载 10，没有通过任何类型的加载然后得到对应变量的，也就是说在运行时没有去加载 DoTestConst.dll，那么是否意味着没有 DoTestConst.dll 也可以运行呢？答案是肯定的，删除 DoTestConst.dll 也可以运行，是否很诡异呢？也就解释了之前的实验，为什么更新 Const 变量的值之后没有调用新的值，因为程序在运行的时候根本不会去加载 DoTestConst.dll。那么 10 这个值是从哪来的呢？实际上 CLR 对于 Const 变量做了特殊处理，是将 Const 的值直接嵌入在生成的 IL 代码中，在执行的时候不会再去从 dll 加载。这也带来了一个不容易发觉的 Bug，因此在引用其他程序集的 Const 变量时，需考虑到版本更新问题，要解决这个问题就是把调用的应用程序再编译一次就 ok 了。但实际程序部署更新时可能只更新个别文件，这时候就必须用 Readonly 关键字来解决这个问题。</p><p>　　接下来看 Readonly 的版本：</p><p>public static class MyClass<br>{<br>    public static readonly int Count = 10;<br>    }</p><p>复制</p><p>复制</p><p>　调用方代码不变，接着看生成的 IL 代码：</p><p>　　IL_0000: nop IL_0001: ldsfld int32 [DoTestConst]DoTestConst.MyClass::Count 　　IL_0006: call void [mscorlib]System.Console::WriteLine(int32)</p><p>　　很明显加载代码变了，一个很常见的 ldsfld 动作，请求了 DoTestConst.MyClass 的 Count 变量，是通过强制要求加载 DoTestConst 来实现的。因此这时候更新 Count 的值重新编译之后，还是不编译调用程序，然后再执行就会看到新的值。而这时候如果删除 DoTestConst.dll 那么，会出现找不到 dll 之类的异常。这也充分说明了对于 Readonly 定义的变量是在运行时加载的。</p><h2 id="动态常量（Readonly）被赋值后不可以改变"><a href="#动态常量（Readonly）被赋值后不可以改变" class="headerlink" title="** 动态常量（Readonly）被赋值后不可以改变 **"></a>** 动态常量（Readonly）被赋值后不可以改变 **</h2><p>　　ReadOnly 变量是运行时变量，它在运行时第一次赋值后将不可以改变。其中 “不可以改变” 分为两层意思：</p><ol><li> 对于值类型变量，值本身不可以改变（Readonly， 只读）</li><li> 对于引用类型变量，引用本身（相当于指针）不可改变。</li></ol><p>　　值类型变量，举个例子说明一下：</p><p>public class Student<br>{<br>    public readonly int Age;</p><p>public Student(int age)<br>{<br>    this.Age = age;<br>    }<br>    }</p><p>复制</p><p>　　Student 的实例 Age 在构造函数中被赋值以后就不可以改变，下面的代码不会编译通过：</p><p>Student student = new Student(20);<br>student.Age = 21; // 错误信息：无法对只读的字段赋值（构造函数或变量初始化器中除外）</p><p>复制</p><p>复制</p><p>　引用类型变量，举个例子说明一下：</p><p>public class Student<br>{<br>    public int Age; // 注意这里的 Age 是没有 readonly 修饰符的</p><p>public Student(int age)<br>{<br>    this.Age = age;<br>    }<br>    }</p><p>public class School<br>{<br>    public readonly Student Student;</p><p>public School(Student student)<br>{<br>    this.Student = student;<br>    }<br>    }</p><p>复制</p><p>　　School 实例的 Student 是一个引用类型的变量，赋值后，变量不能再指向其他任何的 Student 实例，所以，下面的代码将不会编译通过：</p><p>School school = new School(new Student(10));<br>school.Student = new Student(20);// 错误信息：无法对只读的字段赋值（构造函数或变量初始化器中除外）</p><p>复制</p><p>复制</p><p>　　引用本身不可以改变，但是引用说指向的实例的值是可以改变的。所以下面的代码是可以编译通过的：</p><p>School school = new School(new Student(10));<br>school.Student.Age = 20;</p><p>复制</p><p>在构造方法中，我们可以多次对 Readonly 修饰的常量赋值。举个例子说明一下：</p><p>public class Student<br>{<br>    public readonly int Age = 20;// 注意: 初始化器实际上是构造方法的一部分，它其实是一个语法糖</p><p>public Student(int age)<br>{<br>    this.Age = age;<br>    this.Age = 25;<br>    this.Age = 30;<br>    }<br>}</p><h2 id="总结"><a href="#总结" class="headerlink" title="** 总结 **"></a>** 总结 **</h2><p>　　Const 和 Readonly 的最大区别(除语法外) 　　Const 的变量是嵌入在 IL 代码中，编译时就加载好，不依赖外部 dll（这也是为什么不能在构造方法中赋值）。Const 在程序集更新时容易产生版本不一致的情况。 Readonly 的变量是在运行时加载，需请求加载 dll，每次都获取最新的值。Readonly 赋值引用类型以后，引用本身不可以改变，但是引用所指向的实例的值是可以改变的。在构造方法中，我们可以多次对 Readonly 赋值。</p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity 粒子特效的适配</title>
    <link href="https://tamsiree.com/GameEngine/Unity/Unity%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%E7%9A%84%E9%80%82%E9%85%8D/"/>
    <id>https://tamsiree.com/GameEngine/Unity/Unity%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%E7%9A%84%E9%80%82%E9%85%8D/</id>
    <published>2022-11-03T02:18:35.000Z</published>
    <updated>2025-11-05T13:53:39.387Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在工作中使用粒子特效是发现了两个问题</p><pre><code>1. 美术提供的粒子特效没有根据屏幕分辨率自适应调整大小2. 粒子特效的层级比较奇怪</code></pre><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="粒子特效自适应"><a href="#粒子特效自适应" class="headerlink" title="粒子特效自适应"></a>粒子特效自适应</h2><p>在 Unity 编辑器开发中，使用的是 <code>1080*1920</code> 的分辨率，粒子特效大小看起来完美契合。</p><p><img src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/Unity/U20221103111203.png" alt="在 Unity 编辑器中"></p><p>在打包运行在手机上时，因为手机的分辨率为 <code>1440*2960</code>, 粒子特效就明显大于了 UI 界面。</p><p><img src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/Unity/U20221103113534.jpg" alt="在手机上"></p><p>解决办法：</p><p>将粒子特效的 <code>Scaling Mode</code> [缩放模式] ，改为 Hierarchy [跟随父节点缩放]。</p><blockquote><p>注意，改变了缩放模式之后，运行时会发现粒子变得特别小，这是因为 Unity 重置了该粒子特效的大小，只需要重新调整大小即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/Unity/U20221103115625.png"></p><p>因为我是在 FGUI 的基础上穿插使用粒子特效，因为 FGUI 与 Unity 的比例不一致，比例为 1：100，所以粒子特效需要将缩放比放大 100 倍。</p><blockquote><p><code>Scaling Mode</code> 为 <code>Local</code> 时不会有 FGUI 的比例问题，但是会有分辨率不适配问题，两害取其轻，所以选用 <code>Hierarchy</code> 模式。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">effect.transform.localScale = Vector3.one * <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="粒子特效层级"><a href="#粒子特效层级" class="headerlink" title="粒子特效层级"></a>粒子特效层级</h2><p>描述：当你把粒子特效挂到 UI 上之后，你发现要么粒子全被遮住了或者完全看不到特效。</p><p>解决方法：根据需求，修改粒子特效层级。 同样在 Particle System 面板里，往下拉找到 Renderer 组件，若未勾选则将其勾选打开。里面会有两个相关层级的选项：Sorting Layer （排序层级）和 Order in Layer （在层级中的位序）</p><p>只要将这两个层级改成与你的挂在 UI 一个层级，就会完全看到这个特效。如果你需要特效被遮挡，则需要将该层级改成低于 UI 的层级。</p><blockquote><p>这里有一个坑：当粒子特效和 UI 处于同一层级的时候，粒子特效不会被 UI 遮盖，无视节点顺序。</p></blockquote><p>当我们 UI 和粒子特效都处在同一层级时，此时我们能看到粒子特效没问题。但是假如此时有提示弹窗弹出，需要遮住整个界面的时候。你就会发现 UI 是遮住了，但是粒子特效却跃然于 UI 之上。解决这个问题只能是弹窗的层级必须比粒子特效高一个层级，否则无论如何粒子特效都能无视节点顺序，显示在同 UI 层级的 UI 之上</p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/categories/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/categories/GameEngine/Unity/"/>
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/tags/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>《守望先锋》架构设计和网络同步</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E3%80%8A%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B%E3%80%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E3%80%8A%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B%E3%80%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/</id>
    <published>2022-01-23T02:55:08.000Z</published>
    <updated>2025-11-05T13:53:39.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《守望先锋》2017 GDC 系列的分享前几年给了我很多帮助，尤其是 kevinan 大神的翻译更让我受益良多，如今我再想温习一下相关技术却发现很多网络上的文章图片都已经坏掉了，故在此收集网络资源发布重置版，当成备份。</p><p>重制版内容：新增多级标题，方便分块阅读，部分图片已由本人重置，一些必要的地方我录制了 Gif 图，方便观看。</p><p>全系列链接：<a href="https://www.lfzxb.top/ow-gdc-share-table-of-contents/">《守望先锋》GDC2017 技术分享精粹重制版总目录</a></p><p>原视频链接：<a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=2886s&ab_channel=GDC">https://www.youtube.com/watch?v=W3aieHjyNvw&amp;t=2886s&amp;ab_channel=GDC</a></p><h2 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a><a href="#ecs"></a>ECS</h2><h3 id="ecs-概述-ECS-概述"><a href="#ecs-概述-ECS-概述" class="headerlink" title="[](#ecs 概述)ECS 概述"></a>[](#ecs 概述)ECS 概述</h3><p>哈喽，大家好，这次的分享是关于《守望先锋》（译注：下文统一简称为 Overwatch）游戏架构设计和网络部分。老规矩，手机调成静音；离开时记得填写调查问卷；换下半藏，赶紧推车！（众笑）</p><p>我是 Tim Ford，是暴雪公司 Overwatch 开发团队老大。自从 2013 年夏季项目启动以来就在这个团队了。在那之前，我在《Titan》项目组，不过这次分享跟 Titan 没有半毛钱关系。（众笑）</p><p>这次分享的一些技术，是用来降低不停增长的代码库的复杂度（译注，代码复杂度的概念需要读者自行查阅）。为了达到这个目的我们遵循了一套严谨的架构。最后会通过讨论网络同步（netcode）这个本质很复杂的问题，来说明具体如何管理复杂性。</p><p>Overwatch 是一个近未来世界观的在线团队英雄射击游戏，它的主要是特点是英雄的多样性， 每个英雄都有自己的独门绝技。</p><p>Overwatch 使用了一个叫做 “实体组件系统” 的架构，接下来我会简称它为 ECS。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110454.jpg!webp" alt="[doc_image_4_w596_h333]"></p><p>ECS 不同于一些现成引擎中很流行的那种组件模型，而且与 90 年代后期到 21 世纪早期的经典 Actor 模式区别更大。我们团队对这些架构都有多年的经验，所以我们选择用 ECS 有点是 “这山望着那山高” 的意味。不过我们事先制作了一个原型，所以这个决定并不是一时冲动。</p><p>开发了 3 年多以后，我们才发现，原来 ECS 架构可以管理快速增长的代码复杂性。虽然我很乐意分享 ECS 的优点，但是要知道，我今天所讲的一切其实都是事后诸葛亮 。</p><p><strong>ECS</strong> 架构概述</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907122157.png" alt="[image-20210907122157540]"></p><p>ECS 架构看起来就是这样子的。先有个 World，它是 ** 系统 **（译注，这里的系统指的是 ECS 中的 S，不是一般意义上的系统，为了方便阅读，下文统称 System）和 ** 实体 **(Entity)的集合。而实体就是一个 ID，这个 ID 对应了 ** 组件 **(Component)的集合。组件用来存储游戏状态并且没有任何的行为(Behavior)。System 有行为但是没有状态。</p><p>这听起来可能挺让人惊讶的，因为组件没有函数而 System 没有任何字段。</p><p><strong>ECS</strong> 引擎用到的 System 和组件</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907122224.png" alt="image-20210907122223993"></p><p>图的左手边是以轮询顺序排列的 System 列表，右边是不同实体拥有的组件。在左边选择不同的 System 以后，就像弹钢琴一样，所有对应的组件会在右边高亮显示，我们管这叫组件元组（译注，元组 tuple，从后文来看，主要作用就是可以调用 Sibling 函数来获取同一个元组内的组件，有点虚拟分组的意思）。</p><p>System 遍历检查所有元组，并在其状态（State）上执行一些操作（也就是行为 Behavior）。记住组件不包含任何函数，它的状态都是裸存储的。</p><p>绝大多数的重要 System 都关注了不止一个组件，如你所见，这里的 Transform 组件就被很多 System 用到。</p><p>** 来自原型引擎里的一个 System 轮询 (tick) 的例子 **<br><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110555.jpg!webp" alt="doc_image_7_w601_h337"></p><p>这个是物理 System 的轮询函数，非常直截了当，就是一个内部物理引擎的定时更新。物理引擎可能是 Box2d 或者是 Domino（暴雪自有物理引擎）。执行完物理世界的模拟以后，就遍历元组集合。用 DynamicPhysicsComponent 组件里保存的 proxy 来取到底层的物理表示，并把它复制给 Transform 组件和 Contact 组件（译注：碰撞组件，后文会大量用到）。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110609.jpg!webp" alt="[doc_image_8_w602_h337]"></p><p>System 不知道实体到底是什么，它只关心组件集合的小切片(slice，译注：可以理解为特定子集合)，然后在这个切片上执行一组行为。有些实体有多达 30 个组件，而有些只有 2、3 个，System 不关心数量，它只关心执行操作行为的组件的子集。</p><p>像这个原型引擎里的例子，（指着上图 7 中）这个是玩家角色实体，可以做出很多很酷的行为，右边这些是玩家能够发射的子弹实体。</p><p>每个 System 在运行时，不知道也不关心这些实体是什么，它们只是在实体相关组件的子集上执行操作而已。</p><p><strong>Overwatch</strong> 里的 (ECS 架构的) 实现，就是这样子的。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907122313.png" alt="[image-20210907122313840]"></p><p>EntityAdmin 是个 World，存储了一个所有 System 的集合，和一个所有实体的哈希表。表键是实体的 ID。ID 是个 32 位无符号整形数，用来在实体管理器（Entity Array）上唯一标识这个实体。另一方面，每个实体也都存了这个实体 ID 和资源句柄（resource handle），后者是个可选字段，指向了实体对应的 Asset 资源（译注：这需要依赖暴雪的另一套专门的 Asset 管理系统），资源定义了实体。</p><p>组件 Component 是个基类，有几百个子类。每个子类组件都含有在 System 上执行 Behavior 时所需的成员变量。在这里多态唯一的用处就是重载 Create 和析构（Destructor）之类的生命周期管理函数。而其他能被继承组件类实例直接使用的，就只有一些用来方便地访问内部状态的 helper 函数了。但这些 helper 函数不是行为(译注：这里强调是为了遵循前面提到的原则：组件没有行为)，只是简单的访问器。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110640.jpg!webp" alt="[doc_image_10_w601_h338]"></p><p>EntityAdmin 的结尾部分会调用所有 System 的 Update。每个 System 都会做一些工作。上图 9 就是我们的使用方式，我们没有在固定的元组组件集合上执行操作，而是选择了一些 ** 基础 ** 组件来遍历，然后再由相应的行为去调用其他兄弟组件。所以你可以看到这里的操作只针对那些含有 Derp 和 Herp 组件的实体的元组执行。</p><p><strong>Overwatch</strong> 客户端的 System 和组件列表</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110658.jpg!webp" alt="[doc_image_11_w602_h338]"></p><p>这里有大概 46 不同的 System 和 103 个组件。这一页的炫酷动画是用来吸引你们看的（众笑）。</p><p>** 然后是服务器 **</p><p>你可以看到有些 System 执行需要很多组件，而有些 System 仅仅需要几个。理想情况下，我们尽量确保每个 System 都依赖很多组件去运行。把他们当成纯函数(译注，pure function，无副作用的函数)，而不改变（mutating）它们的状态，就可以做到这一点。我们的确有少量的 System 需要改变组件状态，这种情况下它们必须自己管理复杂性。</p><p>** 下面是个真实的 System 代码 **</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110719.jpg!webp" alt="[doc_image_13_w602_h338]"></p><p>这个 System 是用来管理玩家连接的，它负责我们所有游戏服务器上的强制下线（译注，AFK, Away From Keyboard，表示长时间没操作而被认为离线）功能。</p><p>这个 System 遍历所有的 Connection 组件（译注：这里不太合适直接翻译成“连接”），Connection 组件用来管理服务器上的玩家网络连接，是挂在代表玩家的实体上的。它可以是正在进行比赛的玩家、观战者或者其他玩家控制的角色。System 不知道也不关心这些细节，它的职责就是强制下线。</p><p>每一个 Connection 组件的元组包含了输入流 (InputStream) 和 Stats 组件（译注：看起来是用来统计战斗信息的）。我们从输入流组件读入你的操作，来确保你必须做点什么事情，例如键盘按键；并从 Stats 组件读取你在某种程度上对游戏的贡献。</p><p>你只要做这些操作就会不停重置 AFK 定时器，否则的话，我们就会通过存储在 Connection 组件上的网络连接句柄发消息给你的客户端，踢你下线。</p><p>System 上运行的实体必须拥有完整的元组才能使得这些行为能够正常工作。像我们游戏里的机器人实体就没有 Connection 组件和输入流组件，只有一个 Stats 组件，所以它就不会受到强制下线功能的影响。System 的行为依赖于完整集合的“切片”。坦率来说，我们也确实没必要浪费资源去让强制机器人下线。</p><h3 id="为什么不能直接用传统面向对象编程模型-为什么不能直接用传统面向对象编程模型？"><a href="#为什么不能直接用传统面向对象编程模型-为什么不能直接用传统面向对象编程模型？" class="headerlink" title="[](# 为什么不能直接用传统面向对象编程模型)为什么不能直接用传统面向对象编程模型？"></a>[](# 为什么不能直接用传统面向对象编程模型)为什么不能直接用传统面向对象编程模型？</h3><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110737.png!webp" alt="[image-20210907110737655]"></p><p>上面 System 的更新行为会带来了一个疑问：为什么不能使用传统的面向对象编程 (OOP) 的组件模型呢？例如在 Connection 组件里重载 Update 函数，不停地跟踪检测 AFK？</p><p>答案是，因为 Connection 组件会同时被多个 ** 行为 ** 所使用，包括：AFK 检查；能接收网络广播消息的已连接玩家列表；存储包括玩家名称在内的状态；存储玩家已解锁成就之类的状态。所以（如果用传统 OOP 方式的话）具体哪个行为应该放在组件的 Update 中调用？其余部分又应该放在哪里？</p><p>传统 OOP 中，一个类既是行为又是数据，但是 Connection 组件不是行为，它就只是状态。Connection 完全不符合 OOP 中的对象的概念，它在不同的 System 中、不同的时机下，意味着完全不同的事情。</p><h3 id="行为和状态分离的优势-行为和状态分离的优势"><a href="#行为和状态分离的优势-行为和状态分离的优势" class="headerlink" title="[](# 行为和状态分离的优势)行为和状态分离的优势"></a>[](# 行为和状态分离的优势)行为和状态分离的优势</h3><p>想象一下你家前院盛开的樱桃树吧，从主观上讲，这些树对于你、你们小区业委会主席、园丁、一只鸟、房产税官员和白蚁而言都是完全不同的。从描述这些树的状态上，不同的观察者会看见不同的行为。树是一个被不同的观察者区别对待的主体（subject）。</p><p>类比来说，玩家实体，或者更准确地说，Connection 组件，就是一个被不同 System 区别对待的主体。我们之前讨论过的管理玩家连接的 System，把 Connection 组件视为 AFK 踢下线的主体；连接实用程序 (ConnectUtility) 则把 Connection 组件看作是广播玩家网络消息的主体；在客户端上，用户界面 System 则把 Connection 组件当做记分板上带有玩家名字的弹出式 UI 元素主体。</p><p>Behavior 为什么要这么搞？结果看来，根据主体视角区分所有 Behavior，这样来描述一棵 ** 树 ** 的全部行为会更容易，这个道理同样也适用于 ** 游戏对象 **(game objects)。</p><h3 id="新的问题-新的问题"><a href="#新的问题-新的问题" class="headerlink" title="[](# 新的问题)新的问题"></a>[](# 新的问题)新的问题</h3><p>然而随着这个工业级强度的 ECS 架构的实现，我们遇到了新的问题。</p><p>首先我们纠结于之前定下的规矩：组件不能有函数；System 不能有状态。显而易见地，System 应该可以有一些状态的，对吧？一些从其他非 ECS 架构导入的遗留 System 都有成员变量，这有什么问题吗？举个例子，InputSystem, 你可以把玩家输入信息保存在 InputSystem 里，而其他 System 如果也需要感知按键是否被按下，只需要一个指向 InputSystem 的指针就能实现。</p><p>在单个组件里存储一个全局变量看起来很很愚蠢，因为你开发一个新的组件类型，不可能只实例化一次(译注：这里的意思是，如果实例化了多次，就会有多份全局变量的拷贝，明显不合理)，这一点无需证明。组件通常都是按照我们之前看见过的那种方式（译注：指的是通过 <code>ComponentItr&lt;&gt;</code> 函数模板那种方式）来迭代访问，如果某个组件在整个游戏里只有一个实例，那这样访问就会看起来比较怪异了。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110806.jpg!webp" alt="[doc_image_17_w602_h339]"></p><p>无论如何，这种方式撑了一阵子。我们在 System 里存储了一次性（one-off）的状态数据，然后提供了一个全局访问方式。从图 16 可以看到整个访问过程（译注：重点是 g_game-&gt;m_inputSystem 这一行）。</p><p>如果一个 System 可以调用另外一个 System 的话，对于编译时间来说就不太友好了，因为 System 需要互相包含（include）。假定我现在正在重构 InputSystem，想移动一些函数，修改头文件(译注：Client/System/Input/InputSystem.h)，那么所有依赖这个头文件去获取输入状态的 System 都需要被重新编译，这很烦人，还会有大量的耦合，因为 System 之间互相暴露了内部行为的实现。（译注：转载不注明出处，真的大丈夫吗？还把译者的名字都删除！声明：这篇文章是本人 kevinan 应 GAD 要求而翻译！）</p><p>从图 16 最下面可以看见我们有个 PostBuildPlayerCommand 函数，这个函数是 InputSystem 在这里的主要价值。如果我想在这个函数里增加一些新功能，那么 CommandSystem 就需要根据玩家的输入，填充一些额外的结构体信息发给服务器。那么我这个新功能应该加到 CommandSystem 里还是 PostBuildPlayerCommand 函数里呢？我正在 System 之间互相暴露内部实现吗？</p><p>随着系统的增长，选择在何处添加新的行为代码变得模棱两可。上面 CommandSystem 的行为填充了一些结构体，为什么要混在一起？又为什么要放到这里而不是别处？</p><p>无论如何，我们就这样凑合了好一阵子，直到死亡回放 (Killcam) 需求的出现。</p><h3 id="死亡回放系统带来的重构-singleton-组件-死亡回放系统带来的重构-Singleton-组件"><a href="#死亡回放系统带来的重构-singleton-组件-死亡回放系统带来的重构-Singleton-组件" class="headerlink" title="[](# 死亡回放系统带来的重构 - singleton 组件)死亡回放系统带来的重构 - Singleton 组件"></a>[](# 死亡回放系统带来的重构 - singleton 组件)死亡回放系统带来的重构 - Singleton 组件</h3><p>为了实现 Killcam，我们会有两个不同的、并行的游戏环境，一个用来进行实时游戏过程渲染，一个用来专门做 Killcam。我接下来会展示它们是如何实现的。</p><p>首先，也很直接，我会添加第二个全新的 ECS World，现在就有两个 World 了，一个是 liveGame(正常游戏)，一个是 replayGame 用来实现回放（Replay）。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907122413.png" alt="[image-20210907122413279]"></p><p>回放 (Replay) 的工作方式是这样的，服务器会下发大概 8 到 12 秒左右的网络游戏数据，接着客户端翻转 World，开始渲染 replayAdmin 这个 World 的信息到玩家屏幕上。然后转发网络游戏数据给 replayAdmin，假装这些数据真的是来自网络的。此时，所有的 System，所有的组件，所有的行为都不知道它们并没有被预测(predict，译注：后面才讲到的同步技术)，它们以为客户端就是实时运行在网络上的，像正常游戏过程一样。</p><p>听起来很酷吧？如果有人想要了解更多关于回放的技术，我建议你们明天去听一下 Phil Orwig 的分享，也是在这个房间，上午 11 点整。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110858.jpg!webp" alt="[doc_image_22_w602_h342]"></p><p>无论如何，到现在我们已经知道的是：首先，所有需要全局访问 System 的调用点（call sites）会突然出错(译注：Tim 思维太跳跃了，突然话锋一转，完全跟不上)；另外，不再只有唯一一个全局 EntityAdmin 了，现在有两个；System A 无法直接访问全局 System B，不知怎地，只能通过共享的 EntityAdmin 来访问了，这样很绕。</p><p>在 Killcam 之后，我们花了很长时间来回顾我们的编程模式的缺陷，包括：怪异的访问模式；编译周期太长；最危险的是内部系统的耦合。看起来我们有大麻烦了。</p><p>针对这些问题的最终解决方案，依赖于这样一个事实：开发一个只有唯一实例的组件其实没什么不对！根据这个原则，我们实现了一个 ** 单例（Singleton）组件。**</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907110920.jpg!webp" alt="[doc_image_23_w601_h338]"></p><p>这些组件属于单一的匿名实体，可以通过 EntityAdmin 直接访问。我们把 System 中的大部分状态都移到了单例中。</p><p>这里我要提一句，只需要被一个 System 访问的状态其实是很罕见的。后来在开发一个新 System 的过程中我们保持了这个习惯，如果发现这个系统需要依赖一些状态。就做一个单例来存储，几乎每一次都会发现其他一些 System 也同样需要这些状态，所以这里其实已经提前解决了前面架构里的耦合问题。</p><p>下面是一个单例输入的例子。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111020.jpg!webp" alt="[doc_image_24_w602_h338]"></p><p>全部按键信息都存在一个单例里面，只是我们把它从 InputSystem 中移出来了。任何 System 如果想知道按键是否按下，只需要随便拿一个组件来询问（那个单例）就行了。这样做以后，一些很麻烦的耦合问题消失了，我们也更加遵循 ECS 的架构哲学了：System 没有状态；组件不带行为。</p><p>按键并不是行为，掌管本地玩家移动的 Movement System 里有一个行为，用这个单例来预测本地玩家的移动。而 MovementStateSystem 里有个行为是把这些按键信息打包发到服务器（译注：按键对于不同的 System 就不是不同的主体）。</p><p>结果发现，单例模式的使用非常普遍，我们整个游戏里的 40% 组件都是单例的。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111033.jpg!webp" alt="[doc_image_25_w601_h338]"></p><p>一旦我们把某些 System 状态移到单例中，会把共享的 System 函数分解成 Utility（实用）函数，这些函数需要在那些单例上运行，这又有点耦合了，我们接下来会详细讨论。</p><p>改造后如图 22，InputSystem 依然存在（译注：然而并没有看到 InputSystem 在哪里），它负责从操作系统读取输入操作，填充 SingletonInput 的值，然后下游的其他 System 就可以得到同样的 Input 去做它们想做的。</p><p>像按键映射之类的事情就可以在单例里实现，就与 CommandSystem 解耦了。</p><p>我们把 PostBuildPlayerCommand 函数也挪到了 CommandSysem 里，本应如此，现在可以保证所有对玩家输入的命令（PlayerCommand）的修改都能且仅能在此处进行了。这些玩家命令是很重要的数据结构，将来会在网络上同步并用来模拟游戏过程。</p><p>在引入单例组件时，我们还不知道，我们其实正在打造的是一个解耦合、降低复杂度的开发模式。在这个例子中，CommandSystem 是唯一一处能够产生与玩家输入命令相关副作用的地方（译注：sideeffect，指当调用函数时，除了返回函数值之外，还对主调用函数产生附加影响，例如修改全局变量了）。</p><p>每个程序员都能轻易地了解玩家命令的变化，因为在一次 System 更新的同一时刻，只有这一处代码有可能产生变化。如果想添加针对玩家命令的修改代码，那也很明朗，只能在这个源文件中改，所有的模棱两可都消失了。</p><h3 id="共享行为-utility-函数-共享行为-Utility-函数"><a href="#共享行为-utility-函数-共享行为-Utility-函数" class="headerlink" title="[](# 共享行为 - utility 函数)共享行为 - Utility 函数"></a>[](# 共享行为 - utility 函数)共享行为 - Utility 函数</h3><p>现在讨论另外一个问题，与共享行为 (sharedbehavior) 有关。</p><p>共享行为一般出现在同一行为被多个 System 用到的时候。</p><p>有时，同一个主体的两个观察者，会对同一个行为感兴趣。回到前面樱花树的例子，你的小区业委会主席和园丁，可能都想知道这棵树会在春天到来的时候，掉落多少叶子。</p><p>根据这个输出可以做不同的处理，至少主席可能会冲你大喊大叫，园丁会老老实实回去干活，但是这里的 ** 行为 ** 是相同的。</p><p>举个例子，大量代码都会关心“敌对关系”，例如，实体 A 与实体 B 互相敌对吗？敌对关系是由 3 个可选组件共同决定的：filter bits，pet master 和 pet。filter bits 存储队伍编号（team index）；pet master 存储了它所拥有全部 pet 的唯一键；pet 一般用于像托比昂的炮台之类。</p><p>如果 2 个实体都没有 filter bits，那么它们就不是敌对的。所以对于两扇门来说，它们就不是敌对的，因为它们的 filter bits 组件没有队伍编号。</p><p>如果它们 (译注：2 个实体) 都在同一个队伍，那自然就不是敌对的，这很容易理解。</p><p>如果它们分别属于永远敌对的 2 个队伍，它们会同时检查自己身上和对方身上的 pet master 组件，确保每个 pet 都和对方是敌对关系。这也解决了一个问题：如果你跟每个人都是敌对的，那么当你建造一个炮台时，炮台会立马攻击你（译注：完全没理解为什么会这样）。确实会的，这是个 bug，我们修复了。（众笑）</p><p>如果你想检查一枚飞行中的炮弹的敌对关系，只需要回溯检查射出这枚炮弹的开火者就行了，很简单。</p><p>这个例子的实现，其实就是个函数调用，函数名是 CombatUtilityIsHostile，它接受 2 个实体作为参数，并返回 true 或者 false 来代表它们是否敌对。无数 System 都调用了这个函数。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111100.jpg!webp" alt="[doc_image_28_w601_h338]"></p><p>图 25 中就是调用了这个函数的 System，但是如你所见，只用到了 3 个组件，少得可怜，而且这 3 个组件对它们都是只读的。更重要的是，它们是纯数据，而且这些 System 绝不会修改里面的数据，仅仅是读。</p><p>再举一个用到这个函数的例子。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111113.jpg!webp" alt="[doc_image_29_w601_h338]"></p><p>作为一个例子，当用到共享行为的 Utility 函数时我们采用了不同的规则。</p><p>如果你想在多处调用一个 Utility 函数，那么这个函数就应该依赖很少的组件，而且不应该带副作用或者很少的副作用。如果你的 Utility 函数依赖很多组件，那就试着限制调用点的数量。</p><p>我们这里的例子叫做 CharacterMoveUtil，这个函数用来在游戏模拟过程中的每个 tick 里移动玩家位置。有两处调用点, 一处是在服务器上模拟执行玩家的输入命令，另一处是在客户端上预测玩家的输入。</p><h3 id="简化共享行为-简化共享行为"><a href="#简化共享行为-简化共享行为" class="headerlink" title="[](# 简化共享行为)简化共享行为"></a>[](# 简化共享行为)简化共享行为</h3><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111134.jpg!webp" alt="[doc_image_30_w602_h338]"></p><p>我们继续用 Utility 函数替换 System 间的函数调用，并把状态从 System 移到单例组件中。</p><p>如果你打算用一个共享的 Utility 函数替换 System 间的函数调用，是不可能自动地 (magically) 避免复杂性的，几乎都得做语句级的调整。</p><p>正如你可以把副作用都隐藏在那些公开访问的 System 函数后面一样，你也可以在 Utility 函数后面做同样的事。</p><p>如果你需要从好几处调用那些 Utility 函数，就会在整个游戏循环中引入很多严重的副作用。虽然是在函数调用后面发生的，看起来没那么明显，但这也是相当可怕的耦合。</p><p>如果本次分享只让你学到一点的话，那最好是：** 如果只有一个调用点，那么行为的复杂性就会很低，因为所有的副作用都限定到函数调用发生的地方了 **。</p><p>下面浏览一下我们用来减少这类耦合的技术。</p><h4 id="延迟执行-延迟执行"><a href="#延迟执行-延迟执行" class="headerlink" title="[](# 延迟执行)延迟执行"></a>[](# 延迟执行)延迟执行</h4><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111146.jpg!webp" alt="[doc_image_31_w602_h339]"></p><p>当你发现有些行为可能产生严重的副作用，又必须执行时，先问问你自己：这些代码，是必须 ** 现在 ** 就执行吗？</p><p>好的单例组件可以通过 “推迟”（Deferment）来解决 System 间耦合的问题。“推迟” 存储了行为所需状态，然后把副作用延后到当前帧里更好的时机再执行。</p><p>例如，代码里有好多调用点都要生成一个碰撞特效(impact effects)。</p><p>包括 hitscan(译注：直射，没有飞行时间)子弹；带飞行时间的可爆炸抛射物；查里娅的粒子光束，光束长得就像墙壁裂缝，而且在开火时需要保持接触目标；另外还有喷涂。</p><p>创建碰撞特效的副作用很大，因为你需要在屏幕上创建一个新的实体，这个实体可能间接地影响到生命周期、线程、场景管理和资源管理。</p><p>碰撞特效的生命周期，需要在屏幕渲染之前就开始，这意味着它们不需要在游戏模拟的中途显现，在不同的调用点都是如此。</p><p>下图 30 是用来创建碰撞特效的一小部分代码。基于 Transform（译注：变形，包括位移旋转和缩放）、碰撞类型、材质结构数据来做碰撞计算，而且还调用了 LOD、场景管理、优先级管理等，最终生成了所需的特效。</p><p>这些代码确保了像弹孔、焦痕持久特效不会很奇怪的叠在一起。例如，你用猎空的枪去射击一面墙，留下了一堆麻点，然后法老之鹰发出一枚火箭弹，在麻点上面造成了一个大面积焦痕。你肯定想删了那些麻点，要不然看起来会很丑，像是那种深度冲突（Z-Fighting）引起的闪烁。我可不想在到处去执行那个删除操作，最好能在一处搞定。</p><p>我得修改代码了，但是看上去好多啊，调用点一大堆，改完了以后每一处都需要测试。而且以后英雄越来越多，每个人都需要新的特效。然后我就到处复制粘贴这个函数的调用，没什么大不了的，不就是个函数调用嘛，又不是什么噩梦。（众笑）</p><p>其实这样做以后，会在每个调用点都产生副作用的。程序员就得花费更多脑力来记住这段代码是如何运作的，这就是代码复杂度所在，肯定是应该避免的。</p><p>于是我们有了 Contact 单例。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111202.jpg" alt="[doc_image_34_w602_h339]"></p><p>它包含了一个未决的碰撞记录的数组，每个记录都有足够的信息，来在本帧的晚些时候创建那个特效。如果你想要生成一个特效的时候，只需要添加一条新记录并填充数据就可以了。等运行到帧的后期，进行场景更新和准备渲染的时候，ResolveContactSystem 会遍历数组，根据 LOD 规则生成特效并互相叠加。这样的话，即使有严重的副作用，在每一帧也只是发生在一个调用点而已。</p><p>除了降低复杂度以外，“推迟”方案还有很多其他优点。数据和指令都缓存在本地，可以带来性能提升；你可以针对特效做性能预算了，例如你有 12 个 D.VA 同时在射墙，她们会带来数百个特效，你不用立即创建全部这些特效，你可以仅仅创建自己操纵的 D.VA 的特效就可以了，其他特效可以在后面的运算过程中分摊开来，平滑性能毛刺。这样做有很多好处，真的，你现在可以实现一些复杂的逻辑了。即使 ResolveContactSystem 需要执行多线程协作，来确定单个粒子效果的朝向， 现在也很容易做。“推迟”技术真的很酷。</p><p>Utility 函数，单例，推迟，这些都只是我们过去 3 年时间建立 ECS 架构的一小部分模式。除了限制 System 中不能有状态，组件里不能有行为以外，这些技术也规定了我们在 Overwatch 中如何解决问题。</p><p>遵守这些限制意味着你要用很多奇技淫巧来解决问题。不过，这些技术最终造就了一个可持续维护的、解耦合的、简洁的代码系统。它限制了你，它把你带到坑里，但这是个“成功之坑”。</p><p>学习了这些之后呢，咱们来聊聊真正的难题之一，以及 ECS 是如何简化它的。</p><h2 id="网络同步-网络同步"><a href="#网络同步-网络同步" class="headerlink" title="[](# 网络同步)网络同步"></a>[](# 网络同步)网络同步</h2><p>作为 gameplay(游戏玩法，机制)工程师，我们解决过的最重要的问题就是网络同步（netcode）。</p><p>这里先说下目标，是要开发一款快速响应（responsive）的网络对战动作游戏。为了实现快速响应，就必须针对玩家的操作做预测（predict，也可以说是预表现）。如果每个操作都要等服务器回包的话，就不可能有高响应性了。尽管因为一些混蛋玩家作弊所以不能信任客户端，但是已经 20 年了，这条 FPS 游戏真理没变过。详见原视频的 <a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=1370s">22:50</a> - <a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=1396s">23:16</a> 部分</p><p>游戏中有快速响应需求的操作包括：移动，技能，就我们而言还有带技能的武器，以及命中判定（hit registration）。</p><p>这里所有的操作都有统一的原则：玩家按下按键后必须立即能够看到响应。即使网络延迟很高时也必须是如此。</p><p>像我这页 PPT 中演示的那样，ping 值已经 250ms 了，我所有的操作也都是立即得到反馈的，“看上去”很完美，一点延迟都没有。</p><p>然而呢，带预测的客户端，服务器的验证和网络延迟就会带来副作用：预测错误（misprediction，或者说预测失败）了。预测错误的主要症状就一点，会使得你没能成功执行 “你认为你已经做出的” 操作。</p><h3 id="问题提出-问题提出"><a href="#问题提出-问题提出" class="headerlink" title="[](# 问题提出)问题提出"></a>[](# 问题提出)问题提出</h3><p>虽然服务器需要纠正你的操作，但代价并不会是操作延迟。我们会用”确定性”（Determinism）来减少预测错误发生的概率，下面是具体的做法。</p><p>前提条件不变，PING 值还是 250 毫秒。我认为我跳起来了，但是服务器不这么看，我被猛拉回原地，而且被冻住了（冰冻是英雄 Mei 的技能之一）。这里（原视频<a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=1410s">23:30</a> - <a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=1430s">23:50</a>）你甚至可以看到整个预测的工作过程。预测过程开始时，试图把我们移到空中，甚至大猩猩跳跃技能的 CD 都已经进入冷却了，这是对的，我们不希望预测准确率仅仅是十之八九。所以我们希望尽可能的快速响应，</p><p>如果你碰巧在斯里兰卡玩这个游戏，而且又被 Mei 冻住了，那么就有可能会预测错误。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111259.jpg!webp" alt="[doc_image_39_w602_h340]"></p><p>下面我会首先给出一些准则，然后讨论一下这个崭新的技术是如何利用 ECS 来减少复杂度的。</p><p>这里不会涉及到通用的数据复制技术、远端实体插值（remote entity interpolation）或者是向后缓和（backwardsreconciliation）技术细节。</p><p>我们完全是站在巨人的肩膀上，使用了一些其他文献中提过的技术而已。后面的幻灯片会假定大家对那些技术都已经很熟悉了。</p><h3 id="确定性-determinism-确定性-Determinism"><a href="#确定性-determinism-确定性-Determinism" class="headerlink" title="[](# 确定性 determinism)确定性(Determinism)"></a>[](# 确定性 determinism)确定性(Determinism)</h3><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111925.jpg!webp" alt="[doc_image_40_w601_h337]"></p><p>确定性模拟技术依赖于时钟的同步，固定的更新周期和量化。服务器和客户端都运行在这个保持同步的时钟和量化值之上。时间被量化成 command frame，我们称之为“命令帧”。每个命令帧都是固定的 16 毫秒，不过在电竞比赛时是 7 毫秒。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907111918.jpg!webp" alt="[doc_image_41_w602_h339]"></p><p>模拟过程的频率是固定的，所以需要把计算机时钟循环转换为固定的命令帧序号。我们使用了一个循环累加器来处理帧号的增长。</p><p>在我们的 ECS 框架内，任何需要进行预表现、或者基于玩家的输入模拟结果的 System，都不会使用 Update，而是用 UpdateFixed。UpdateFixed 会在每个固定的命令帧调用。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907112549.gif" alt="[重制版说明：因为是 Gif 图，所以会有卡顿，原视频是一直流畅往前运行的，希望不要引起误解]"></p><p>重制版说明：因为是 Gif 图，所以会有卡顿，原视频是一直流畅往前运行的，希望不要引起误解</p><p>假定输出流是稳定的，那么客户端的始终总是会超前于服务器的，超前了大概半个 RTT 加上一个缓存帧的时长。这里的 RTT 就是 PING 值。上图 39 的例子中，我们的 RTT 是 160 毫秒，一半就是 80 毫秒，再加上 1 个缓存帧时长（上图中为 1 帧），我们每帧是 16 毫秒，全加起来就是客户端相对于服务器的提前量。</p><p>图中的垂直线代表每一个处理中的帧。客户端开始模拟并把第 19 帧的输入上报给服务器，过一段时间（基本上是半个 RTT 加上缓冲时间）以后，服务器才开始模拟这一帧。这就是我为什么要说客户端永远是领先于服务器的。</p><p>正因为客户端是一股脑的尽快接受玩家输入，尽可能地贴近现在时刻，如果还需要等待服务器回包才能响应的话，那看起来就太慢了，会让游戏变得卡顿。图 39 中的缓冲区，你肯定希望尽可能的小（译注：缓冲越小，模拟时就越接近当前时刻），顺便说一句，游戏运行的频率是 60 赫兹，我这里播放动画的速度是正常速度的百分之一（译注：这也是为了让观众看得更清晰、明白）。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907125604.webp" alt="[v2-8a54474393ea5c1bd9a73fc087457ab4_b]"></p><p>客户端的预测 System 读取当前输入，然后模拟猎空的移动过程。我这里是用游戏摇杆来表示猎空的输入操作并上报的。这里的（第 14 帧）猎空是我当前时刻模拟出来的运动状态，经过完整的 RTT 加上缓冲事件，最终猎空会从服务器上回到客户端（译注：这里最好结合演讲视频，静态的文章无法表达到位）。这里回来的是经过服务器验证的运动状态快照。服务器模拟权威带来的副作用就是验证需要额外的半个 RTT 时间才能回到客户端。</p><p>那么这里客户端为什么要用一个环形缓冲（ring buffer）来记录历史运动轨迹呢？这是为了方便与服务器返回的结果进行对比。经过比较，如果与服务器模拟结果相同，那么客户端会开开心心地继续处理下一个输入。如果结果不一致，那就是一个“预测错误”，这时就需要“和解”（reconcile）了。</p><p>如果想简单，那就直接用服务器下发的结果覆盖客户端就行了，但是这个结果已经是“旧”（相对于当前时刻的输入来讲）的了，因为服务器的回包一般都是几百毫秒之前的了。</p><p>除了上面那个环形缓冲以外，我们还有另一个环形缓冲用来存储玩家的输入操作。因为处理移动的代码是确定性的，一旦玩家开始进入他想要进入到移动状态，想要重现这个过程也是很容易的。所以这里我们的处理方式就是，一旦从服务器回包发现预测失败，我们把你的全部输入都重播一遍直至追上当前时刻。如下图 41 中的第 17 帧所示，客户端认为猎空正在跑路，而服务器指出，你已经被晕住了，有可能是受到了麦克雷的闪光弹的攻击。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113032.jpg!webp" alt="[doc_image_44_w602_h337]"></p><p>接下来的流程是，当客户端收到描述角色状态的数据包时，我们基本上就得把移动状态及时恢复到最近一次经过服务器验证过状态上去，而且必须重新计算之后所有的输入操作，直至追上当前时刻（第 25 帧)。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113051.jpg!webp" alt="[doc_image_45_w602_h338]"></p><p>现在客户端进行到第 27 帧（上图）了，这时我们收到了服务器上第 17 帧的回包。一旦重新同步（译注：注意下图 41 中客户端猎空的状态全都更正为 “晕” 了）以后，就相当于回退到了“帧同步”（lockstep）算法了。</p><p>我们肯定知道我们到底被晕了多久。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113118.jpg!webp" alt="[doc_image_46_w601_h338]"></p><p>到了下图第 33 帧以后，客户端就知道已经不再是晕住的状态了，而服务器上也正在模拟相同的情况。不再有奇怪的同步追赶问题了。一旦进入这个移动状态，就可以重发玩家当前时刻的操作输入了。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907122656.png!webp" alt="[image-20210907122656762]"></p><p>然而，客户端网络并不保证如此稳定，时有丢包发生。我们游戏里的输入都是通过定制化的可靠 UDP 实现。所以客户端的输入包常常无法到达服务器，也就是丢包。服务器又试图保持了一个小小的、保存未模拟输入的缓冲区，但是让它尽量的小，以保证游戏操作的流畅。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113243.jpg!webp" alt="[doc_image_48_w602_h340]"></p><p>一旦这个缓冲区是空的，服务器只能根据你最后一次输入去“猜测”。等到真正的输入到达时，它会试着“缓和”，确保不会弄丢你的任何操作，但是也会有预测错误。</p><p>下面是见证奇迹的时刻。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113335.jpg!webp" alt="[doc_image_49_w602_h339]"></p><p>上图可以看到，已经丢了一些来自客户端的包，服务器意识到以后，就会复制先前的输入操作来就行预测，一边祈祷希望预测正确，一边发包告诉客户端：“嘿哥们，丢包了，不太对劲哦”。接下来发生的就更奇怪的了，客户端会进行时间膨胀，比约定的帧率更快地进行模拟。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113353.jpg!webp" alt="[doc_image_50_w601_h337]"></p><p>这个例子里，约定好的帧速是 16 毫秒，客户端就会假装现在帧速是 15.2 毫秒，它想要更加提前。结果就是，这些输入来的越来越快。服务器上缓冲区也会跟着变大，这就是为了在尽量不浪费的情况下，度过（丢包的）难关。</p><p>这种技术运转良好，尤其是在经常抖动的互联网环境下，丢包和 PING 都不稳定。即使你是在国际空间站里玩这个游戏，也是可以的。所以我想这个方案真的很 NB。</p><p>现在，各位都记个笔记吧，这里收到消息，现在开始放大时间刻度，注意我们是真的加速轮询了，你可以看见图中右边的坡越来越平坦了。它比以前更加快速地上报输入。同时服务器上的缓冲也越来越大了，可以容忍更多地丢包，如果真的发生丢包也有可能在缓冲期间补上。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113452.jpg!webp" alt="[doc_image_51_w602_h339]"></p><p>doc_image_51_w602_h339</p><p>一旦服务器发现，你现在的网络恢复健康了，它就会发消息给你说：“嘿哥们，现在没事了”。而客户端会做相反的事情：它会缩小时间刻度，以更慢的速度发包。同时服务器会减小缓冲区的尺寸。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113506.jpg!webp" alt="[doc_image_52_w601_h338]"></p><p>doc_image_52_w601_h338</p><p>如果这个过程持续发生，那目标就会是是不要超过承受极限，并通过输入冗余来使得预测错误最小化。</p><p>温馨提示：（原视频的 <a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=1850s">30:50</a> - <a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=1916s">31:56</a> 体现了客户端时间膨胀和服务端缓冲区变化全过程）</p><p>早些时候我有提到过，服务器一旦饥饿，就会复制最后一次输入操作，对吧？一旦客户端赶上来了，就不会再复制输入了，这样会有因为丢包而被忽略的风险。解决方法是，客户端维持一个输入操作的滑动窗口。这项技术从《雷神世界》开始就有了。</p><p>我们不是仅仅发送当前第 19 帧的输入，而是把从最后一次被服务器确认的运动状态到现在的全部输入都发送过去。上面的例子可以看出，最后一次从服务器来的确认是第 4 帧。而我们刚刚模拟到了第 19 帧。我们会把每一帧的每一个输入都打包成为一个数据包。玩家一般顶多每 1/60 秒才会有一次操作，所以压缩后数据量其实不大。一般你按住 “向前” 按钮之前，很可能是已经在 “前进” 了。</p><p>结果就是，即使发生丢包，下一个数据包到达时依然会有全部的输入操作，这会在你真正模拟以前，就填充上所有因为丢包而出现的空洞。所以这个反馈循环的过程和可增长的缓冲区大小，以及滑动窗口，使得你不会因为丢包而损失什么。所以即使丢包也不会出现预测错误。</p><p>接下来会再次给你展示动画过程，这一次是双倍速，是正常速度的 1/50 了。</p><p>这里有全部不稳定因素：网络 PING 值抖动，有丢包，客户端时间刻度放大，输入窗口填充了全部漏洞，有预测失败，有服务器纠正。我们它们都合在一起播放给你看。</p><h3 id="战斗系统相关-战斗系统相关"><a href="#战斗系统相关-战斗系统相关" class="headerlink" title="[](# 战斗系统相关)战斗系统相关"></a>[](# 战斗系统相关)战斗系统相关</h3><p>接下来的议题，我不想讲太多细节，因为这是 Dan Reid 的分享的主题(译注，已经翻译就是《守望先锋》中网络脚本化的武器和技能系统一文)，因为这是开幕式的一部分，所以强烈推荐各位听一下，真的很棒。还是在这个房间，我讲完了就开始。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113546.jpg!webp" alt="[doc_image_54_w601_h338]"></p><p>doc_image_54_w601_h338</p><p>所有的技能都是用暴雪自有指令式脚本语言 State 开发的。脚本系统的一大优点就是它可以在前后穿越时空。在客户端预测，然后服务器验证，就像之前的例子里面的移动操作，我们可以把你回滚然后重播所有输入。技能也使用了与移动相同的前后滚原则，先回退到最后一次经过验证的快照的状态，然后重播输入直到当前时刻。</p><p>大家肯定还记得这个例子，就是猎空被晕导致的服务器纠正过程，技能的处理过程是相同的。客户端和服务器都会模拟技能执行的确定性过程，客户端领先于服务器，所以一般是客户端先模拟，服务器稍后跟进。客户端处理预测错误的方式是，先根据服务器快照回滚，然后再前滚（roll forth），就像这样幻灯演示的动画过程那样。这里演示的是死神的幽灵形态。图 45 中的这些方块（译注：State 中的 State）代表了幽灵形态，有了这些方块我就可以很自信的播放很酷的特效和动画了。</p><p>幽灵形态结束后就会关闭这些方块。在同一帧中这些小动画会展示出 State 的关闭过程。紧接着就是幽灵形态的出现，不久以后我们就会得到来自服务器的消息：“嗨，我预测的幽灵形态的过程已经告诉你了，所以你赶紧倒退回去，把这些 State 都打开，然后咱们再重新模拟全部输入，把这些 State 都关了”。这基本上就是每次服务器下发更新时回滚和前滚的过程了。</p><p>能预测移动很酷，这意味着可以预测每个技能，我们也确实这样做了，同样，对于武器或者其他的模块，我们也可以这么做。</p><h4 id="命中判定的预测和确认-命中判定的预测和确认"><a href="#命中判定的预测和确认-命中判定的预测和确认" class="headerlink" title="[](# 命中判定的预测和确认)命中判定的预测和确认"></a>[](# 命中判定的预测和确认)命中判定的预测和确认</h4><p>现在讨论一下命中判定的预测和确认。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113605.jpg!webp" alt="[doc_image_55_w601_h337]"></p><p>doc_image_55_w601_h337</p><p>ECS 处理这个其实很方便，还记得吗，实体如果拥有行为所需的组件元组，它就会是这个行为的主体。如果你的实体是敌对的（还记得我们之前讲的敌对性检查吧）而且你有一个 ModifyHealthQueue 组件，你就可以被别的玩家击中，这都受制于“命中判定”。</p><p>这两个组件，一个是用来检查敌对性的，一个是 ModifyHealthQueue。ModifyHealthQueue 是服务器记录的你身上的全部伤害和治疗。与单例 Contact 类似，也是延迟计算的，而且有多个调用点，这就是最大的副作用。延迟计算是因为不想在抛射物模拟途中，立即生成一大堆特效，我们选择延后。</p><p>顺便说一句，伤害，也完全不会在客户端预测，因为它们全都是骗子。</p><p>然而命中判定却是在客户端处理的。所以，如果你有一个 MovementState 组件，而且是一个不会被本地玩家操纵的 remote 对象，那你会被运动 System 经过插值（interpolate）运算来重新定位。标准插值是发生在最后一次收到的两个 MovementState 之间的，这项技术自从《Quake》时代就有了。</p><p>System 根本不在乎你是一个移动平台、炮台、门还是法老之鹰，你只需要拥有一个 MovementState 组件就够了，MovementState 组件还要负责存储环形缓冲区，还记得环形缓冲嘛？之前用来保存那些猎空小人的位置的。</p><p>有了 MovementState 组件，服务器在计算命中以前，就会把你回滚到攻击者上报时你所在的那一帧，这就是向后缓和（backwards reconcilation）。这个回滚过程与 ModifyHealthQueue 无关，只是为了判断是否击中目标，当判定击中时 ModifyHealthQueue 才开始工作，来决定了是否接受伤害。我们还需要倒回门、平台、车的状态，如果子弹被挡住了的话，就无所谓了。一般来说如果你是敌对的，而且有 MovementState 组件，你就会被倒回，而且可能会受伤。</p><p>被倒回（rewind）是被一组 Utility 函数操纵的行为；而受伤是 MovementState 组件被延迟处理时发生的另外一个行为。这两种行为独立开来，各自发生在各自的组件切片上。</p><p>射击过程有点抽象，我这里会分解一下。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113646.jpg!webp" alt="[doc_image_56_w601_h338]"></p><p>doc_image_56_w601_h338</p><p>图 47 中的框是每一个实体的逻辑边界（bounding volumes），可能有些不太明显，图片中央往左一点有一个茶色透明的框，就是逻辑边界。逻辑边界基本上就是代表了这个源氏的实时快照的并集。所以源氏周围的逻辑边界就代表了过去半秒钟这个角色的全部运动（的最大范围）。如果我现在沿着准星方向射击，在倒回这个角色以前，会首先与这个边界相交，因为基于我的 PING 值，它有可能在边界内的任意一处位置。</p><p>这个例子里，如果我沿着这个方向射击，那只需要单独倒回安娜即可，因为子弹只和她的边界相交了。不需要同时倒回大锤和他的能量盾或者车，以及后面的门。</p><p>射击如同移动一样，也可能会有预测失败。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907113705.jpg!webp" alt="[doc_image_57_w602_h336]"></p><p>doc_image_57_w602_h336</p><p>这里的绿色人偶是死神的客户端视角，黄色是服务器视角。这些绿色的小点点是客户端认为它的子弹击中的位置。可以看见绿色的细线是子弹经过的路径，但服务器在校验的时候，这个蓝紫色的半球才代表实际命中的位置。</p><p>这完全是个人为制造的例子，确定型模拟过程是很可靠的，为了重现射击过程中的预测失败，我把我的丢包率设置为 60%，然后足足射了这个混蛋 20 分钟才成功重现(众笑)。</p><p>这里我还得提一句，模拟过程如此精确，要归功于我们的 QA 团队的同事。他们从不接受 “NO” 作为答案，而且因为市面上其他游戏都不会把命中判定的预测精确度做到这个水平，所以我们的 QA 小伙伴们根本不相信我，也不在乎我。只是不停地提 bug 单，而且是越来越多的 bug 单，而每一次当我们去检查是否真的有 bug 时，结果是每次都真的有。这里要对他们表示深深的感谢，有了他们的工作才使得我们能做出如此伟大的产品。</p><p>如果你的 PING 值特别高，命中判定就会失效。</p><p>一旦 PING 值超过 220 毫秒，我们就会延后一些命中效果，也不会再去预测了，直接等服务器回包确认。之所以这么做的原因是，客户端上本来就做了外插值（extrapolate），不想把目标倒回那么远。不想让受害者觉得他们拼命跑到墙后面找掩护，结果还是被回拉、受伤。所以加了一层保护。这倒回外插后一段时间内的行为。下面的视频会演示这个过程（译注：强烈建议看视频<a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=2380s">39:40</a> - <a href="https://www.youtube.com/watch?v=W3aieHjyNvw&t=2440s">40:40</a>）。</p><p>PING 为 0 的时候，对弹道碰撞做了预测，而击中点和血条没有预测，要等服务器回包才渲染。</p><p>当 PING 达到 300 毫秒的时候，碰撞都不预测了，因为射击目标正在做快读的外插，他实际上根本没在这里，这里我们用了 DR（Dead Reckoning）导航推测算法，虽然很接近，但是他真没在那里。死神左右来回晃动时就会出现这种情况，外插时完全无法正确预测。这里我们不会照顾你的感受，你的网络太差了。</p><p>最后这个视频，PING 达到 1 秒的时候，尤为明显。死神的移动方式不变，还会有外插。顺便提一句，甚至 PING 已经是 1 秒钟那么慢了，客户端的所有操作都还是能够立即预测、响应的，只不过大部分都是错的而已。其实我应该放大招的（午时已到），肯定能弄死他。</p><p>下面讲下其他预测失败的例子，PING 值还是不怎么好，150 毫秒。这种条件下，无论何时遇到运动预测失败，都会错误的预测命中。下面用慢动作展现一下。</p><p>看，都已经飙血了，但是却没看见血条，也没看见弹坑，所以对于弹道碰撞的预测来讲就是错误的。服务器拒绝了，这不是一次合法的命中。碰撞效果预测失败的原因就是 “冰墙” 立起来了。你 “以为” 自己开火时还站在地上，但是服务器模拟时，你已经被冰墙升到了空中，就是这个行为导致预测失败的。</p><p>当我们修复这些微小的命中预测错误时，发现大部分情况都能通过与服务器就位置问题达成一致来消除，所以我们花了很多时间来对齐位置。</p><p>下面是与运动相关的预测失败的例子，同时也与游戏玩法有关。</p><p>PING 值还是 150 毫秒，你想射中这个死神，但是他处于幽灵形态，箭头碰到他时，客户端会预测说应该有血飚出来，但没有弹坑（hit pit），也没有血条，我们根本没击中他，因为它已经先进入幽灵状态了。</p><p>这种例子里，虽然大部分时间都会优先满足进攻者，但除非受害者做了什么事情缓和（mitigate）了这次进攻。在这个例子里，死神的幽灵形态会给他 3 秒钟的无敌时间。无论如何，我们没有真的打到死神。</p><p>让我从哲学角度想象一下，你就是那个死神，你进入了幽灵状态，但事实上服务器告诉你所有特效开始播放了，然后你却死掉了，你很快就会跑到论坛上去（抱怨自己已经进入幽灵形态却还是死了）。</p><h2 id="总结-总结"><a href="#总结-总结" class="headerlink" title="[](# 总结)总结"></a>[](# 总结)总结</h2><p>ECS 简化了网络同步问题。网络同步代码中用到的 System，知道自己何时被用于玩家身上，很简单直接，基本上如果一个实体被一个带有 Connection 组件的东西控制了，它就是一个玩家。</p><p>System 也知道哪些目标需要被倒回到进攻者时刻的那一帧上，任何包含 MovementState 组件的实体都会被倒回。</p><p>实体与组件之间的内在关联主要行为是 MovementState 可以在时间线上被取消。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907114208.jpg!webp" alt="[doc_image_62_w602_h339]"></p><p>doc_image_62_w602_h339</p><p>上图 52 是 System 和组件的全景图，其中只有少数几个与网络同步行为有关。而这就是我们已知最复杂的问题了。System 中有两个是 NetworkEvent 和 NetworkMessage，是网络同步模块的核心组成部分，参与了接收输入和发送输出这样的典型网络行为。</p><p>还有另外几个 System，一只手就数得过来：InterpolateMovement，Weapons，State，MovementState，我特别想删了 MovementState，因为我不喜欢它。所以呢，实际上网络同步模块中，只有 3 个 System 是与 gameplay 有关的，其中用到的组件就是右边高亮列出的，也只有组件对于网络同步模块是只读的。真正修改了数据的就是像 ModifyHealthQueue，因为对敌人造成的伤害是真实的。</p><p>现在回头看一下，用了 ECS 这么多年后，都学到了哪些知识与心得。</p><p>我有点希望 System 和 Utility 都能回到最早那个 ECS 操作元祖的权威例程的用法，做法有点特殊，我们只遍历一个组件就够了，再通过它访问所有兄弟组件。对于真正复杂的组件访问元组模型，你必须知道确切的访问对象才行。如果有个行为需要一个含有 40 个组件的元组，那可能是因为你的系统设计过于复杂了，元组之间有冲突。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907114317.jpg!webp" alt="[doc_image_64_w601_h338]"></p><p>doc_image_64_w601_h338</p><p>元组另一个很酷的副作用是，你掌握了关于什么 System 能访问什么状态的先验知识，那么回到我们用到元组的那个原型引擎当中，就可以知道 2 或 3 个 System 可以操作不同的组件集合。因为根据元组的定义就可以知道他们的用途。这里设计的非常容易扩展。就像之前那个弹钢琴的动画一样，不过可以看到多个 System 同时点亮，只因为它们操纵的组件集合是不同的。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907114329.jpg!webp" alt="[doc_image_65_w602_h339]"></p><p>doc_image_65_w602_h339</p><p>由于已经知道组件读写的优先级，System 的轮询可以做到多线程处理 gameplay 代码。这里要提一句，Transform 组件依然很受欢迎，但只有为数不多的几个 System 会真正修改它，大部分 System 都是对它只读。所以当你定义元组时，可以把组件标记上 “只读” 属性，这就意味着，即使有多个 System 都操作对该组件，但都是只读，可以并行处理。</p><p>实体生命周期管理需要一些技巧，尤其是在一帧的中间创建出来的那些。在早期，我们推迟了创建和销毁行为，当你说“嘿我想要创建一个实体时”，实际上是在那一帧结束时才完成的。事实证明，推迟销毁一点问题都没有，而推迟创建却有一大堆副作用。尤其是当你在 System A 中申请创建一个新的实体，然后在 System B 中使用，这时如果你推迟了创建过程，你就要隔一帧才能使用。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907114349.jpg!webp" alt="[doc_image_66_w601_h337]"></p><p>doc_image_66_w601_h337</p><p>这有点不爽。这也增加了很多内部复杂性(译注：看到这里，复杂性都是一些潜规则，需要花脑力去记住的 hardcode)，我们想修改掉这部分代码，使它可以在一帧的中途创建好，这样就可以马上使用了。</p><p>我们在游戏发布之后才做了这些改动，实在很恐怖。这个补丁打在了 1.2 或者 1.3 版本，上线那天晚上我都是通宵的。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907114401.jpg!webp" alt="[doc_image_67_w601_h339]"></p><p>doc_image_67_w601_h339</p><p>我们大概花了 1 年半的时间来制定 ECS 的使用准则，就像之前那个权威的例子，但是我们需要改造一些现有的代码使之能够适应新的架构。这些准则包括：</p><ul><li>  组件没有函数；</li><li>  System 没有状态；</li><li>  共享代码要放到 Utils 里；</li><li>  组件里复杂的副作用要通过队列的方式推迟处理，尤其是单例组件；</li><li>  System 不能调用其他 System 的函数，即使是我们自己的取名 System 也不行，这个 System 几年之前暴雪分享过的。</li></ul><p>** 仍然有大量代码不符合这个规范 **，所以它们是复杂度和维护工作的主要来源，就一点也不奇怪了。通过检视代码变更数量或者说 bug 数量，你就能发现这一点。</p><p>所以，如果你有什么遗留代码而且无法融入 ECS 规范的话，就绝对不应该使用。保持子系统整洁，不用创建任何代理组件去对它们进行封装。</p><p>不同的系统设计是用来解决问题的不同方法。</p><p>ECS 是一个集成大量 System 的工具，不合适的系统设计原则就不应该被采用。</p><p>ECS 的设计目的是用来把大量的模块进行集成并解耦，很多 System 及其依赖的组件都是冰山形状的。</p><p>冰山型组件对其他 ECS 的 System 暴露的表面很小，但它们内部其实有大量的状态、代理或者数据结构是 ECS 层无法访问的。</p><p>在线程模型中这些冰山的体型相当明显，大部分 ECS 的工作，例如更新 System，都是发生在主线程 (图 58 顶部) 上的。我们也用到了大量的多线程技术，像 fork 和 join。这个例子里，有角色发射了大量的抛射物，然后脚本 System 说我们需要生成一些抛射物，就创建了几个工作线程来干活。还有这里是 ResolvedContactSystem 想要创建一些碰撞特效，这里花费了几个工作线程去做这项工作。</p><p>抛射物模拟的幕后工作已经被隔离，而且对上层 ECS 是不可见的，这样很好。</p><p>另外一个很酷的例子就是 AIPetDataSystem，很好的应用了 fork 和 join 模式，在 ECS 层面，只有一点点耦合，可能是说“嗨，这是一扇可破坏的门，你可能需要在这些区域重建路径”，但是幕后工作其实很多，像获取所有三角形，渲染并裁减，这些都与 ECS 无关，我们也不应该把 ECS 置于那些问题领域，应该自己想办法。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907114450.jpg!webp" alt="[doc_image_69_w602_h338]"></p><p>doc_image_69_w602_h338</p><p>这里的视频演示的是 PathValidationSystem，路径（Path）就是全部这些蓝色色块，AI 可以行走于其表面上。其实路径并不只用于 AI，也用在很多英雄的技能上。所以就需要在服务器和客户端之间对这些路径进行数据同步。</p><p>视频里的禅亚塔将会破坏这里的这些物品，你会看见破坏后的物体掉落到表面下方。然后那里的门会打开我们会把那些表面粘在一起。PathValidationSystem 只需要说：“嗨，三角形有变化”。然后冰山背后就会用全部数据重建路径。</p><p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907114436.jpg!webp" alt="[doc_image_70_w602_h340]"></p><p>doc_image_70_w602_h340</p><p>现在准备结束今天的分享了。</p><p>ECS 是 Overwatch 的粘合剂，它很酷，因为它可以帮你用最小的耦合来集成大量分散的系统。如果你打算用 ECS 定义你的规范，实际上无论你想用什么架构来快速定义你的规范，应该都是只有少数程序员需要接触物理系统代码、脚本引擎或者音频库。但是每个人都应该能够用到胶水代码，一起集成系统。</p><p>实施这些限制，就能够马到成功。</p><p>事实证明，网络同步真的很复杂，所以必须尽可能的与引擎其余部分解耦，ECS 是解决这个问题的好办法。</p><p>最后在接受提问以前，我想感谢我们团队成员，尤其是 gameplay 工程师，大家花了 3 年时间创造了如此美妙的艺术品。我们共同努力，创建原则，架构不断进化，结果也是有目共睹的。</p><hr><blockquote><p>参考链接：<a href="https://www.lfzxb.top/ow-gdc-gameplay-architecture-and-netcode/">《守望先锋》架构设计和网络同步</a></p></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity 性能优化</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2022-01-21T07:00:29.000Z</published>
    <updated>2025-11-05T13:53:39.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开始进行 Unity 性能优化的工作，主要分为三类：CPU、GPU 和内存。<br>CPU 的优化又分为渲染和脚本，本文将着重于脚本优化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h1 id="Unity-性能优化-–-脚本篇"><a href="#Unity-性能优化-–-脚本篇" class="headerlink" title="Unity 性能优化 – 脚本篇"></a>Unity 性能优化 – 脚本篇</h1><p>一般来说，优化必须要知道性能热点在哪里，而知道性能热点则需要在 ** 目标设备 ** 去进行深度的 <strong>profile</strong>。如果不进行 profile，而是靠臆测去进行优化，往往会事倍功半，甚至适得其反。</p><p>本文所讲述的是已经经过<a href="https://github.com/iWoz/UnityPerformanceTest">验证的</a>，通用的优化方法和思路，可以为大家节约一些 profile 时间。以下将从 Unity API、C#、Lua、数据结构和算法等方面来详细阐述优化建议。</p><h2 id="Unity-API"><a href="#Unity-API" class="headerlink" title="Unity API"></a>Unity API</h2><h4 id="GameObject-GetComponent"><a href="#GameObject-GetComponent" class="headerlink" title="GameObject.GetComponent"></a>GameObject.GetComponent</h4><p>Unity 是基于组合的开发方式，所以 <code>GetComponent</code> 是一个高频使用的函数。每次调用 <code>GetComponent</code> 时，Unity 都要去遍历所有的组件来找到目标组件。每次都去查找是不必要的耗费，我们可以通过缓存的方式来避免这些不必要的开销。</p><p>其中 <code>Transform</code> 是我们用到最多的组件，GameObject 内部提供了一个 <code>.transform</code> 来获取此组件。然而经过测试（2017.2.1p1）我们发现缓存的效率依然是最高的。所以 ** 若要经常访问一个特定组件，将其缓存 **。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Transform m_transform;</span><br><span class="line">void Awake() &#123;</span><br><span class="line">    m_transform = transform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Start () &#123;</span><br><span class="line">    // 缓存的 m_transform，耗时 49ms</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">        m_transform.position = Vector3.one;</span><br><span class="line"></span><br><span class="line">    // 内部属性 transform，耗时 77ms</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">        transform.position = Vector3.one;</span><br><span class="line"></span><br><span class="line">    // 采用 GetComponent，耗时 102ms</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">        GetComponent&lt;Transform&gt;().position = Vector3.one;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="GameObject-Find"><a href="#GameObject-Find" class="headerlink" title="GameObject.Find"></a>GameObject.Find</h4><p><code>GameObject.Find</code> 会遍历当前所有的 GameObject 来返回名字相符的对象。所以当游戏内对象很多时，这个函数将很耗时。</p><p>可以通过 ** 缓存 ** 的方法，在 <code>Start</code> 或 <code>Awake</code> 时缓存一次找到的对象，在后续使用中使用缓存的对象而非继续调用 <code>GameObject.Find</code>。</p><p>或者采用 <code>GameObject.FindWithTag</code> 来寻找特定标签的对象。如果能在一开始就确定好对象，可以通过 **Inspector 注入 ** 的方式，将对象直接拖到 Inspector 中，从而避免了运行时的查找。</p><h4 id="Camera-main"><a href="#Camera-main" class="headerlink" title="Camera.main"></a>Camera.main</h4><p><code>Camera.main</code> 用来返回场景中的主相机，Unity 内部是通过 <code>GameObject.FindWithTag</code> 来查找 tag 为 <code>MainCamera</code> 的相机。</p><p>当需要频繁访问主相机时，我们可以将其 ** 缓存 ** 以获得性能提升。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Camera m_mainCamera;</span><br><span class="line">void Awake() &#123;</span><br><span class="line">    m_mainCamera = Camera.main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Start () &#123;</span><br><span class="line">    // 直接使用 Camera.main，耗时 164ms</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">        Camera.main.transform.position = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    // 采用缓存，耗时 74ms</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">        m_mainCamera.transform.position = Vector3.zero;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="GameObject-tag"><a href="#GameObject-tag" class="headerlink" title="GameObject.tag"></a>GameObject.tag</h4><p><code>GameObject.tag</code> 常用来比较对象的 tag，但是直接采用 <code>.tag ==</code> 来进行对比的话，每一帧会产生 GC Alloc。通过 <code>GameObject.CompareTag</code> 来进行比较则可以避免掉这些 GC，但是前提是比较的 tag 需在 Tag Manager 中定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 46Bytes GC Alloc Per Frame</span><br><span class="line">bool x = tag == &quot;xxxxx&quot;;</span><br><span class="line"></span><br><span class="line">// No GC Alloc, But Need to Define Tags in Tag Manager</span><br><span class="line">bool y = CompareTag(&quot;xxxxx&quot;); </span><br></pre></td></tr></table></figure><h4 id="MonoBehaviour"><a href="#MonoBehaviour" class="headerlink" title="MonoBehaviour"></a>MonoBehaviour</h4><p><code>MonoBehaviour</code> 提供了很多内部的调用方法，诸如 <code>Update</code>、<code>Start</code> 和 <code>Awake</code> 等等，它们使用起来很方便，只要在一个继承了 <code>MonoBehaviour</code> 的脚本中定义了 <code>Update</code> 函数，Unity 便会在每一帧去执行这个函数，具体的执行顺序见：<a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">Execution Order of Event Functions</a>。</p><p>然而当有大量的 <code>MonoBehaviour</code> 的 <code>Update</code> 需要执行时，在 profiler 中可以看到它们的耗时很高。因为在 <code>MonoBehaviour</code> 内部调用 <code>Update</code> 时需要做一系列检查，如下图所示： <img src="https://blogs.unity3d.com/wp-content/uploads/2015/12/table5.png" alt="Update 调用耗时"></p><p>我们可以自建一个 MonoBehaviour 管理器，里面维护一个 List，然后将这些需要调用 <code>Update</code> 的 MonoBehaviour 扔进 List 中，并将它们的 <code>Update</code> 函数改成其他名字，比如 <code>MonoUpdate</code>。然后在这个管理器的 <code>Update</code> 函数中循环遍历所有的 MonoBehaviour 调用它们的 <code>MonoUpdate</code>。结果可以获得数量级上的提升，如下所示： <img src="https://blogs.unity3d.com/wp-content/uploads/2015/12/table11.png" alt="1 万次调用差别"></p><p>详细原理请阅读：<a href="https://blogs.unity3d.com/2015/12/23/1k-update-calls/">10000 Update calls</a>。</p><h4 id="Transform-SetPositionAndRotation"><a href="#Transform-SetPositionAndRotation" class="headerlink" title="Transform.SetPositionAndRotation"></a>Transform.SetPositionAndRotation</h4><p>每次调用 <code>Transform.SetPosition</code> 或 <code>Transform.SetRotation</code> 时，Unity 都会通知一遍所有的子节点。</p><p>当位置和角度信息都可以预先知道时，我们可以通过 <code>Transform.SetPositionAndRotation</code> 一次调用来同时设置位置和角度，从而避免两次调用导致的性能开销。</p><h4 id="Animator-Set…"><a href="#Animator-Set…" class="headerlink" title="Animator.Set…"></a>Animator.Set…</h4><p><code>Animator</code> 提供了一系列类似于 <code>SetTrigger</code>、<code>SetFloat</code> 等方法来控制动画状态机。例如：<code>m_animator.SetTrigger(“Attack”)</code> 是用来触发攻击动画。然而在这个函数内部，<code>“Attack”</code> 字符串会被 hash 成一个整数。如果我们需要频繁触发攻击动画，我们可以通过 <code>Animator.StringToHash</code> 来 ** 提前进行 hash**，来避免每次的 hash 运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Hash once, use everywhere!</span><br><span class="line">private static readonly int s_Attack = Animator.StringToHash(“Attack”);</span><br><span class="line">m_animator.SetTrigger(s_Attack); </span><br></pre></td></tr></table></figure><h4 id="Material-Set…"><a href="#Material-Set…" class="headerlink" title="Material.Set…"></a>Material.Set…</h4><p>与 <code>Animator</code> 类似，<code>Material</code> 也提供了一系列的设置方法用于改变 Shader。例如：<code>m_mat.SetFloat(“Hue”, 0.5f)</code> 是用来设置材质的名为 Hue 的浮点数。同样的我们可以通过 <code>Shader.PropertyToID</code> 来提前进行 hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Hash once, use everywhere!</span><br><span class="line">private static readonly int s_Hue = Shader.PropertyToID(&quot;Hue&quot;);</span><br><span class="line">m_mat.SetFloat(s_Hue, 0.5f); </span><br></pre></td></tr></table></figure><h4 id="Vector-Math"><a href="#Vector-Math" class="headerlink" title="Vector Math"></a>Vector Math</h4><p>如果需要比较距离，而非计算距离，用 <code>SqrMagnitude</code> 来替代 <code>Magnitude</code> 可以避免一次耗时的开方运算。</p><p>在进行向量乘法时，有一点需要注意的是乘法的顺序，因为向量乘比较耗时，所以我们应该尽可能的减少向量乘法运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 耗时：73ms</span><br><span class="line">for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">    Vector3 c = 3 * Vector3.one * 2;</span><br><span class="line"></span><br><span class="line">// 耗时：45ms</span><br><span class="line">for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">    Vector3 c = 3 * 2 * Vector3.one; </span><br></pre></td></tr></table></figure><p>可以看出上述的向量乘法的结果完全一致，但是却有显著的耗时差异，因为后者比前者少了一次向量乘法。所以，应该 ** 尽可能合并数字乘法，最后再进行向量乘 **。</p><h4 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h4><p>Coroutine 是 Unity 用来实现异步调用的机制，如果对其不够了解可以参考我之前写的文章：<a href="https://wuzhiwei.net/unity_coroutines/">对 Unity 中 Coroutines 的理解</a>。</p><p>当需要实现一些定时操作时，有些同学可能会在 <code>Update</code> 中每帧进行一次判断，假设帧率是 60 帧，需要定时 1 秒调用一次，则会导致 59 次无效的 Update 调用。</p><p>用 Coroutine 则可以避免掉这些无效的调用，只需要 <code>yield return new WaitForSeconds(1f);</code> 即可。当然这里的最佳实践还是用一个变量缓存一下 <code>new WaitForSeconds(1f)</code>，这样省去了每次都 new 的开销。</p><h4 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h4><p><code>SendMessage</code> 用来调用 MonoBehaviour 的方法，然而其内部采用了反射的实现机制，时间开销异常大，需要尽量避免使用。</p><p>可以用 ** 事件机制 ** 来取代它。</p><h4 id="Debug-Log"><a href="#Debug-Log" class="headerlink" title="Debug.Log"></a>Debug.Log</h4><p>众所周知，输出 Log 是一件异常耗时，而且玩家感知不到的事情。所以应该在正式发布版本时，将其关闭。</p><p>Unity 的 Log 输出并不会在 Release 模式下被自动禁用掉，所以需要我们手动来禁用。我们可以在运行时用一行代码来禁用 Log 的输出：<code>Debug.logger.logEnabled = false;</code>。</p><p>不过最好采用条件编译标签 <code>Conditional</code> 封装一层自己的 Log 输出，来直接避免掉 Log 输出的编译，还可以省去 Log 函数参数传递和调用的开销。具体可以参见：<a href="http://www.xuanyusong.com/archives/2782">Unity3D 研究院之在发布版本屏蔽 Debug.log 输出的 Log</a>。</p><h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>反射是一项异常耗时的操作，因为其需要大量的有效性验证而且无法被编译器优化。</p><p>而且反射在 iOS 下还可能存在 <a href="https://docs.microsoft.com/en-us/xamarin/ios/internals/limitations">不能通过 AOT</a> 的情况，所以我们应该尽量避免使用反射。</p><p>我们可以自己 ** 建立一个字符串 - 类型的字典来代替反射 <strong>，或者 ** 采用 delegate</strong> 的方式来避免反射。</p><h4 id="内存分配（栈和堆）"><a href="#内存分配（栈和堆）" class="headerlink" title="内存分配（栈和堆）"></a>内存分配（栈和堆）</h4><p>在 C# 中，内存分配有两种策略，一种是分配在栈 StackStackStack 上，另一种是分配在堆 HeapHeapHeap 上。</p><p>在栈上分配的对象都是拥有固定大小的类型，在栈上分配内存十分高效。</p><p>在堆上分配的对象都是不能确定其大小的类型，由于其内存大小不固定，所以经常容易产生内存碎片，导致其内存分配相对于栈来说更为低效。</p><h4 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h4><p>在 C# 中，数据可以分为两种类型：值类型 ValueTypeValueTypeValue Type 和引用类型 ReferenceTypeReferenceTypeReference Type。</p><p>值类型包括所有数字类型、Bool、Char、Date、所有 Struct 类型和枚举类型。其类型的大小都是固定，它们都在栈上进行内存分配。</p><p>引用类型包括字符串、所有类型的数组、所有 Class 以及 Delegate，它们都在堆上进行内存分配。</p><p><img src="https://www.codeproject.com/KB/dotnet/6importentStepsDotNet/13.jpg" alt="Stack &amp; Heap"></p><h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>装箱 BoxingBoxingBoxing 指的是将值类型转换为引用类型，而拆箱 UnBoxingUnBoxingUnBoxing 的是将引用类型转换为值类型。 <img src="https://www.codeproject.com/KB/dotnet/6importentStepsDotNet/8.jpg" alt="Stack &amp; Heap"></p><p>从上图我们可以发现装箱和拆箱存在着从栈到堆的互指以及堆内存的开辟，所以它们本质是一项非常耗时的操作，我们应该尽量避免之。</p><p>Mono 之前的 foreach 导致每帧的 GC Alloc，本质也是因为装箱和拆箱导致的，此问题已经在 Unity5.6 后被修复。</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>我们在 ** 堆 ** 上分配的内存，其实是由垃圾回收器（Garbage Collector）来负责回收的。垃圾回收算法异常耗时，因为它需要遍历所有的对象，然后找到没有引用的孤岛，将它们标记为「垃圾」，然后将其内存回收掉。</p><p>频繁的垃圾回收不仅很耗时，还会导致内存碎片的产生，使得下一次的内存分配变得更加困难或者干脆无法分配有效内存，此时堆内存上限会往上翻一倍，而且无法回落，造成内存吃紧。</p><p>所以我们应该极力避免 GC Alloc，即需要控制堆内存的分配。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串连接会导致 GC Alloc，例如 <code>string gcalloc = &quot;GC&quot; + &quot;Alloc&quot;</code> 会导致 <code>&quot;GC&quot;</code> 变成垃圾，从而产生 GC Alloc。又比如：<code>string c = string.Format(&quot;one is {0}&quot;， 1)</code>，也会因为一次装箱操作（数字 <code>1</code> 被装箱成字符串 <code>&quot;1&quot;</code>）而产生额外的 GC Alloc。</p><p>所以如果字符串连接是高频操作，应该尽量避免使用 <code>+</code> 来进行字符串连接。C# 提供了 <code>StringBuilder</code> 类来专门进行字符串的连接。</p><h2 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h2><p>I2LCPP 是 Unity 提供的将 C# 的 IL 码转换为 C++ 代码的服务，由于转成了 C++，所以其最后会转换成汇编语言，直接以机器语言的方式执行，而不需要跑在. NET 虚拟机上，所以提高了性能。同时由于 IL 的反编译较为简单，转换成 C++ 后，也会增加一定的反汇编难度。</p><p>IL2CPP 的 C++ 代码虽然是自动生成的，但是其中间的某些过程也可以被人为操纵，从而达到提升性能的目的。</p><h3 id="Sealed-修饰"><a href="#Sealed-修饰" class="headerlink" title="Sealed 修饰"></a>Sealed 修饰</h3><p>在 C# 中，虚函数的调用会比直接调用开销更大，我们可以用 <a href="https://msdn.microsoft.com/en-us/library/88c54tsw.aspx"><code>sealed</code></a> 修饰符来修饰掉那些确保不会被继承的类或函数。</p><p>具体详情可以参考：<a href="https://blogs.unity3d.com/2016/07/26/il2cpp-optimizations-devirtualization/">IL2CPP Optimizations: Devirtualization</a>。<em>需要注意的是，在最新的 Unity 版本中，这一项优化<a href="https://forum.unity.com/threads/il2cpp-is-sealed-not-worked-as-said-anymore-in-unity-2018-3.659017/">已经失效</a>。</em></p><h3 id="避免自动判空"><a href="#避免自动判空" class="headerlink" title="避免自动判空"></a>避免自动判空</h3><p>在自动转换的 C++ 代码中，IL2CPP 默认会对所有 Nullable 的变量做判空。其实在某些你非常确定参数不为空的场合，这种检测实际上是不必要的。</p><p>具体步骤是复制 <a href="https://wuzhiwei.net/Il2CppSetOptionAttribute.cs"><code>Il2CppSetOptionAttribute.cs</code></a> 文件到你的 <code>Assets</code> 目录下，然后在类或者函数定义上加一个修饰语句 <code>[Il2CppSetOption(Option.NullChecks, false)]</code> 即可以禁用整个类或者函数的判空检测。</p><h3 id="避免数组越界检测"><a href="#避免数组越界检测" class="headerlink" title="避免数组越界检测"></a>避免数组越界检测</h3><p>同理，IL2CPP 也会默认对所有数组的读写做越界检测，我们可以通过修饰语句 <code>[Il2CppSetOption(Option.ArrayBoundsChecks, false)]</code> 来将其禁用。</p><p>具体可以参考：<a href="https://docs.unity3d.com/Manual//IL2CPP-CompilerOptions.html">https://docs.unity3d.com/Manual//IL2CPP-CompilerOptions.html</a></p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>我之前写过一篇有关于纯 Lua 性能优化的文章：<a href="https://wuzhiwei.net/lua_performance/">编写高性能的 Lua 代码</a>，以下是一些摘抄和补充。</p><h4 id="local"><a href="#local" class="headerlink" title="local"></a>local</h4><p>Lua 的默认变量都是全局变量，必须要加上 <code>local</code> 修饰才能变成局部变量。</p><p>局部变量相对于全部变量有以下几点好处： 1. 读写更快 2. 可以避免不经意的全局变量名污染 3. 在作用域结束时，会被自动标记为垃圾，避免了内存泄漏</p><p>所以，虽然 Lua 的默认变量声明都是全局变量，我们还是应该将其用 <code>local</code> 修饰为局部变量。</p><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>Lua 中的表内部分为两部分：hash 部分和 array 部分。当创建一个空表时，这两个部分都会默认初始化空间为 0。随着内容的不断填充，会不断触发 rehash。rehash 是一次非常耗时的操作，所以应尽量避免之。</p><p>如果同时需要创建较多的小表，我们可以通过 ** 预先填充 ** 表以避免 rehash。</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>与 C# 类似，在 Lua 中的字符串连接的代价也很高昂，但是与 C# 提供了 <code>StringBuilder</code> 不同，Lua 没有提供类似的原生解决方案。</p><p>不过我们可以用 table 来作为一个 buffer，然后使用 <code>table.concat(buffer, &#39;&#39;)</code> 来返回最终连接的字符串。</p><h4 id="与-C-交互"><a href="#与-C-交互" class="headerlink" title="与 C# 交互"></a>与 C# 交互</h4><p>关于与 C# 的交互，不同的 Lua 解决方案有不同的策略，但是有些基本的点都是一样的。</p><p>首先，关于 MonoBehaviour 的三大 Update 的桥接，最佳策略是通过一个管理器继承 MonoBehaviour 的 Update，然后将其派发给 Lua 端，然后 Lua 端所有的 Update 都注册于这个管理器当中。这样可以避免了多次 Lua 与 C# 的桥接交互，可以大量节省时间。</p><p>其次，需要考虑 GC 问题，默认的 struct 比如 <code>Vector3</code> 传递到 Lua 中都需要经历一次装箱操作，会带来额外的 GC Alloc，可以采用特殊配置的方式将其避免。XLua 的方案可以参考：<a href="https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/XLua%E5%A4%8D%E6%9D%82%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%88struct%EF%BC%89gc%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.md">XLua 复杂值类型（struct）gc 优化指南</a>。</p><p>最后，通用的优化思路可以参考<a href="https://blog.uwa4d.com/archives/USparkle_Lua.html">用好 Lua+Unity，让性能飞起来——Lua 与 C# 交互篇</a>，作者针对实例做了较为详尽的分析。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h4><p>容器应该针对不同的使用场合进行选择，主要看使用场合哪种操作的频率较高。例如：</p><ul><li>  经常需要进行 ** 随机下标访问 ** 的场合，优先选择 ** 数组 **（Array）或 ** 列表 **（List）</li><li>  经常需要进行 ** 查找 ** 的场合，优先选择 ** 字典 **（Dictionary）</li><li>  经常需要 ** 插入或删除 ** 的场合，优先选择 ** 链表 **（LinkedList）</li></ul><p>还有一些特殊的数据结构，适用于特殊的使用场合。例如：</p><ul><li>  不能存在相同元素的，可以选择 HashSet</li><li>  需要后进先出的，用来 ** 优化递归函数调用 ** 的，可以选择 Stack</li><li>  需要先进先出的，可以选择 Queue</li></ul><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>对象池（Object Pool）可以避免频繁的对象生成和销毁。游戏对象的生成，首先需要开辟内存，其次还可能会引起 GC Alloc，最后还可能会引发磁盘 I/O。频繁的销毁对象会引发严重的内存碎片，使得堆内存的分配更加困难。</p><p>所以在有大量对象需要重复生成和销毁时，一定要采用对象池来缓存好创建的对象，等到它们无需使用时，不需要将其销毁，而是将其放入对象池中，可以免去下次的生成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectPool&lt;T&gt; where T : new()</span><br><span class="line">&#123;</span><br><span class="line">    private Stack&lt;T&gt; objs;</span><br><span class="line"></span><br><span class="line">    public ObjectPool()&#123;</span><br><span class="line">        objs = new Stack&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取对象池里的对象</span><br><span class="line">    public T GetObject()&#123;</span><br><span class="line">        T obj = objs.Count &gt; 0 ? objs.Pop() : new T();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    // 回收对象池里的对象</span><br><span class="line">    public void ReturnObject(T obj)&#123;</span><br><span class="line">        if (obj != null)</span><br><span class="line">            objs.Push(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="空间划分"><a href="#空间划分" class="headerlink" title="空间划分"></a>空间划分</h4><p>在计算空间碰撞或者寻找最近邻居时，如果空间很庞大，需要参与计算的对象太多的情况下，用两层循环逐个遍历去计算的复杂度为平方级。</p><p>我们可以借助于空间划分的数据结构来使复杂度降低到 <code>N*Log(N)</code>。四叉树一般用来划分 2D 空间，八叉树一般用来划分 3D 空间，而 KD 树则是不限空间维度。</p><p>我之前写过一篇介绍 KD 树的原理和优化的文章：<a href="https://wuzhiwei.net/kdtree/">KD 树的应用与优化</a>，内容比较详尽，大家可以去读一读。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>循环的使用非常常见，也非常容易成为性能热点。我们应该尽量避免在循环内进行耗时或无效操作，尤其是这个循环在每帧的 Update 调用中时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Update() &#123;</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">        if (condition)</span><br><span class="line">            excuteFunc(i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以上的循环遍历中，无论 <code>condition</code> 为真或者为假，循环都会执行 <code>count</code> 次，若 <code>condition</code> 为假，则相当于白跑了 <code>count</code> 次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Update() &#123;</span><br><span class="line">    if (condition)</span><br><span class="line">        for (int i = 0; i &lt; count; i++)</span><br><span class="line">                excuteFunc(i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>将判断条件提出循环外，则可以避免白跑了的问题。</p><p>另一个需要注意的是小心多重循环的顺序问题，应该尽量把遍历次数较多的循环放在内层。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    // 耗时：37ms</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">        for (int j = 0; j &lt; 2; j++)</span><br><span class="line">            int k = i * j;</span><br><span class="line">    // 耗时：13ms</span><br><span class="line">    for (int i = 0; i &lt; 2; i++)</span><br><span class="line">        for (int j = 0; j &lt; 1000000; j++)</span><br><span class="line">            int k = i * j;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当内外层循环数有较多数量级上的差别时，将忙的循环放在内层性能更高，因为其避免了更多次内层循环计数器初始化的调用。</p><h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><p>开方运算，三角函数这些都是耗时的数学运算，应尽量避免之。</p><p>像之前提到的，如果只是单纯比较距离而不是计算距离的话，就可以用距离的平方来表示，可以节约掉一次耗时的开方运算。</p><p>三角运算可以通过简单的向量运算来规避之，具体可以参考我之前写的文章：<a href="https://wuzhiwei.net/vector_in_games/">向量运算在游戏开发中的应用和思考</a>。</p><p>~ 又比如如果经常需要除一个常数，比如用万分位整数来表示小数需要经常除 <code>10000</code>，可以改成乘 <code>0.0001f</code>，可以规避掉较乘法更为耗时的除法运算。~ 大雾，实际验算证明，现代的编译器会对此进行优化，所以没有必要为此牺牲可读性。很多时候还是要先测算再去写代码会比较好。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>我最喜欢的一种优化思路就是缓存。缓存的本质就是用空间换时间。例如之前在 Unity API 中提到的很多耗时的函数，都可以用缓存来提升性能。</p><p>包括对象池，也是缓存技术的一种。针对于需要依赖复杂运算而且后续要经常用到值，我们便可将其缓存起来，以避免后续的计算，从而获取性能提升。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li>  <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity7.html">General Optimizations in Unity</a></li><li>  <a href="https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-scripts-unity-games">Optimizing scripts in Unity games</a></li><li>  <a href="https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games">Optimizing garbage collection in Unity games</a></li><li>  <a href="https://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types">Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing</a></li></ul></blockquote><p>Posted in <a href="https://wuzhiwei.net/category/alogrithm/">Alogrithm</a>, <a href="https://wuzhiwei.net/category/datastructure/">DataStructure</a>, <a href="https://wuzhiwei.net/category/game-develop/">Game Develop</a>, <a href="https://wuzhiwei.net/category/unity/">Unity</a> Tagged <a href="https://wuzhiwei.net/tag/c/">C#</a>, <a href="https://wuzhiwei.net/tag/lua/">Lua</a>, <a href="https://wuzhiwei.net/tag/unity/">Unity</a>, <a href="https://wuzhiwei.net/tag/%e4%bc%98%e5%8c%96/">优化</a>, <a href="https://wuzhiwei.net/tag/%e6%80%a7%e8%83%bd/">性能</a>, <a href="https://wuzhiwei.net/tag/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/">数据结构</a>, <a href="https://wuzhiwei.net/tag/%e7%ae%97%e6%b3%95/">算法</a></p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>gitattributes 文件</title>
    <link href="https://tamsiree.com/Git/gitattributes%E6%96%87%E4%BB%B6/"/>
    <id>https://tamsiree.com/Git/gitattributes%E6%96%87%E4%BB%B6/</id>
    <published>2022-01-19T13:35:46.000Z</published>
    <updated>2025-11-05T13:53:39.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是-gitattributes-？"><a href="#什么是-gitattributes-？" class="headerlink" title="什么是 .gitattributes ？"></a>什么是 .gitattributes ？</h2><p>当执行 git 动作时，.gitattributes 文件允许你指定由 git 使用的文件和路径的属性，例如：<code>git commit</code> 等。</p><p>换句话说，每当有文件保存或者创建时，git 会根据指定的属性来自动地保存。</p><p>其中的一个属性是 <em>eol</em>(end of line)，用于配置文件的结尾。本文将会深入了解如何配置文件的结尾行，这样的话，即使在不同的机器、操作系统 上都可以使得每个开发者都可以使用相同的值。</p><h2 id="为什么是-gitattributes（开发者之间的争议-⚔️-）"><a href="#为什么是-gitattributes（开发者之间的争议-⚔️-）" class="headerlink" title="为什么是 .gitattributes（开发者之间的争议 ⚔️ ）?"></a>为什么是 .gitattributes（开发者之间的争议 ⚔️ ）?</h2><p>不是所有的开发者都是一样的，不能因为你是在 Windows 上使用 Visual Studio Code 开发的，就期望别的 Pull Request 也是基于相同的开发 环境完成的（在 MacOS 上可能用的是 Sublime Text2）。</p><p>正如上面提到的，开发者使用不同的操作系统，默认的文件结尾行就会不同。在 Windows 上默认的是回车换行（Carriage Return Line Feed, CRLF），然而，在 Linux/MacOS 上则是换行（Line Feed, LF）。</p><p>从表面看起来，内容都是一样的，那我们为什么还会困扰呢？??</p><p>好的，如果你启用了该功能，并设置属性 <code>endOfLine</code> 为 <code>lf</code> 的话。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;endOfLine&quot;: &quot;lf&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Windows 上，开发者会看到如下的检查警告。</p><p><img src="https://pic1.zhimg.com/v2-7f7615000240d6862bf8875328bbde70_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-7f7615000240d6862bf8875328bbde70_720w.jpg"></p><p>这时候 <code>.gitattributes</code> 就可以派上用场了 ！</p><h2 id="新仓库"><a href="#新仓库" class="headerlink" title="新仓库"></a>新仓库</h2><p>首先，在仓库的根目录下创建名为 <code>.gitattributes</code> 的文件。</p><p>下面，是一份 <code>.gitattributes</code> 文件的样例内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.js    eol=lf</span><br><span class="line">*.jsx   eol=lf</span><br><span class="line">*.json  eol=lf</span><br></pre></td></tr></table></figure><p>把该文件提交并推送到服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Added .gitattributes to repo&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>现在，任何人从仓库获取代码后，创建以及修改文件时，git 都会自动地设置好正确的文件结尾。</p><h2 id="增加到已有的-Git-仓库"><a href="#增加到已有的-Git-仓库" class="headerlink" title="增加到已有的 Git 仓库"></a>增加到已有的 Git 仓库</h2><p>正如上面提到的，在仓库的根目录下创建名为 <code>.gitattributes</code> 的文件。一旦文件推送到 git 服务器后，请确保你的本地 仓库是干净的、无需提交的。使用命令 <code>git status</code> 可以检查是否你的仓库是干净的。</p><p>** 注意 **：如果你还有未提及或推送的文件，请确保这些动作已经被执行过了，或者在执行下面的命令前 <code>stash</code> 过。</p><h2 id="重置-GitAttributes"><a href="#重置-GitAttributes" class="headerlink" title="重置 GitAttributes"></a>重置 GitAttributes</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r</span><br><span class="line">git reset --hard</span><br></pre></td></tr></table></figure><p>上面的命令就会根据文件 <code>.gitattributes</code> 中的定义，更新文件的结尾行。</p><p>任何变更都会自动使用指定文件的文件结尾行格式。</p><p>下一步，可以通知团队成员或者协作者去执行 Git 属性重置的命令。</p><p>现在，prettier 就不会在提示有关 CR 的问题了，所有的开发者都可以安心写代码了! ☮️</p><p><img src="https://pic1.zhimg.com/v2-2a96734c924815a917883af54d62351c_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-2a96734c924815a917883af54d62351c_720w.jpg"></p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Git" scheme="https://tamsiree.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://tamsiree.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Unity 自定义 PackageManager 服务器</title>
    <link href="https://tamsiree.com/GameEngine/Unity/Unity%E8%87%AA%E5%AE%9A%E4%B9%89PackageManager%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://tamsiree.com/GameEngine/Unity/Unity%E8%87%AA%E5%AE%9A%E4%B9%89PackageManager%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2022-01-16T16:41:48.000Z</published>
    <updated>2025-11-05T13:53:39.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="本文会实现以下几个需求"><a href="#本文会实现以下几个需求" class="headerlink" title="** 本文会实现以下几个需求 **"></a>** 本文会实现以下几个需求 **</h2><ul><li><p>  ** 搭建自己的 PackageManager 服务器 **</p></li><li><p>  安装 nodejs</p></li><li><p>  安装 npm</p></li><li><p>  部署 verdaccio</p></li></ul><ul><li><p>  ** 将自己写的插件发布到 PackageManager 服务器上 **</p></li><li><p>  配置自己的 Package</p></li><li><p>  注册 Verdaccio 服务器账号</p></li><li><p>  登陆 Verdaccio 服务器</p></li><li><p>  发布 Package 到 Verdaccio 服务器上</p></li></ul><ul><li><p>  ** 让项目可以使用 Verdaccio 服务器上的所有 Package**</p></li><li><p>  修改项目的 manifest.json</p></li></ul><ul><li><p>  ** 修改 Unity 编辑器的项目模板，让每个新建的 Unity 项目都可安装自己服务器上的插件 **</p></li><li><p>  修改 Unity 编辑器项目模板的 mainfest.json</p></li><li><p>  使用 peazip 重新压缩为. tgz 文件</p></li></ul><h2 id="本文需要用到的工具"><a href="#本文需要用到的工具" class="headerlink" title="** 本文需要用到的工具 **"></a>** 本文需要用到的工具 **</h2><ul><li>  Unity Editor</li><li>  云服务器</li><li>  Windows PowerShell</li><li>  PeaZip</li></ul><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="** 参考文章：**"></a>** 参考文章：**</h2><p><a href="https://medium.com/@markushofer/run-your-own-unity-package-server-b4fe9995704e">https://medium.com/@markushofer/run-your-own-unity-package-server-b4fe9995704e</a></p><h2 id="一、云服务器部署"><a href="#一、云服务器部署" class="headerlink" title="一、云服务器部署"></a>一、云服务器部署</h2><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p>你可以选择阿里云，腾讯云，谷歌云等产品，本文使用腾讯云的轻量级服务器。</p><p>理论上只要是 Linux 的系统就可以。</p><p><img src="https://pic4.zhimg.com/v2-107231d3a15789eb6b930fe0df083783_b.jpg"></p><p>系统镜像为 Ubuntu</p><p><img src="https://pic2.zhimg.com/v2-fa63f0049c00f345e37f3dc4072a3e71_b.jpg"></p><p><img src="https://pic4.zhimg.com/v2-39c91fc2b4570c7d847aa30d98e1190b_b.jpg"></p><h3 id="登陆云服务器"><a href="#登陆云服务器" class="headerlink" title="登陆云服务器"></a>登陆云服务器</h3><p>自行购买好服务器之后进入控制台界面，大部分厂商的服务器都是可以直接在网页上远程登陆的。点击登陆</p><p><img src="https://pic1.zhimg.com/v2-a2cc9c8f3fac304402c6b8505f80fb20_b.jpg"></p><h3 id="切换到-root"><a href="#切换到-root" class="headerlink" title="切换到 root"></a>切换到 root</h3><p>进入控制台之后输入 sudo -i 获取 root 权限</p><p><img src="https://pic3.zhimg.com/v2-a2843da9915076b63d26af5be613e2fa_b.jpg"></p><h3 id="安装-Verdaccio"><a href="#安装-Verdaccio" class="headerlink" title="安装 Verdaccio"></a>安装 Verdaccio</h3><p>Verdaccio 是一个开源的 npm 私服，我们后续的 package 都是发布在这上面的</p><p><a href="https://verdaccio.org/zh-cn/">https://verdaccio.org/zh-cn/</a></p><p><img src="https://pic3.zhimg.com/v2-38dc9e9399e8c3de4c8c641f22905b86_b.jpg"></p><p>在安装 verdaccio 之前需要先安装 nodejs 和 npm</p><p>使用以下代码安装</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_11.x | bash -</span><br><span class="line">apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>成功之后的输出</p><p><img src="https://pic2.zhimg.com/v2-fd421e58a924f8d59b51cf026e46e23d_b.jpg"></p><p>使用以下代码验证是否安装成功</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodejs -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>正常输出了版本号则说明安装成功</p><p><img src="https://pic3.zhimg.com/v2-2d6915b686fed58274368c482a9f153a_b.jpg"></p><p>确保 nodejs 和 npm 安装成功之后我们来安装 verdaccio</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global verdaccio</span><br></pre></td></tr></table></figure><p>安装成功</p><p><img src="https://pic3.zhimg.com/v2-f3bad03135d72371ab374651bb6f94ea_b.jpg"></p><h3 id="配置-Verdaccio"><a href="#配置-Verdaccio" class="headerlink" title="配置 Verdaccio"></a>配置 Verdaccio</h3><p>然后我们需要运行 verdaccio，在普通用户权限下运行即可</p><p>按 Ctrl D 退出 root 权限</p><p>输入 verdaccio 运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verdaccio</span><br></pre></td></tr></table></figure><p>成功运行显示下图，记住 config file 的路径，下一步需要用到</p><p>我这里是 /home/lighthouse/verdaccio/config.yaml</p><p><img src="https://pic3.zhimg.com/v2-0abd7e263d5f08db959fcf41625b9e7a_b.jpg"></p><p>按 Ctrl Z 退出 verdaccio</p><p><img src="https://pic1.zhimg.com/v2-35426f6f4987c120ef98fec65cf7b940_b.jpg"></p><p>这里使用 vim + 上面记住的路径，编辑配置文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/lighthouse/verdaccio/config.yaml</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/v2-d3e2db1774ec4f952a3de22d0b48f312_b.jpg"></p><p>到这个界面之后按 i ，然后在 plugins 下插入下面两行代码</p><p>4873 是端口，可以自行定义，之后就使用 ip + 这个端口访问 verdaccio 界面</p><p><img src="https://pic2.zhimg.com/v2-0c6679fa55e344c5a8cc31d1d6646005_b.jpg"></p><p>按 Esc 退出 Insert</p><p>输入 :wq 并回车保存并退出 vim</p><p><img src="https://pic3.zhimg.com/v2-66c633fcdbda79b529a59a364e5cccee_b.png"></p><p><img src="https://pic2.zhimg.com/v2-1b5acbdd3371b5265950f3a941e2c9f9_b.png"></p><p>这时候需要回到控制台，打开防火墙，添加你刚才设置的端口</p><p><img src="https://pic4.zhimg.com/v2-9525729b3803c70bd5bd1f73fbb9c227_b.jpg"></p><p><img src="https://pic3.zhimg.com/v2-e0c04f4dedc1858381d775701db22592_b.jpg"></p><p>重新登陆到控制台，运行 verdaccio</p><p><img src="https://pic2.zhimg.com/v2-ccf8ec5d35191bc675e0bf5eafb17801_b.jpg"></p><p>这时候你就可以打开浏览器，输入 ip 加端口访问 verdaccio 了</p><p><img src="https://pic2.zhimg.com/v2-6a9b4fdc185367c545c066467d2b37c5_b.jpg"></p><p>控制台这边也会有 log 输出</p><p><img src="https://pic2.zhimg.com/v2-af2d664637498dd3c046854aa69f670d_b.jpg"></p><p>但是这样还有一个弊端，我们需要 verdaccio 一直运行，但是现在关掉控制台之后，它也会跟着关闭，我们也无法通过端口访问了</p><p><img src="https://pic1.zhimg.com/v2-cbf87d3f504c9f38a70f658c8713d3dc_b.jpg"></p><p>我们需要使用一个叫 screen 的小工具来让 verdaccio 一直运行在服务器上</p><p>登陆服务器输入 screen，</p><p><img src="https://pic1.zhimg.com/v2-64f5c712d39a34df48f133f06e261574_b.png"></p><p>如果没有安装，则输入以下代码进行安装</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install screen</span><br></pre></td></tr></table></figure><p>输入之后会显示该界面，再按一下回车</p><p><img src="https://pic2.zhimg.com/v2-f3fea7b66011e9a282f81c35ec4f9dd1_b.jpg"></p><p>然后就进入到了 screen 的控制台，输入 verdaccio 回车</p><p><img src="https://pic1.zhimg.com/v2-af96c7995a63728b78314f456638c4fc_b.jpg"></p><p>按 Ctrl A+D 退出</p><p>大功告成，现在关闭控制台之后，你还可以通过端口访问</p><p><img src="https://pic2.zhimg.com/v2-cb69ac5fa70b97bad31351231648a845_b.jpg"></p><h2 id="二、将自己的插件发布到服务器上面"><a href="#二、将自己的插件发布到服务器上面" class="headerlink" title="二、将自己的插件发布到服务器上面"></a>二、将自己的插件发布到服务器上面</h2><h3 id="首先你需要准备好你的插件包"><a href="#首先你需要准备好你的插件包" class="headerlink" title="首先你需要准备好你的插件包"></a>首先你需要准备好你的插件包</h3><p>你可以参考 Package 下面这些 Unity 自带的包格式</p><p><img src="https://pic4.zhimg.com/v2-89432fb6509bb8ea7fb525b79c173b23_b.jpg"></p><p>这里用我自己写的 UI 框架举例</p><p><img src="https://pic2.zhimg.com/v2-afdd5ebcb1fa62d880a61333925130a5_b.jpg"></p><p>有几个要点：</p><ul><li>  package 以文件夹的形式管理</li><li>  脚本建议按照 Editor 和 Runtime 进行分类</li><li>  package 里所有的脚本都需要有一个程序集定义文件 Assembly Definition</li><li>  程序集之间的引用关系必须正确</li><li>  根目录必须要有一个 package.json 文件</li></ul><h3 id="为脚本创建程序集定义文件"><a href="#为脚本创建程序集定义文件" class="headerlink" title="** 为脚本创建程序集定义文件 **"></a>** 为脚本创建程序集定义文件 **</h3><p>我这个项目是比较简单的结构，就只需要给 Editor 和 Runtime 两个文件夹的脚本添加</p><p>关于程序集定义文件的详细介绍请看官方手册：</p><p>在文件夹下右键创建一个 Assembly Definition 文件，这个文件会自动将跟它同级以及同级文件夹内的脚本定义为一个程序集</p><p>这里我在 Runtime 文件夹下新建</p><p><img src="https://pic4.zhimg.com/v2-f2539a977081dfe69c7e74e80b1a6ef3_b.jpg"></p><p><img src="https://pic3.zhimg.com/v2-a10412248912e3be79fcc503e23bdd82_b.jpg"></p><p>然后我在 Editor 文件夹下新建</p><p>这里主要注意平台和引用</p><ol><li> 因为 Editor 的脚本应该是只在编辑器下生效的，所以我们需要将平台改为只勾选 Editor，否则有可能在打包时出错</li></ol><p><img src="https://pic2.zhimg.com/v2-a4d7901ee90edf56626903fe237be989_b.jpg"></p><ol start="2"><li>一些 Editor 的脚本会引用 Runtime 的脚本，所以需要对 Editor 的程序集定义文件引用 Runtime 的程序集定义文件</li></ol><p><img src="https://pic1.zhimg.com/v2-4b1dabea0a116458b5f54bdd9d4f3480_b.jpg"></p><ol start="3"><li>如果你的插件引用了其他插件，也需要添加其他插件的程序集引用</li></ol><h3 id="在插件根目录创建-package-json-文件"><a href="#在插件根目录创建-package-json-文件" class="headerlink" title="在插件根目录创建 package.json 文件"></a>在插件根目录创建 package.json 文件</h3><p><img src="https://pic3.zhimg.com/v2-71696372bd8fa5286f184d41ad586a96_b.jpg"></p><p>打开之后，填写包名，版本号，引用的其他 package 等</p><p><img src="https://pic2.zhimg.com/v2-a302f2035e450ae7a50f5a8521ba6605_b.jpg"></p><p>全部完成之后，我们的 Package 就准备好了，剩下就只有上传了</p><h3 id="使用-Windows-PowerShell-将-Package-上传到-verdaccio"><a href="#使用-Windows-PowerShell-将-Package-上传到-verdaccio" class="headerlink" title="使用 Windows PowerShell 将 Package 上传到 verdaccio"></a>使用 Windows PowerShell 将 Package 上传到 verdaccio</h3><p>** 打开 PowerShell** ，一般都是自带的</p><p><img src="https://pic3.zhimg.com/v2-3bbfe901c5ebc320cb85b2d4d7d716ca_b.jpg"></p><p>** 首先使用以下指令注册一个 verdaccio 账户 **</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://ip: 端口 </span><br></pre></td></tr></table></figure><p>会让你输入用户名密码和邮箱</p><p><img src="https://pic3.zhimg.com/v2-64520e82023faa5265ceb16986c0e57a_b.jpg"></p><p>注册成功</p><p><img src="https://pic4.zhimg.com/v2-b7dc30de2cbb0e105d1a065f77d64e53_b.jpg"></p><p>** 使用以下代码登陆，注册登陆一般只需一次即可，后续直接发布就行 **</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login --registry http://ip: 端口 </span><br></pre></td></tr></table></figure><p>接下来 **cd 到你的 package 路径 **</p><p><img src="https://pic2.zhimg.com/v2-7816370cbc7c6957c21101eb21ebb37d_b.png"></p><p>然后 ** 使用以下指令发布，每次更新都需要提升版本号，否则会失败 **</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --registry http://ip: 端口 </span><br></pre></td></tr></table></figure><p>发布成功</p><p><img src="https://pic1.zhimg.com/v2-dc7af356280c808337cc0329676c4b6c_b.jpg"></p><p>然后可以在网页看到你发布的 Package</p><p><img src="https://pic3.zhimg.com/v2-8fa2c497d2bea139a3df4379101e0896_b.jpg"></p><h2 id="三、修改项目的-manifest-json-文件，注册你的服务器地址"><a href="#三、修改项目的-manifest-json-文件，注册你的服务器地址" class="headerlink" title="三、修改项目的 manifest.json 文件，注册你的服务器地址"></a>三、修改项目的 manifest.json 文件，注册你的服务器地址</h2><p>打开根目录，找到 Packages 文件夹下的 manifest.json</p><p><img src="https://pic2.zhimg.com/v2-c748c5c6d0269070cc2537f2228f7119_b.jpg"></p><p><img src="https://pic3.zhimg.com/v2-8081a48a54eaece42d2190d96b8f5516_b.jpg"></p><p>** 在 dependencies 上方加入以下代码 **</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scopedRegistries&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Puffer&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;http://ip: 端口 /&quot;,</span><br><span class="line">    &quot;scopes&quot;: [</span><br><span class="line">      &quot; 注册的包名前缀 & quot;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="https://pic2.zhimg.com/v2-cce80990ba4c526b5e299bd50ff77a79_b.jpg"></p><p>重新回到项目，打开 PackageManager，就可以找到我们发布的 package 了</p><p>新版本的 Unity 还可以在这筛选是 Unity 的包还是自定义服务器的包</p><p>为了方便找到我自己的包，名字前都加了一个下划线</p><p><img src="https://pic2.zhimg.com/v2-2be3b1216ae0691e79418b6fbee6498d_b.jpg"></p><h2 id="四、修改-Unity-编辑器的项目模板，让每个新建的-Unity-项目都可安装自己服务器上的插件"><a href="#四、修改-Unity-编辑器的项目模板，让每个新建的-Unity-项目都可安装自己服务器上的插件" class="headerlink" title="四、修改 Unity 编辑器的项目模板，让每个新建的 Unity 项目都可安装自己服务器上的插件"></a>四、修改 Unity 编辑器的项目模板，让每个新建的 Unity 项目都可安装自己服务器上的插件</h2><p>上面这样依然不是很方便，我每新建一个项目，都要重新修改一下 manifest.json 文件，对于我这样的程序员来说，一件事情做两遍，是 ** 不能忍 ** 的。</p><p>我们通过修改 Unity 编辑器的项目 ** 模板 ** 来解决这个问题，这样每次新建项目的时候，就都会使用我们模板里的 json 文件了！</p><p>首先找到 Unity 编辑器的项目模板路径</p><p>如下</p><p><img src="https://pic1.zhimg.com/v2-12692df16caf8d14bb5e83ddfb7d7798_b.jpg"></p><p>将我们平时常用的那个模板解压，进入解压后得到的文件夹</p><p><img src="https://pic4.zhimg.com/v2-74893827f649ceb828f8e2c7a6e1c15f_b.jpg"></p><p>打开它，增加我们域注册代码</p><p><img src="https://pic3.zhimg.com/v2-9e89b6446df02685e6c7f9e4c7d9af6a_b.jpg"></p><p>为这个模板重命名，到模板根目录，打开 package.json</p><p><img src="https://pic1.zhimg.com/v2-b6e2f52df4b986323dd827dbd99ad278_b.jpg"></p><p>修改 name 和 displayName</p><p><img src="https://pic4.zhimg.com/v2-20e677dfdcc45d4154ba8d4da0b81217_b.jpg"></p><p>这时候我需要将这个 package 文件夹重新压缩回 tgz，我常用的 winrar 是不行的</p><p>这里我使用 PeaZip 来进行压缩</p><p><img src="https://pic2.zhimg.com/v2-38d26e28e6a87f2fce17b5c3d9cf0971_b.png"></p><p>右键该文件夹，添加到归档</p><p><img src="https://pic3.zhimg.com/v2-9ff2abae01b73fbda7a1d69d825373ee_b.jpg"></p><p>注意红框内的几个设置</p><p>选择 GZip，勾选选用 TAR 归档，点击确定</p><p><img src="https://pic4.zhimg.com/v2-f83d0250c2c278d370e8679a52037803_b.jpg"></p><p>然后得到一个 .tar.gz 文件</p><p><img src="https://pic2.zhimg.com/v2-5f0812474966ef00c6907bd8fa2ae85d_b.png"></p><p>对其进行重命名，将 .tar.gz 改成 .tgz ，否则 Unity 无法识别该模板</p><p><img src="https://pic2.zhimg.com/v2-de2d65b78bfed182442c414e7cc52f7d_b.jpg"></p><p>最后删除 Package 文件夹</p><p><img src="https://pic4.zhimg.com/v2-a2c56cf2ab60fcffbbfe051fac2f6b97_b.jpg"></p><p>然后需要注销或者重启电脑，才会生效</p><p><img src="https://pic1.zhimg.com/v2-12815b6c50d0cb0c0696099d2c409164_b.jpg"></p><p>大功告成，新建项目的时候就可以看到我们的模板了</p><p><img src="https://pic3.zhimg.com/v2-cce5945a33b347705447cf80a53e1e12_b.jpg"></p><hr><blockquote><p>参考来源： <a href="https://zhuanlan.zhihu.com/p/339669034">[ Unity 自定义 PackageManager 服务器 ]</a><br><a href="https://www.jianshu.com/p/153841d65846">开发 Unity PackageManager 插件包</a><br><a href="https://www.jianshu.com/p/6e5e2947df31">Unity: 使用 Package Manager 开发和管理自定义插件</a></p></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
    <summary type="html">搭建自己的PackageManager服务器</summary>
    
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/categories/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/categories/GameEngine/Unity/"/>
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/tags/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 的 Profiler 指南</title>
    <link href="https://tamsiree.com/Software/Unity/Unity%E7%9A%84Profiler%E6%8C%87%E5%8D%97/"/>
    <id>https://tamsiree.com/Software/Unity/Unity%E7%9A%84Profiler%E6%8C%87%E5%8D%97/</id>
    <published>2022-01-06T06:22:07.000Z</published>
    <updated>2025-11-05T13:53:39.385Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h1 id="Profiler-概述"><a href="#Profiler-概述" class="headerlink" title="Profiler 概述"></a>Profiler 概述</h1><h2 id="打开-Unity-Profiler"><a href="#打开-Unity-Profiler" class="headerlink" title="打开 Unity Profiler"></a>打开 Unity Profiler</h2><ol><li>Window-&gt;Analysis-&gt;Profiler。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200408151835953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20200408151732233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="2"><li>Profiler 可以确定 ** 需要在应用程序中优化什么，并确认优化产生了您期望的结果 **。默认情况下，Unity 记录 300 帧游戏数据并呈现每一帧的详细信息。</li></ol><h2 id="Profiler-Window-Layout"><a href="#Profiler-Window-Layout" class="headerlink" title="Profiler Window Layout"></a>Profiler Window Layout</h2><ul><li>A：Profiler 模块。这是可以在应用程序中配置的所有模块的列表。使用该区域顶部的下拉菜单从窗口中添加和删除模块。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408154842311.png"></p><ul><li>B：Profiler 控件。使用这些控件来设置从哪个设备进行配置，以及应该执行哪种类型的配置 Unity，在帧之间导航，并开始记录数据。</li><li>C: 帧图表。这个区域包含了每个模块的图表。</li><li>D：细节面板模块。窗口这个区域的信息会根据您选择的模块而变化。</li></ul><h2 id="Profiler-Controls"><a href="#Profiler-Controls" class="headerlink" title="Profiler Controls"></a>Profiler Controls</h2><p><img src="https://img-blog.csdnimg.cn/20200408155856179.png"></p><h3 id="各个控件功能："><a href="#各个控件功能：" class="headerlink" title="各个控件功能："></a>各个控件功能：</h3><ol><li>AttachToPlay：</li></ol><ul><li>选择要对应用程序进行概要分析的目标。</li><li>默认情况下，这个设置为 Playmode。还可以选择编辑器来配置 Unity 编辑器，并显示编辑器当前使用的资源。</li><li>Unity 还可以自动检测任何运行在网络上或通过 USB 连接的设备，并在下拉菜单中显示它们。在下拉列表中单击 Enter IP，手动输入要对应用程序进行概要分析的设备的 IP 地址；</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408160807342.png"></p><ol start="2"><li>Record：</li></ol><p>-<br>启用此设置以在运行应用程序时记录活动模块的分析信息。</p><p>-<br>如果没有启用此按钮，则分析器在运行应用程序时不会收集任何数据。</p><p><img src="https://img-blog.csdnimg.cn/20200408160933765.png"></p><ol start="3"><li><p>Back Arrow：向后导航一帧。</p></li><li><p>Forward Arrow: 向前导航一帧。</p></li><li><p>Current:</p></li></ol><ul><li>跳转到最后记录的帧，使分析器实时显示收集到的数据。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408161117694.png"></p><ol start="6"><li><p>Frame Number：指示当前在分析器中查看的帧号。</p></li><li><p>Clear：清除 Profiler 窗口中的所有数据。</p></li><li><p>Clear On Play：</p></li></ol><ul><li>当下次在 “Player Windows” 中单击 “播放” 或连接到新目标设备时，启用此设置可从 “分析器” 窗口中删除所有数据。</li></ul><ol start="9"><li>Deep Profile：</li></ol><ul><li>启用此设置来配置所有 c# 方法。</li><li>** 当启用此设置时，Unity 将检测添加到所有 mono 调用中，这样就可以对的脚本进行更详细的调查 **。</li></ul><ol start="10"><li>Call Stack：</li></ol><p>-<br>** 若要记录用于脚本化内存分配的调用堆栈，需要单击此切换 **。</p><p>-<br>** 启用此选项时分析器记录的帧在 GC 中有信息 **。</p><p>-<br>** 在完整调用堆栈上的 Alloc 示例将导致托管脚本分配，即使在 Deep Profile 没有激活时也是如此 **。</p><ol start="11"><li>Load：</li></ol><ul><li>将保存的分析器数据加载到分析器窗口。</li><li>也可以通过分析器加载 Player 通过<a href="https://docs.unity3d.com/2019.3/Documentation/ScriptReference/Profiling.Profiler-logFile.html">Profiler.logFile </a>API 写出的已经写出到文件的数据。</li><li>** 按住 Shift 键，然后单击 Load 按钮，可以将文件内容附加到当前 Profile 帧序列中 **。</li></ul><ol start="12"><li>Context Menu：</li></ol><p><img src="https://img-blog.csdnimg.cn/20200408162658408.png"></p><p>(1) ColorBindMode：启用此设置可使分析器在其图形中使用更高的对比度颜色。这增强了红绿色盲用户的可见性。</p><p>(2) Show Stat for “Current Frame” : 在记录过程中一直显示当前帧的对应的图表上的数据。</p><p>(3) Preference：</p><ul><li>打开 Preferences 菜单以调整特定于分析器的属性。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408163327695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p>** 为了保持较低的开销，Unity 只会每隔五帧重绘一次编辑器 UI，这将导致一个稍微有些不太平滑的更新 **。</p><h3 id="Deep-Profilling"><a href="#Deep-Profilling" class="headerlink" title="Deep Profilling"></a>Deep Profilling</h3><ol><li><p>** 通常，分析器只分析在 <a href="https://docs.unity3d.com/2019.3/Documentation/ScriptReference/Unity.Profiling.ProfilerMarker.html">profilermarker</a> 中显式包装的 Code Timings<strong>。</strong> 这包括从引擎的本地代码到脚本代码的第一次调用堆栈深度 **，例如 MonoBehaviour 的启动、Update 或类似的方法。</p></li><li><p>如果没有向您自己的代码中添加更显式的 ProfilerMarker 插装，那么只能看到作为脚本代码子样例的其他样例是那些回调到 Unity 的 API(如果该 API 已插装)的样例。** 大多数带有性能开销的 API 调用都是插装的 Instumented**。例如：通过 Camera.main API 获取主相机作为“FindMainCamera”Sample。</p></li><li><p>当启用 Deep Profile 设置，Profiler 会剖析脚本代码的每一部分并且记录所有的函数调用，包括至少第一次调用堆栈到任何 UnityAPI 的深度。Unity 将分析器工具注入到你所有的脚本方法中来记录所有的函数调用。这对于理解应用程序代码在什么地方花费的时间最多很有用。</p></li><li><p>深度剖析是资源密集型的，并且会使用大量的内存。因此，在进行概要分析时，应用程序的运行速度会明显变慢。深度剖析更适合使用简单脚本的小型游戏。如果正在使用复杂的脚本代码，应用程序可能根本无法使用深度剖析，而对于许多较大的应用程序，深度剖析可能会使 Unity 耗尽内存。</p></li><li><p>要增加 Profiler 环缓冲区的大小，可以调整分析器。可以调整 ** 正在分析的播放器的 <a href="https://docs.unity3d.com/2019.3/Documentation/ScriptReference/Profiling.Profiler-maxUsedMemory.html">maxUsedMemory</a> 属性 **。如果 Deep Profile 导致应用程序的帧率下降到无法运行的程度，那么可以手动地剖析脚本代码块，这比深度剖析的开销要小。</p></li></ol><ul><li>** 使用 profilermarker 手动添加标记脚本块所需的工具 **。</li><li>** 标记内容将出现在 CPU 使用率分析器模块中 **。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408170643734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="6"><li>如果想找出哪些调用堆栈会导致 GC。没有深度剖析的 Alloc 示例，可以打开分配调用堆栈的集合。在 Profiler 控件中启用调用堆栈设置，然后可以选择 GC。在时间轴视图中 Alloc 样例，或者使用 Hierarchy 视图中的 Show Related Objects 面板来查找这些样例的调用堆栈。</li></ol><h2 id="Profiler-Modules"><a href="#Profiler-Modules" class="headerlink" title="Profiler Modules"></a>Profiler Modules</h2><h3 id="各个模块功能和含义"><a href="#各个模块功能和含义" class="headerlink" title="各个模块功能和含义"></a>各个模块功能和含义</h3><ol><li>CPU Usage:</li></ol><ul><li>显示应用程序在物理、脚本、动画和垃圾收集等领域花费最多时间的概述。</li><li>此模块包含关于应用程序的广泛概要信息，您可以使用它来决定使用哪些模块来进一步研究应用程序中更具体的问题。</li><li>此模块始终处于活动状态，即使您关闭它。</li></ul><p>2.GPU Usage:</p><p>-<br>GPU Usage 显示与图形处理相关的信息。</p><p>-<br>** 默认情况下，这个模块没有被激活，因为它有很高的开销 **。</p><ol start="3"><li><a href="https://so.csdn.net/so/search?q=Render">Render</a>ing:</li></ol><ul><li>显示 Unity 在应用程序中 ** 渲染图形的信息，包括静态和动态批处理、SetPass 和 Draw 调用、三角形和顶点 **。</li></ul><ol start="4"><li>Memory：</li></ol><ul><li>显示有关 Unity 如何在应用程序中分配内存的信息。</li><li>这对于了解 ** 脚本分配 (GC.Alloc) 如何导致垃圾收集 **，或者 ** 了解应用程序的 Asset 内存使用随时间的变化趋势 ** 特别有用。</li></ul><ol start="5"><li>Audio：</li></ol><ul><li>显示与应用程序中的音频相关的信息，例如什么时候播放多少音频源，音频系统需要多少 CPU 占用，以及分配给它多少内存。</li></ul><ol start="6"><li><p>Video: 显示应用程序中与视频相关的信息。</p></li><li><p>Physics/Physics 2D：显示物理引擎处理过的应用程序中的物理信息。</p></li><li><p>Network Message，Network Operation 两个模块已经被弃用。</p></li><li><p>UI：</p></li></ol><ul><li>显示关于 Unity 如何处理应用程序的 UI 批处理的信息，包括为什么以及如何批处理项目。</li></ul><ol start="10"><li>UI Details：</li></ol><ul><li>与 UI 模块类似，此模块的图表 ** 添加了有关批处理和顶点计数的数据，以及包含触发 UI 更改的用户输入事件信息的标记 **。</li></ul><ol start="11"><li>Global Illumination：</li></ol><ul><li>显示关于 Unity 在应用程序中的全局照明子系统上花费了多少 CPU 资源的信息。</li></ul><h3 id="Profiler-Module-Overhead-分析器模块开销"><a href="#Profiler-Module-Overhead-分析器模块开销" class="headerlink" title="Profiler Module Overhead 分析器模块开销"></a>Profiler Module Overhead 分析器模块开销</h3><ol><li><p>一些分析器模块有很大的数据收集开销，比如 GPU、UI 和音频分析器模块。为了防止这些模块影响应用程序的性能，可以通过在 Profiler 模块下拉菜单中取消对它们的选择来禁用它们。这将从窗口中删除模块，停止分析器收集模块的数据，并降低分析器的开销。</p></li><li><p>** 这不适用于 CPU 使用模块，因为其他模块依赖于 CPU 使用模块，所以 CPU 使用模块即使在不活动时也会收集数据 **。</p></li><li><p>若要添加模块，选择 Profiler 模块下拉菜单并选择要激活的 Profiler。当您从下拉菜单中选择 Profiler 模块时，它将开始收集数据，但是不会显示它不活动期间的任何数据。</p></li><li><p>** 为了避免 GPU Profiler 模块的开销，它在默认情况下是不活动的。图形分析器模块必须在应用程序启动时激活，以连接到图形驱动程序。如果你稍后添加它，它对大多数平台没有影响，并且剖析器显示消息“图形卡驱动程序不支持 GPU 剖析 **(或它被禁用，因为驱动程序 bug)”。</p></li><li><p>如果指示分析器收集数据并通过分析器将数据发送到磁盘。** 可以通过 Profiler. setareaenabled()关闭 Profiler 模块，而不是通过 Profiler 窗口 **。</p></li><li><p>一些通过外部 IDE 调试脚本的设置也可能产生开销。** 为了避免这种开销和获得更准确的测量，禁用编辑器附加设置 (Edit-&gt; 首选项 -&gt;外部工具)<strong>。类似地，</strong> 在配置构建播放器时，打开构建设置并禁用脚本调试以避免这种开销 **。</p></li></ol><h2 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command Line Arguments"></a>Command Line Arguments</h2><ol><li>如果从命令行（例如 Windows 上的命令提示符，MacOS 上的终端，LinuxShell 或者 Android adb）启动构建的播放器或 Unity 编辑器，可以传递命令行参数来配置一些 Profile 设置。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200408193447129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h1 id="Profile-Application"><a href="#Profile-Application" class="headerlink" title="Profile Application"></a>Profile Application</h1><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><ol><li>构建时必须选中：Development Build 以及 AutoconnectProfiler，其他选项可选。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200408194407685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20200408194457448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="2"><li>Deep Profiling Support 对于深入分析应用程序的启动时间非常有用，这将为构建增加少量开销。</li></ol><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><ol><li>IOS 和 Android 都支持通过网络的远端 profiling。如果使用了防火墙，需要在出站规则中打开端口：54998-55511。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200409095837639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="iOS-远端-Profiling"><a href="#iOS-远端-Profiling" class="headerlink" title="iOS 远端 Profiling"></a>iOS 远端 Profiling</h3><p><img src="https://img-blog.csdnimg.cn/20200409100038215.png"></p><h3 id="Android-远端-Profiling"><a href="#Android-远端-Profiling" class="headerlink" title="Android 远端 Profiling"></a>Android 远端 Profiling</h3><p><img src="https://img-blog.csdnimg.cn/202004091004036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="重新连接"><a href="#重新连接" class="headerlink" title="重新连接"></a>重新连接</h3><ol><li><p>当选择 “Build &amp; Run” 时，Unity Editor 自动为应用程序创建了一个 ADB 通道。如果想要分析另外的应用，或者重启 Adb 服务，需要手动配置此通道。</p></li><li><p>配置方式：打开终端并输入如下内容。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200409101638825.png"></p><ol start="3"><li>** 为了开启 Android 中 Deep Profile，需要如下配置 **：</li></ol><p>(1) ** 开启 Mono Scripting 后端。Edit-&gt;ProjectSettings-&gt;Player-&gt;Android-&gt;OtherSetting**。</p><p><img src="https://img-blog.csdnimg.cn/20200409102145112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p>(2) 输入如下命令行：</p><p><img src="https://img-blog.csdnimg.cn/20200409102328817.png"></p><h1 id="Audio-Profiler-module"><a href="#Audio-Profiler-module" class="headerlink" title="Audio Profiler module"></a>Audio Profiler module</h1><h2 id="音频四个模块"><a href="#音频四个模块" class="headerlink" title="音频四个模块"></a>音频四个模块</h2><ol><li>音频主模块分类：</li></ol><p><img src="https://img-blog.csdnimg.cn/2020040821164155.png"></p><p><img src="https://img-blog.csdnimg.cn/20200408211033866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="2"><li>音频主模块各个部分的含义：</li></ol><p><img src="https://img-blog.csdnimg.cn/20200408211313106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="Simple-细节面板"><a href="#Simple-细节面板" class="headerlink" title="Simple 细节面板"></a>Simple 细节面板</h2><h3 id="Simple-细节面板显示："><a href="#Simple-细节面板显示：" class="headerlink" title="Simple 细节面板显示："></a>Simple 细节面板显示：</h3><p>注：**AudioClip 是一个声音片段，如：按钮点击，相当于是一首音乐 <strong>；</strong>AudioSource 是一个源，包含 AudioClip，还有其它一些属性，如：是否静音等，相当于是一个音乐播放器 **。</p><p><img src="https://img-blog.csdnimg.cn/20200408211626692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="Simple-细节面板各个参数含义："><a href="#Simple-细节面板各个参数含义：" class="headerlink" title="Simple 细节面板各个参数含义："></a>Simple 细节面板各个参数含义：</h3><ol><li><p>TotalAudioSources：场景中 AudioSource 的数量。</p></li><li><p>PlayingAudioSources：场景中正在破防的 Audio Source 的数量。</p></li><li><p>PausedAudioSources：场景中暂停播放的 Audio Source 的数量。</p></li><li><p>Audio Clip Count：场景中 Audio Clips 的总数量。</p></li><li><p>**Audio Voices：项目中使用的 Audio Channels（FMOD Channels）的数量 **。</p></li><li><p>Total Audio CPU：Audio 使用的 CPU 的数量（百分比）。</p></li><li><p>DSP CPU：</p></li></ol><ul><li>（数字信号处理）项目中通过 Mixing, Audio Effects，解压缩非流送的在内存中压缩类型的声音使用的 CPU 的数量（百分比）。</li><li>这并不包含 CPU 所需的 Unity 在背后解码的加载类型是解压并且有负载在背景标志中检查的声音。</li></ul><ol start="8"><li><p>Streaming CPU：应用中 CPU 在项目中使用流送 Audio 的耗费的百分比。</p></li><li><p>Other CPU：不被上面 CPU 包含的一般的 CPU 耗费（百分比）。</p></li><li><p>Total Audio Memory：在应用中使用的 Audio 的内存数量（M）。</p></li><li><p>Streaming File Memory：</p></li></ol><ul><li>加载类型为流式的音频文件在从磁盘逐步读取压缩音频数据时用于短期缓冲的内存数量。</li></ul><ol start="12"><li>Streaming Decode Memory:</li></ol><ul><li>加载类型为流送的 Audio 文件用来缓存解码后的采样流耗费的内存的数量。</li></ul><ol start="13"><li>Sample Sound Memory：</li></ol><ul><li>** 加载类型为解压加载的音频文件用于解压采样数据的内存量 **。</li><li></li></ul><p>**Unity 会把音频系统分配的内存集中起来，并且它会一直增长，直到应用程序的运行时间达到饱和 **。</p><p>-<br>** 音频系统在内部重用分配的内存，这些内存在运行时无法压缩 **。</p><ol start="14"><li>Other Memory：音频系统中各子系统引起的内存开销。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200409112456329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="Audio-Clip-的-LoadType"><a href="#Audio-Clip-的-LoadType" class="headerlink" title="Audio Clip 的 LoadType"></a>Audio Clip 的 LoadType</h3><p><img src="https://img-blog.csdnimg.cn/20200409141840943.png"></p><p><img src="https://img-blog.csdnimg.cn/2020040914180351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li>Decompress On Load：</li></ol><p>-<br>** 音频文件将在加载后立即解压缩 **。</p><p>-<br>** 将此选项用于较小的压缩声音，以避免动态解压缩的性能开销 **。</p><p>-<br>将 vorbis 编码的声音解压到负载上要比压缩它们多占用大约 10 倍的内存(对于 ADPCM 编码，大约是 3.5 倍)，因此 ** 不要将此选项用于大型文件 **。</p><ol start="2"><li>Compressed In Memory：</li></ol><p>-<br>** 保持声音压缩在内存中，当播放时才解压 **。</p><p>-<br>这个选项有轻微的性能开销(特别是对于 Ogg/Vorbis 压缩文件)，所以 ** 只在较大的文件中使用它，因为在加载时解压缩会占用大量的内存 **。</p><p>-<br>** 解压是发生在 mixer 线程，可以在 “DSP CPU” 部分的音频窗格的剖析器窗口中监视 **。</p><ol start="3"><li>Streaming：</li></ol><ul><li>动态解码声音。** 该方法使用最少的内存来缓冲从磁盘中增量读取并动态解码的压缩数据 **。</li><li>注意：解压发生在单独的流线程上，可以在 profiler 窗口的音频窗格的 “ Steaming CPU” 部分监视它的 CPU 使用情况。</li><li>Streaming clips 即使没有加载音频数据也有一个大约 200KB 的重载。</li></ul><h2 id="Dtaile-View："><a href="#Dtaile-View：" class="headerlink" title="Dtaile View："></a>Dtaile View：</h2><p>详细视图包含简单视图中的所有信息，另外还包含音频事件的每帧详细日志记录。</p><p><img src="https://img-blog.csdnimg.cn/2020040914400953.png"></p><h3 id="组视图与通道和组视图"><a href="#组视图与通道和组视图" class="headerlink" title="组视图与通道和组视图"></a>组视图与通道和组视图</h3><ol><li><p>Group 显示了音频 mixer 中总线的层次结构。</p></li><li><p>通道和组视图将显示此信息以及有关播放声音的信息。</p></li><li><p>Reset Play Count On Play：在下次单击 Player 窗口中的 play 或连接到新目标设备时重置 plays 列中的数字。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200409144045771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20200409144308565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="细节面板中各个属性值含义"><a href="#细节面板中各个属性值含义" class="headerlink" title="细节面板中各个属性值含义"></a>细节面板中各个属性值含义</h3><ol><li><p>Object：包含 AudioSource 播放 Audio 的 GameObject。</p></li><li><p>Asset:  对应的 GameObject 中 Audio Source 正在播放的音频 Asset。</p></li><li><p>Volume：Audio Source 应用到 Audio 上的音量。这是它整体音量特征和动态音量特征的的结合。动态音量适用于与距离相关的衰减曲线。</p></li><li><p>Audibility：Audio 播放的实际级别。这是 Audio Source 的音频和另外的 mixer 通道对其施加的其他衰减的总和。</p></li><li><p>**Players：Unity 播放此音频的数量。这个信息对调试逻辑错误可能很有用，因为 Unity 可能不会使用一些音频文件 **。</p></li><li><p>3D： 如果 Audio 使用动态距离想啊滚衰减和方向平移，则显示 Yes。</p></li><li><p>Paused：如果音频在此帧中是暂停的，则显示 YES。</p></li><li><p>Muted：如果音频在此帧中是静音的，则显示 YES。</p></li><li><p>Virtual:</p></li></ol><ul><li>如果 Audio 由于 Max Real Voice Count 被挂起，则显示为 YES。可以在 Project Settings 中的 Audio 中进行设置。</li><li>Max Real Voice Count 设置 Unity 同时播放的最大 AudioSources 的数量。</li><li>如果这显示为 True，则 Unity 有优先级更高的或 Audibility 的 Audio 在这一帧被播放。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200409151311346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="9"><li>OneShot：</li></ol><ul><li>如果 AudioSource.PlayOneShot()播放这个音频，则显示 YES。</li><li>其中第一个参数为 AudioClip，第二个参数为音量缩放值（0-1）。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200409151902523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="10"><li>Looped：如果 AudioSource.Play()播放音频，则显示 YES。</li></ol><p>11.** Distance：AudioSource 到 AudioListener 之间的距离 **。</p><ol start="12"><li>MinDist：</li></ol><p>-<br>在 AudioSource 曲线编辑器上定义的最小距离。</p><p>-<br>这定义了音频周围的一个球形区域，小于其值时音量保持在一个恒定的水平。</p><ol start="13"><li>MaxDist：</li></ol><ul><li>音频源曲线编辑器上定义的最大距离。</li><li>这定义了音频周围的一个球形区域，大于其值时音量保持在一个恒定的水平。</li></ul><ol start="14"><li><p>Time：Audio 回放的当前相关时间，当音频回放暂停时，时间不会往前走。</p></li><li><p>Duration：Audio 以秒为单位的长度。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200409144844366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h1 id="CPU-Usege-Module"><a href="#CPU-Usege-Module" class="headerlink" title="CPU Usege Module"></a>CPU Usege Module</h1><h2 id="图表类别"><a href="#图表类别" class="headerlink" title="图表类别"></a>图表类别</h2><ol><li>**CPU 使用情况探查器模块的图表跟踪在应用程序主线程上花费的时间 **。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200410102648778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="CPU-Usege-图表中各个模块及含义"><a href="#CPU-Usege-图表中各个模块及含义" class="headerlink" title="CPU Usege 图表中各个模块及含义"></a>CPU Usege 图表中各个模块及含义</h3><p>** 类别 **** 描述 <strong><strong>Rendering</strong> 应用程序花费多少时间来渲染图形。**Scripts</strong> 应用程序在运行脚本上花费了多少时间。<strong>Physics</strong> 应用程序在物理引擎上花费了多少时间。<strong>Animation</strong><br>应用程序花了多少时间来动画 SkinnedMeshRenderers，GameObject 和其他组件。这还包括花在计算 Animation 和 Animator 组件的系统上使用的时间<br><strong>GarbageCollector</strong> 应用程序花了多少时间运行垃圾回收器。<strong>VSync 垂直同步 **** 应用程序每帧花费多少时间等待 targetFrameRate 或下一个 VBlank 与之同步 <strong>。这取决于 QualitySetting.vSyncCount 值，目标帧速率或 VSync 设置，该设置是运行应用程序的平台的默认或强制最大值。</strong>Global Illunimation</strong> 应用程序在光照上花费了多少时间。<strong><strong>UI</strong></strong> 应用程序花费多少时间来显示其 UI。<strong>Other</strong> 应用程序花在不属于任何其他类别的代码上的时间。** 这包括整个 EditorLoop 或在 Profile 中配置播放模式时的性能分析开销等区域 **。</p><h2 id="模块详细信息窗格"><a href="#模块详细信息窗格" class="headerlink" title="模块详细信息窗格"></a>模块详细信息窗格</h2><p>当选择 “ CPU Usage” 模块时，其下方的详细信息窗格将显示应用程序在选定框架中花费时间的细分。可以将时序数据显示为时间轴或层次表；要更改显示，使用详细信息窗格中的左上方下拉菜单（默认设置为时间轴）。可用的三个视图是：</p><p>** 视图 **** 功能 <strong><strong>TimeLine</strong> 显示特定帧的时间细分，以及该帧长度的时间轴。</strong> 这是唯一可用于查看除主线程以外的线程上的时序并关联各个线程之间的时序的视图模式。<strong><strong>Hierarchy</strong> 按时序数据的内部层次结构对其进行分组。此选项以降序列表格显示应用程序调用的元素，默认情况下，这些元素按花费的时间排序。您还可以按分配的脚本内存量（<strong>GC Alloc</strong>）或调用次数来排序信息。要更改排序表的列，请单击表列的标题。**RawHierarchy</strong> 以类似于发生计时的调用堆栈的分层结构显示计时数据。**Unity 在这种模式下单独列出每个调用堆栈，而不是像在 “ 层次结构” 视图中那样合并它们 **。</p><h2 id="TimeLine-视图"><a href="#TimeLine-视图" class="headerlink" title="TimeLine 视图"></a>TimeLine 视图</h2><ol><li><p>时间轴视图是用于 CPU Usage 模块的默认视图。它概述了应用程序中的时间以及时间之间的关系。</p></li><li><p>**TimeLine 视图在其各自的子段中沿同一时间轴显示所有线程的概要分析数据 <strong>。</strong> 这与 Hierarchy 视图不同，后者仅显示来自主线程的概要分析数据 **。</p></li><li><p>** 可以使用时间轴视图来查看不同线程上的活动在并行执行中如何相互关联 **。可以查看正在使用不同线程的多少，例如 JobSystem 的工作线程，如何对这些线程进行排队，是否有任何线程处于空闲状态或正在等待另一个线程或一个 Job 来完成（Wait for X Sample）。</p></li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL3VwbG9hZHMvTWFpbi9wcm9maWxlci1jcHUtdGltZWxpbmUtdmlldy5wbmc?x-oss-process=image/format,png" alt="具有时间轴视图的 CPU 使用情况探查器模块"></p><h3 id="导航和选择条目"><a href="#导航和选择条目" class="headerlink" title="导航和选择条目"></a>导航和选择条目</h3><ol><li><p>使用鼠标上的滚轮或者 Alt + 鼠标右键来缩放时间轴上的区域。</p></li><li><p>使用 “A” 键来重置缩放，这样整个帧时间都可以看到。</p></li><li><p>使用鼠标中键或者 Alt + 鼠标左键来平移时间轴上的区域。</p></li><li><p>在下面窗口中选中 timeline 上某个小项，Profiler 将会突出显示其对 CPU 图表的贡献，使得其余部分变暗；若要取消该条目，直接点击视图中其余地方即可。另外，按 F 键将聚焦选择的当前样本。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200413112127618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="5"><li>单击并水平拖动到任何地方，以在时间轴的某个部分上显示覆盖，时间标尺在顶部显示的时间所涵盖的覆盖。</li></ol><h2 id="Hierarchy-and-和-Hierarchy-view"><a href="#Hierarchy-and-和-Hierarchy-view" class="headerlink" title="Hierarchy and 和 Hierarchy view"></a>Hierarchy and 和 Hierarchy view</h2><p><img src="https://img-blog.csdnimg.cn/20200413114834910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li><p>Hierarchy 视图列出了分析的所有样本，并根据它们的共享调用堆栈和 profilermarker 的层次结构将它们分组在一起。</p></li><li><p>原始的 Hierarchy 视图没有将样本分组在一起，这使得它非常适合在粒度级别上查看样本。</p></li><li><p>还可以使用 Thread 下拉菜单选择一个特定的线程，如 MainThread 或 RenderThread，以便在这些视图中进行检查。</p></li><li><p>这两个视图都在每一行旁边显示了层次结构中每个项目的以下详细信息:</p></li></ol><p>(1) Total：</p><ul><li>**Unity 在一个特定函数上花费的总时间 **，以百分比表示。</li></ul><p>(2) Self：</p><ul><li>Unity 在一个特定函数上花费的总时间百分比，不包括 Unity 调用子函数的时间。</li></ul><p>(3) Calls：</p><p>-<br>** 在这一帧中对这个函数的调用次数 **。</p><p>-<br>** 在 Raw 层次结构视图中，此列中的值始终为 1，因为分析器不会合并样本的层次结构 **。</p><p>(4) GC Alloc:</p><ul><li>** 当前帧中分配了多少脚本堆内存 **?</li><li>脚本堆内存由垃圾收集器管理。</li><li>** 每当 Unity 调用 GC.Collect()或者有一个脚本堆内存分配不适合当前堆内存的大小，垃圾收集器将会被触发，它标记所有的不再引用它们的分配并收集它们 **。</li><li>** 当在堆上分配更多内存时，Unity 会更频繁地运行垃圾收集器。随着托管堆的增长，Unity 需要更长的时间来标记和收集内存 <strong>。因此，</strong> 在应用程序运行时，应该将 GC Alloc 值保持为 0，以防止垃圾收集器影响帧速率，并保持总体堆大小较小 **。</li></ul><p>(5) Time(ms)：</p><ul><li>Unity 花费在一个特定函数上的时间。</li><li>** 如果应用程序使用作业系统或者多线程呈现，则此消息可能会导致误导，因为它只包含 Unity 花费在当前选择的线程上的时间 **。</li><li>如果要更改线程，选择 “层次结构” 窗格顶部的 “Thread” 下拉列表。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200413120736628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p>(6) Self(ms)：</p><ul><li>Unity 花费在一个特定函数上的总时间(以毫秒为单位)，不包括 Unity 调用子函数的时间。</li></ul><p>(7) Warning：</p><ul><li>由警告图标指示，这将显示应用程序在当前帧中触发警告的次数。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200413115216360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="5"><li>要获取关于应用程序 ** 在何处调用和使用 pfofilerd 函数 **，选择 “模块详细信息” 窗格右上角的 “详细信息” 下拉菜单，然后选择 “显示相关对象” 或“显示调用视图”。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200413121349231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="Show-Related-Objects-面板"><a href="#Show-Related-Objects-面板" class="headerlink" title="Show Related Objects 面板"></a>Show Related Objects 面板</h3><p><img src="https://img-blog.csdnimg.cn/20200413152040608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="Show-Calls-panel"><a href="#Show-Calls-panel" class="headerlink" title="Show Calls panel"></a>Show Calls panel</h3><ol><li><strong>Show Calls</strong> 视图显示所选择的 Samples 是从哪里被调用的，以及它调用的其他函数。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200413151354875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="2"><li>另外，可以在详细信息模块右上角顶部启用或者禁用 Collapse Editor Only Samples。这个 Collapses All Samples 在 Player 循环中仅仅在安全检查时发生。当 Samples 被折叠时，它们的 GC.Alloc 值对附加的 Samples 的 GC.Alloc 值没有影响。</li></ol><h3 id="Common-samples"><a href="#Common-samples" class="headerlink" title="Common samples"></a>Common samples</h3><p>除了脚本代码生成的样例之外，Unity 还提供了大量的样例，这些样例可以了解应用程序中哪些部分占用了时间。下表解释了一些更常见的样例的作用。</p><ol><li>Main thread 基本样例：主线程基本示例明确区分了花在应用程序上的时间和花在编辑器和分析器活动上的时间。记录器还可以使用这些样本来获取主线程上帧的计时。</li></ol><p>(1) PlayerLoop：</p><p>-<br>来自应用程序主循环的任何示例的根。</p><p>-<br>当玩家在编辑器中以活动播放模式运行时，目标是编辑器而不是 Playmode，此示例将嵌套在 EditorLoop 下。</p><p>(2) EditorLoop：</p><ul><li>来自编辑器主循环的任何示例的根。</li><li>这仅在编辑器中配置一个播放器时出现。</li><li>当使用剖析器定位 Playmode 时，这个例子显示了渲染和运行包含播放器的编辑器花费了多少帧时间。</li><li>如果希望看到编辑器在这段时间内做了什么，将目标切换到编辑器。</li></ul><p>(3) Profiler.CollectEditorStats</p><ul><li>与为不同的活动分析器模块收集统计信息相关的任何示例的根。</li><li>要关闭特定模块，请关闭它们的图表或调用 Profiler.SetAreaEnabled()</li></ul><p><img src="https://img-blog.csdnimg.cn/20200413153100954.png"></p><ol start="2"><li>Script update 示例：除非使用的是作业系统，否则大部分脚本代码是嵌套在下面的示例中:</li></ol><p><strong>Sample<strong><strong>Function</strong></strong>Update.ScriptRunBehaviourUpdate</strong>This sample includes calls to <code>MonoBehaviour.Update</code> and processing of coroutines.<strong>BehaviourUpdate</strong>This sample processes all <code>Update()</code> methods.<strong>CoroutinesDelayedCalls</strong>Contains coroutine samples after their first yield.<strong>PreLateUpdate.ScriptRunBehaviourLateUpdate</strong>This sample processes all <code>LateUpdate()</code> methods.<strong>FixedBehaviourUpdate</strong>This sample processes all <code>FixedUpdate()</code> methods.</p><ol start="3"><li>Rendering and VSync 示例：</li></ol><p>** 这些示例显示了 CPU 在哪些地方花费时间为 GPU 处理数据，或者它可能在哪些地方等待 GPU 完成 <strong>。如果 GPU 分析器不可用，或者它增加了太多的开销，工具栏不会显示这些信息。</strong> 这些示例可以让您了解应用程序是 cpu 受限还是 GPU 受限。**</p><p><strong>Sample<strong><strong>Function</strong></strong>WaitForTargetFPS</strong>The time your application spends waiting for the targeted FPS that <a href="https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html">Application.targetFrameRate</a> specifies.</p><p>If this sample is a sub-sample of <strong>Gfx.WaitForPresent</strong>, it represents the amount of time your application spends waiting for the VSync configured in <a href="https://docs.unity3d.com/ScriptReference/QualitySettings-vSyncCount.html">QualitySettings.vSyncCount</a>.</p><p><strong>Note:</strong> The Editor doesn’t VSync on the GPU and instead uses <strong>WaitForTargetFPS</strong> to simulate the delay for VSync. Some platforms, in particular Android and iOS, enforce VSync or have a default frame rate cap of 30 or 60.<strong>Gfx.ProcessCommands</strong>Contains all processing of the rendering commands on the render thread. Some of that time might be spent waiting for VSync or new commands from the main thread, which you can see from it’s child sample <strong>Gfx.WaitForPresent</strong>.<strong>Gfx.WaitForCommands</strong>Indicates that the render thread is ready for new commands and might indicate a bottle neck on the main thread.<strong>Gfx.PresentFrame</strong>Indicates the time your application spends waiting for the GPU to render and present the frame, which might include waiting for VSync.</p><p>A <strong>WaitForTargetFPS</strong> sample on the main thread shows how much of that time is spent waiting for VSync.<strong>Gfx.WaitForPresent</strong>Indicates that the main thread is ready to start rendering the next frame, but the render thread has not finished waiting on the GPU to present the frame. This might indicate that your application is GPU-bound. To see what the render thread is simultaneously spending time on, check the Timeline view.</p><p>If the render thread spends time in <strong>Camera.Render</strong>, your application is CPU-bound and might be spending too much time sending draw calls or textures to the GPU.</p><p>If the render thread spends time in <strong>Gfx.PresentFrame</strong>, your game is GPU-bound or it might be waiting for VSync on the GPU. A <strong>WaitForTargetFPS</strong> sub-sample of <strong>GFX.WaitForPresent</strong> indicates the portion of the Present phase that your application spends waiting for VSync. The Present phase is the portion of time between Unity instructing the graphics API to swap the buffers, to the time that this operation is completed<strong>Gfx.WaitForRenderThread</strong>Indicates that the main thread is waiting for the render thread to process all the commands currently in its command stream. This sample only occurs in multithreaded rendering.</p><ol start="4"><li>Multi threading 示例：</li></ol><p>These samples do not consume CPU cycles but instead highlight information that relates to threading and the JobSystem. When you see these samples, use the <a href="https://docs.unity3d.com/Manual/ProfilerCPU.html#timeline">Timeline view</a> to check what’s happening on other threads at the same time.</p><p><strong>Sample<strong><strong>Function</strong></strong>Idle</strong>Any time that the JobSystem does not utilize a Worker Thread, it emits an <strong>Idle</strong> sample. Small gaps between <strong>Idle</strong> samples usually happen when the JobSystem wakes them up, for example to schedule new Jobs. Longer gaps indicate a native Job that has not been instrumented.<strong>Semaphore.WaitForSignal</strong>This thread is waiting for something to finish on another thread. To find the thread it is waiting for, check the <strong>Timeline</strong> view for any samples that ended shortly before this one.<strong>WaitForJobGroupID</strong>A Sync Fence on a JobHandle was triggered. This might lead to <a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobParallelFor.html">work stealing</a>, which happens when a worker finishes its work and then looks at other workers’ jobs to complete. These show up as job samples executed under this sample. Jobs that were “stolen” are not necessarily the jobs that were being waited on.</p><ol start="5"><li>Physics 示例：</li></ol><p>The following table outlines some of the high-level physics Profiler samples. <code>FixedUpdate()</code> calls all of these samples.</p><p><strong>Sample<strong><strong>Function</strong></strong>Physics.Simulate</strong>Updates the state of the current physics by instructing the physics engine to run its simulation.<strong>Physics.Processing</strong>Processes all non-cloth physics jobs. Expand this sample to show the low-level detail of the work done internally in the physics engine.<strong>Physics.ProcessingCloth</strong>Processes all cloth physics jobs. Expand this sample to show the low-level detail of the work done internally in the physics engine.<strong>Physics.FetchResults</strong>Collects the results of the physics simulation from the physics engine.<strong>Physics.UpdateBodies</strong>Updates all the physics bodies’ positions and rotations. This sample also contains messages that communicate when these updates are sent.<strong>Physics.ProcessReports</strong>Runs once the physics <code>FixedUpdate</code> ends. Processes the various stages of responding to the results of the simulation. Contacts, <strong>joint</strong><br>breaks and triggers update and message in this sample. There are four distinct sub stages: <strong>Physics.TriggerEnterExits</strong>Processes <code>OnTriggerEnter</code> and <code>OnTriggerExit</code> events. <strong>Physics.TriggerStays</strong>Processes <code>OnTriggerStay</code> events. <strong>Physics.Contacts</strong>Processes <code>OnCollisionEnter</code>, <code>OnCollisionExit</code>, and <code>OnCollisionStay</code> events. <strong>Physics.JointBreaks</strong>Processes updates and messages relating to broken joints.<strong>Physics.UpdateCloth</strong>Contains updates relating to cloth and their Skinned Meshes.<strong>Physics.Interpolation</strong>Manages the interpolation of positions and rotations for all the physics objects.</p><h3 id="Show-Related-Objects-面板-1"><a href="#Show-Related-Objects-面板-1" class="headerlink" title="Show Related Objects 面板"></a>Show Related Objects 面板</h3><p><img src="https://img-blog.csdnimg.cn/2020041314220894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li><p>ShowRelatedObjects 视图显示与 Profiler 示例中相关的 UnityEngine.Objects 的列表。</p></li><li><p>如果在编辑器中 Profile，Unity 将会通过实例 ID 报告这些对象，并在 Profiler 窗口将他们解析为一个名称。当配置一个已构建的播放器，或从磁盘加载捕获时，这些名称不会出现，而是显示为“N/A”。</p></li><li><p>对于 GC.Alloc 示例中，显示了一个 “N/A” 项列表，如 ** 果在选择 GC 时，在启用调用堆栈设置的编辑器中配置应用程序, 在这个视图中，将显示选择的已分配脚本对象的调用堆栈，即使没有启用深度分析设置 **。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/2020041314273277.png"></p><h2 id="Performance-warnings"><a href="#Performance-warnings" class="headerlink" title="Performance warnings"></a>Performance warnings</h2><p><img src="https://img-blog.csdnimg.cn/20200413150151100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p>Profiler 可以检测一些在性能关键的上下文中应该避免的特定调用：</p><ul><li><strong><strong>Rigidbody</strong>.SetKinematic:</strong> 为供给重建非凸网格对撞机。</li><li><strong>Animation.DestroyAnimationClip:</strong> 触发重建内部状态。</li><li><strong>Animation.AddClip:</strong> triggers RebuildInternalState</li><li><strong>Animation.RemoveClip:</strong> triggers RebuildInternalState</li><li><strong>Animation.Clone:</strong> triggers RebuildInternalState</li><li><strong>Animation.Deactivate:</strong> triggers RebuildInternalState</li></ul><h2 id="Allocation-call-stacks"><a href="#Allocation-call-stacks" class="headerlink" title="Allocation call stacks"></a>Allocation call stacks</h2><ol><li><p>默认情况下，在 GC.Alloc Samples 上分配调用堆栈是禁用的，因为他们会导致多帧延迟扰乱应用程序。</p></li><li><p>启用方法：导航到 Profiler 窗口的工具栏，并选择 Call stack 按钮。</p></li><li><p>无论是在编辑器中配置文件还是在正在运行的播放器中配置文件，都可以使用此功能。** 在打开这个选项后的帧中，GC.Alloc Samples 包含它们的 callstack<strong>。在层次结构视图和时间轴视图中，每个脚本堆分配都显示为一个 GC.Alloc Samples。</strong> 在时间轴视图中，它的颜色为明亮的洋红色 **。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200413145055483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol start="4"><li>或者，可以在层次结构或原始层次结构视图中查看调用堆栈。设置 Details 视图以显示相关对象。** 因为 GC.Alloc 样本没有名字，它们在这个面板中显示为 N/A。当您选择一个 N/A 对象时，分析器会在 details 视图的下半部分显示调用堆栈 **。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200413145059266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="Editor-only-samples"><a href="#Editor-only-samples" class="headerlink" title="Editor only samples"></a>Editor only samples</h2><p>一些 Samples 只有在编辑器中进行概要分析时才会出现。这包括安全检查，校验一致性，验证对象设置，销毁检查和 Prefab-related 激活，所有上述这些 Samples 都不存在于播放器中。</p><p>** 默认情况下，只编辑的示例在 Hierarchy 视图中折叠，并命名为 EditorOnly [SampleName]**。虽然它们可能会导致垃圾收集分配，但如果他们被折叠，将不会对 GC.Alloc 造成影响。</p><p>要更改默认行为，单击 “模块详细信息” 窗格右上角的上下文菜单，并禁用 “Collapse EditorOnly 样例” 设置。当您这样做时，您可以扩展 Samples 并贡献它的 GC.Alloc 值。</p><p><img src="https://img-blog.csdnimg.cn/20200413144758109.png"></p><h1 id="Global-Illumination"><a href="#Global-Illumination" class="headerlink" title="Global Illumination"></a>Global Illumination</h1><p><img src="https://img-blog.csdnimg.cn/20200413155009185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="图表分类："><a href="#图表分类：" class="headerlink" title="图表分类："></a>图表分类：</h2><p><img src="https://img-blog.csdnimg.cn/20200413155110286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="细节面板"><a href="#细节面板" class="headerlink" title="细节面板"></a>细节面板</h2><p><img src="https://img-blog.csdnimg.cn/20200413155233961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h1 id="GPU-Usage-Profiler"><a href="#GPU-Usage-Profiler" class="headerlink" title="GPU Usage Profiler"></a>GPU Usage Profiler</h1><ol><li>模块显示应用程序在 GPU 中花费的时间。你只能在播放模式中使用 GPU 分析器，或者在应用程序的构建中使用。不能使用它来配置编辑器。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200413155442634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="GPU-Profiler-支持列表"><a href="#GPU-Profiler-支持列表" class="headerlink" title="GPU Profiler 支持列表"></a>GPU Profiler 支持列表</h2><p><img src="https://img-blog.csdnimg.cn/20200413155714118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="图表分类"><a href="#图表分类" class="headerlink" title="图表分类"></a>图表分类</h2><p><img src="https://img-blog.csdnimg.cn/20200413155904660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="模块细节面板"><a href="#模块细节面板" class="headerlink" title="模块细节面板"></a>模块细节面板</h2><p><img src="https://img-blog.csdnimg.cn/20200413160046815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20200413160248928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h1 id="Momory-Profiler-Module"><a href="#Momory-Profiler-Module" class="headerlink" title="Momory Profiler Module"></a>Momory Profiler Module</h1><ol><li>有两种内存分析方法：</li></ol><p>(1) Memory Profiler Module：</p><ul><li>这是 Profiler 窗口中的一个内置模块，它为您提供关于应用程序在何处使用内存的基本信息。</li></ul><p>(2) Memory Profiler Package：</p><ul><li>这是一个单独的包，可以将其添加到项目中。</li><li>它为 Unity 编辑器增加了一个额外的内存分析器窗口，你可以用它来更详细地分析你的应用程序的内存使用情况。</li><li>** 可以存储和比较快照来更容易地找到内存泄漏，或者查看内存布局来找到内存碎片问题 **。</li><li><a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@0.2/manual/index.html">https://docs.unity3d.com/Packages/com.unity.memoryprofiler@0.2/manual/index.html</a></li></ul><h2 id="Momory-Profiler-概述"><a href="#Momory-Profiler-概述" class="headerlink" title="Momory Profiler 概述"></a>Momory Profiler 概述</h2><ol><li><p>内存分析器模块可视化表示应用程序中分配的总内存的计数器。可以 ** 使用内存模块查看诸如加载对象的数量以及它们在每个类别中占用的总内存等信息。还可以看到每个 Profiler 帧的 GC 分配数量 **。</p></li><li><p>要获得更精确的数字和应用程序的内存使用情况，请通过 “附加到播放器” 菜单将分析器连接到正在运行的播放器。这允许您查看目标设备上的实际使用情况。</p></li></ol><h2 id="图表分类-1"><a href="#图表分类-1" class="headerlink" title="图表分类"></a>图表分类</h2><p><img src="https://img-blog.csdnimg.cn/20200414104055790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="Module-details-pane"><a href="#Module-details-pane" class="headerlink" title="Module details pane"></a>Module details pane</h2><p><img src="https://img-blog.csdnimg.cn/20200414104519841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h3 id="Simple-view"><a href="#Simple-view" class="headerlink" title="Simple view"></a>Simple view</h3><p>Simple View 显示了在每一帧上 Unity 实时有多少内存被使用的概述。**Unity 为分配预留了内存池，以避免过于频繁地向操作系统请求内存 <strong>。</strong> 这将显示为一个保留的数量，以及它使用的数量 **。</p><ol><li><p>Total：下面区域的所有累计值。</p></li><li><p>Unity:</p></li></ol><ul><li>Unity 本地代码中的内存分配量</li><li>由本地内存管理器系统跟踪，并根据它们的类型、源和平台特定的分配模式在内存池中分配。</li></ul><ol start="3"><li>Mono：</li></ol><ul><li>** 托管代码使用的总堆大小和使用的堆大小。这个内存被垃圾回收 **。</li></ul><ol start="3"><li>Gfx Driver：</li></ol><ul><li>** 驱动程序在纹理、渲染目标、着色器和网格数据上使用的估计内存量 **。</li></ul><ol start="4"><li><p>Audio：音频系统的估计内存使用量</p></li><li><p>Video：视频系统的估计内存使用量</p></li><li><p>Profiler：分析器使用的总内存</p></li><li><p>分析器还列出了一些最常见的 Assets 和游戏对象类型的内存统计信息。这些统计数据包括 ** 计数 (在正斜杠之前) 和使用的内存 <strong>。在这个列表中，</strong>Total Object Count 显示应用程序创建的本地游戏对象的总数。如果这个数字随着时间的推移而增加，你的应用程序将创建游戏对象，而不会销毁它们 **。</p></li></ol><h3 id="Detail-View"><a href="#Detail-View" class="headerlink" title="Detail View"></a>Detail View</h3><p>可以使用详细视图获取应用程序当前状态的快照。单击 Take Sample 按钮以捕获当前目标的详细内存使用情况。分析器需要花费大量的时间来获取这些数据，因此详细视图不会提供实时的详细信息。Profiler 获取样本后，Profiler 窗口将显示一个树视图，可以在其中更详细地查看应用程序的内存使用情况。</p><p><img src="https://img-blog.csdnimg.cn/20200414110814167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li><p>开启 “Gather Object references” 设置将会手机关于在快照时引用对象的内容的信息，信息显示在窗口的右侧窗格中。</p></li><li><p>在树视图中，使用内存的对象分为以下几类：</p></li></ol><ul><li><strong>Other:</strong> <strong>Objects that are neither assets, GameObjects, or components</strong>. Information such as used memory Unity uses for different systems can be found here.</li><li><strong>Not Saved</strong>: <strong>Objects marked as <a href="https://docs.unity3d.com/ScriptReference/HideFlags.html">DontSave</a></strong></li><li><strong>Builtin Resources</strong>: <strong>Unity Editor resources or Unity default resources</strong>, such as Shaders you have added to the Always Included Shaders list of the Graphics settings.</li><li><strong>Assets: Assets referenced from user or native code</strong></li><li><strong>SceneMemory: Objects and attached components</strong></li></ul><p><strong>Note:</strong> In the <strong>Other</strong> category, memory reported under <strong>System.ExecutableAndDlls</strong> is read-only memory. The operating system might discard these pages as needed and later reload them from the file system. This generates lower memory usage, and usually does not directly contribute to the operating system’s decision to close your application if it uses too much memory. Some of these pages might also be shared with other applications that are using the same frameworks.</p><h1 id="Rendering-Profiler"><a href="#Rendering-Profiler" class="headerlink" title="Rendering Profiler"></a>Rendering Profiler</h1><p><img src="https://img-blog.csdnimg.cn/2020041411343120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li><p>渲染分析器显示渲染统计数据。</p></li><li><p>与 Game 创口的 Static 数据很相近。</p></li></ol><h1 id="Video-Profiler-Module"><a href="#Video-Profiler-Module" class="headerlink" title="Video Profiler Module"></a>Video Profiler Module</h1><ol><li>Video Profiler 模块显示关于应用程序中视频使用的资源的信息，如内存、缓冲和视频剪辑的数量。可以使用它来确定应用程序在选定平台上回放和缓冲视频的效率。也可以使用 CPU 使用率分析器模块来评估 Unity 在视频上花费的时间。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200414114905853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="图表种类："><a href="#图表种类：" class="headerlink" title="图表种类："></a>图表种类：</h2><p><img src="https://img-blog.csdnimg.cn/20200414115024492.png"></p><h2 id="模块细节面板-1"><a href="#模块细节面板-1" class="headerlink" title="模块细节面板"></a>模块细节面板</h2><p><img src="https://img-blog.csdnimg.cn/20200414115301355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h1 id="UI-And-UI-Details-Profiler"><a href="#UI-And-UI-Details-Profiler" class="headerlink" title="UI And UI Details Profiler"></a>UI And UI Details Profiler</h1><p><img src="https://img-blog.csdnimg.cn/20200414140600476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li><p>UI 和 UI Detail 模块提供关于 Unity 花费多少时间和资源在应用程序中布局和呈现用户界面的信息。</p></li><li><p>可以使用这个模块理解 <strong>Unity 如何处理应用程序中的 UI 批处理，包括为什么以及如何批处理对象。</strong></p></li><li><p>还可以使用此模块来查找 UI 的哪个部分导致了缓慢的性能，或者在清除时间轴时预览 UI。</p></li></ol><h2 id="图表分类-2"><a href="#图表分类-2" class="headerlink" title="图表分类"></a>图表分类</h2><p><img src="https://img-blog.csdnimg.cn/20200414141425277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="Module-Details-Pane"><a href="#Module-Details-Pane" class="headerlink" title="Module Details Pane"></a>Module Details Pane</h2><p><img src="https://img-blog.csdnimg.cn/20200414141831477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li><p>Object：应用程序在分析期间使用的 UI 画布列表。双击一行以突出显示场景中匹配的对象。</p></li><li><p>Self Batch Count：Unity 为 canvas 生成了多个个 batches。</p></li><li><p>Cumulative Batch Count：累积的 Batch 数目。Unity 为 Canves 和所有它嵌套的 Canvase 生成了多少个 Batches。</p></li><li><p>Self Vertex Count：Canvas 渲染了多少个顶点。</p></li><li><p>Cumulative Batch Count：Canvas 乐基渲染了多少个顶点。</p></li><li><p>Batch Breaking Reason：</p></li></ol><ul><li>为什么 Unity 割裂批处理 batch。有些时候 Unity 可能无法将对象批处理在一起。常见原因如下：</li><li>没有与 Canvas 共面。批处理需要对象的 rect 变换和 Canvas 共面。</li><li>CanvasInjectionIndex：存在一个 CanvasGroup 组件，并强制执行一个新的批处理，比如在其他的组件上显示一个组合框的下拉列表。</li><li>不同的材质实例，矩形裁剪，纹理或 A8TexrtureUsage。其中 **Unity 只能批量使用相同的材质，masking，纹理和纹理通道使用的对象 **。</li></ul><ol start="7"><li><p>GameObjectCount：Batch 中有多少个 GameObject。</p></li><li><p>GameObjects：批处理中的 GameObject 列表。当您从列表中选择一个 UI 对象时，它的预览将出现在窗格的右侧。在预览上方，工具栏中有以下选项：</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200414143625912.png"></p><p>(1) Detach：选择此按钮可在单独的窗口中打开 UI 画布。要重新安装窗口，请关闭它。</p><p>(2) Preview Background：使用下拉菜单改变预览背景的颜色。你可以从棋盘格、黑色或白色中选择。如果你的 UI 有一个特别亮或暗的配色方案，这是非常有用的。</p><p>(3) 预览类型：使用下拉菜单从标准、透支或复合透支中进行选择。</p><h1 id="Physics-Profiler-Module"><a href="#Physics-Profiler-Module" class="headerlink" title="Physics Profiler Module"></a>Physics Profiler Module</h1><p><img src="https://img-blog.csdnimg.cn/20200414144556576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="图表分类-3"><a href="#图表分类-3" class="headerlink" title="图表分类"></a>图表分类</h2><p><img src="https://img-blog.csdnimg.cn/20200414144700348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><ol><li>Active Dynamic：</li></ol><ul><li>激活的非运动学刚体部件的数量。一个激活的刚体是不休眠的。</li></ul><ol start="2"><li>Active Kinematic：</li></ol><ul><li>激活的动力学刚体组件的的数量</li><li>当在一帧中调用 MovePosition 或 MoveRotation 时，运动学刚体处于激活状态，并在下一帧中保持活动状态。</li></ul><p>-<br>Unity 可能每帧处理具有 joints 的运动学刚体组件多次，这有助于值的呈现。</p><ol start="3"><li><strong>Static Colliders</strong>：</li></ol><ul><li>** 没有刚体组件附加到的 GameObject 或者它们的父 GameObject 的 GameObject 上面的 Collider 组件的数量 **。</li><li>具有 Rigidbody 组件的 GameObjects 或 parent GameObjects 上的碰撞器组件不算作静态碰撞器。这些被称为复合碰撞器。</li><li>复合碰撞器以一种方便的方式来安排一个物体的多个碰撞器，而不是将所有的碰撞器都放在与刚体组件相同的 GameObject 上。</li></ul><ol start="4"><li>Rigidbody：</li></ol><ul><li>由物理引擎处理的刚体组件的数量，与组件的休眠状态无关。</li></ul><ol start="5"><li>Trigger Overlaps：</li></ol><ul><li>重叠触发器的数量(成对计数)。</li></ul><ol start="6"><li>Active Constraints：</li></ol><p>-<br>物理引擎处理的原始约束的数量。** 约束被用作关节和碰撞响应的构件 **。</p><p>-<br>例如，限制一个可配置关节的线性或旋转自由度涉及到每个约束的基本约束。</p><ol start="7"><li>Contacts：</li></ol><p>-<br>场景中所有碰撞器之间的接触对的总数，包括触发重叠对的数量。</p><p>-<br>触点是一对相互接触或重叠的碰撞体。</p><p>-<br>当它们之间的距离低于某个用户可配置的限制时，Unity 为每一对碰撞器创建接触对。因此，您可能会看到为刚体组件生成的接触，这些组件还没有接触或重叠。</p><p>注意：剖析器中显示的数字可能与场景中包含物理组件的 GameObjects 的确切数量不一致。这是因为 Unity 以不同的速率处理一些物理组件，这取决于其他组件对它的影响(例如，一个附加的联合组件)。要计算带有特定物理组件的 GameObjects 的确切数量，必须使用 FindObjectsOfType 函数编写一个自定义脚本。** 物理分析器模块不显示睡眠刚体组件的数量。这些组件不参与物理引擎，因此不被分析器处理。**</p><h2 id="使用物理分析器来理解性能问题"><a href="#使用物理分析器来理解性能问题" class="headerlink" title="使用物理分析器来理解性能问题"></a>使用物理分析器来理解性能问题</h2><ol><li>物理模拟运行在从主逻辑更新循环的一个独立的固定评率更新周期，并只能通过 Time.fixedDeltaTime 每次调用来向前。这和 Update 和 FixedUpdate 之间的不同很相似。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200414150420630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h1 id="2D-Physics-Profiler-Module"><a href="#2D-Physics-Profiler-Module" class="headerlink" title="2D Physics Profiler Module"></a>2D Physics Profiler Module</h1><p><img src="https://img-blog.csdnimg.cn/20200414151644435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="图表种类：-1"><a href="#图表种类：-1" class="headerlink" title="图表种类："></a>图表种类：</h2><p><img src="https://img-blog.csdnimg.cn/20200414151750435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><h2 id="模块细节面板-2"><a href="#模块细节面板-2" class="headerlink" title="模块细节面板"></a>模块细节面板</h2><p><img src="https://img-blog.csdnimg.cn/2020041415191085.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva3lvXzIwMjQ=,size_16,color_FFFFFF,t_70"></p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Software" scheme="https://tamsiree.com/categories/Software/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/categories/Software/Unity/"/>
    
    
    <category term="Software" scheme="https://tamsiree.com/tags/Software/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 性能分析优化</title>
    <link href="https://tamsiree.com/Software/Unity/Unity%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96/"/>
    <id>https://tamsiree.com/Software/Unity/Unity%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96/</id>
    <published>2022-01-05T11:13:40.000Z</published>
    <updated>2025-11-05T13:53:39.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Unity Accelerate Solution 团队对 Unity 引擎的源代码了如指掌，可帮助客户们最大限度地利用引擎。团队的日常工作包括深入剖析客户项目，搜寻其在速度、稳定性与效率方面有待优化的部分。本次，我们请到了这支 Unity 最为资深的软件工程师团队来分享一些移动游戏优化方面的专业知识。</p><p>他们分享了非常多的锦囊妙计，以至于一篇博文很难涵盖所有内容。因此，我们将推出一个博文系列。作为此系列的首篇文章，我们将着重介绍 ** 怎样借助性能分析、内存优化和代码架构来提高游戏的性能 **。在未来的几周内，我们将再发表两篇文章：一篇讨论 UI Physics，另一篇讨论音频和资源、项目配置和图形。</p><p>话不多说，直接开讲！</p><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="** 性能分析 **"></a>** 性能分析 **</h1><p>优化工作的第一个步骤便是通过性能分析来收集性能数据，这也是移动端优化的第一步。</p><p>** 我们要尽早在目标设备上进行性能分析，而且要经常分析。**</p><p>**Unity Profiler ** 可提供应用关键的性能信息，因此是优化必不可少的一部分。尽早对项目进行性能分析，不要拖到发售前。对每一个故障或性能尖峰彻查到底。对你自己的项目性能有一个清晰的认知，可帮助你更轻松地发现新问题。</p><p>Unity 编辑器内的性能分析可以揭示出游戏不同系统的相对性能，而在运行设备上进行分析可让你获取更为准确的性能洞察。经常性地在目标设备上分析开发版。同时为最高配置与最低配置的设备进行性能分析和优化。</p><p>除了 Unity Profiler，你还可以使用 iOS 与 Android 的原生工具来进一步测试引擎在平台上的表现。</p><p>-<br>比如 iOS 的 Xcode 和 Instruments</p><p>-<br>以及 Android 上的 Android Studio 和 Android Profiler</p><p>部分硬件更是带有额外的分析工具（例如 Arm Mobile Studio、Intel VTune 以及 Snapdragon Profiler）。</p><p>Unity Profiler：</p><p><a href="https://docs.unity3d.com/Manual/Profiler.html">https://docs.unity3d.com/Manual/Profiler.html</a></p><p>Xcode：</p><p><a href="https://developer.apple.com/documentation/xcode/">https://developer.apple.com/documentation/xcode/</a></p><p>Instruments：</p><p><a href="https://help.apple.com/instruments/mac/current/#/dev7b09c84f5">https://help.apple.com/instruments/mac/current/#/dev7b09c84f5</a></p><p>Android Studio：</p><p><a href="https://developer.android.com/studio/intro">https://developer.android.com/studio/intro</a></p><p>Android Profiler：</p><p><a href="https://developer.android.com/studio/profile/android-profiler">https://developer.android.com/studio/profile/android-profiler</a></p><p>Arm Mobile Studio：</p><p><a href="https://developer.arm.com/tools-and-software/graphics-and-gaming/arm-mobile-studio">https://developer.arm.com/tools-and-software/graphics-and-gaming/arm-mobile-studio</a></p><p>Intel VTune：</p><p><a href="https://software.intel.com/content/www/us/en/develop/documentation/vtune-help/top.html">https://software.intel.com/content/www/us/en/develop/documentation/vtune-help/top.html</a></p><p>Snapdragon Profiler：</p><p><a href="https://developer.qualcomm.com/software/snapdragon-profiler">https://developer.qualcomm.com/software/snapdragon-profiler</a></p><p>** 针对性优化 **</p><p>如果游戏出现性能问题，切忌自行猜测或揣测成因，一定要使用 Unity Profiler 和平台专属工具来准确找出卡顿的问题来源。</p><p>不过，这里所说的优化并不都适用于你的应用。在某个项目中适用的方法不一定适用于你的项目。找出真正的性能瓶颈，将精力集中在有实际效用的地方。</p><p>** 了解 Unity Profiler 工作原理 **</p><p>Unity Profiler 可帮助你在运行时检测出卡顿或死机的原因，更好地了解特定帧或时间点上发生了什么。工具默认启用 CPU 和内存监测轨，你也可以根据需要启用额外的分析模块，包括渲染器、音频和物理（如极度依赖物理模拟的游戏或音游）。<br><img src="//i0.hdslb.com/bfs/article/6ac731c04f79e093381f0a7817a6137616712e49.png@942w_561h_progressive.webp">或使用 Unity Profiler 来测试应用程序的性能和资源分配<br>勾选 ** Development Build** 便能为目标设备构建应用，勾选 ** Autoconnect Profiler ** 或者手动关联分析器，来加快其启动时间。<br><img src="//i0.hdslb.com/bfs/article/02273c31c34e7677331e25943bd283f9bef50f77.png@942w_939h_progressive.webp"><br>选中需要分析的目标平台。按下 <strong>Record（录制）</strong> 按钮可记录应用在几秒钟内的运行（默认为 300 帧）。打开 **Unity &gt; Preferences &gt; analysis &gt; Profiler &gt; Frame Count ** 界面可修改录制帧数，最长录制帧数可以增加到 2000 帧。当然更长的录制帧数会让 Unity 编辑器占用更多的 CPU 资源和内存，但其在特定情形下的作用非常大。</p><p>该分析器采用标记框架，可分析以 ProfileMarkers（如 MonoBehaviour 的 Start 或 Update 方法，或特定 API 调用）划分出的代码运行时。在使用 Deep Profiling 时，Unity 可以分析出每次函数调用的开始与结尾，准确地呈现出导致应用性能放缓的代码部分。</p><p>ProfileMarkers：</p><p><a href="https://docs.unity.cn/ScriptReference/Unity.Profiling.ProfilerMarker.html">https://docs.unity.cn/ScriptReference/Unity.Profiling.ProfilerMarker.html</a></p><p>Deep Profiling：</p><p><a href="https://docs.unity.cn/cn/current/Manual/ProfilerWindow.html">https://docs.unity.cn/cn/current/Manual/ProfilerWindow.html</a><br><img src="//i0.hdslb.com/bfs/article/d021ae76ee484d3f79417c6d83e4d86086b7d931.png@942w_591h_progressive.webp">你可以借助 Timeline 视图来明确应用最为依赖的是 CPU 还是 GPU<br>在分析游戏时，我们建议同时分析性能高峰与帧平均成本。在分析帧率过低的应用时，较为有效的方法是分析并优化每一帧中运行成本较高的代码。在尖峰处首先分析繁重的运算（如物理、AI、动画）和垃圾数据收集。</p><p>点击窗口中的某帧，接着使用 **Timeline ** 或 **Hierarchy ** 视图进行分析：</p><p>-<br>**Timeline ** 可显示特定帧耗时的可视化图表，帮助你直观地看到各项活动以及不同线程之间的关系。你可使用该选项来了解项目主要依赖的是 CPU 还是 GPU。</p><p>-<br><strong>Hierarchy</strong> 将显示分组的 ProfileMarkers 层级，并以毫秒（Time ms’总耗时’和 Self ms‘自执行耗时’）为单位对样本进行排序。你还可以数出帧上函数的 Calls 调用以及内存清理（GC Alloc）的次数。</p><p><img src="//i0.hdslb.com/bfs/article/67e48fa4ce17149b433732058821b9518d43a1ad.png@942w_593h_progressive.webp">Hierarchy 视图允许按照耗时长短对 ProfileMarkers 进行排序<br>注意，在优化任意项目之前，一定要保存 Profiler 的 .data 文件，这样你就能在修改后比较优化前后的不同了。剖析、优化和比较，清空再重复，如此循环往复来提高性能。</p><p><strong>Profiler analyzer</strong></p><p>该工具可以汇总多帧 Profiler 数据，由用户来挑选出那些问题较大的帧。如果你想了解项目更改后 Profiler 的相应改变，可使用 Compare 视图分别加载和比较两个数据集，从而完成测试与优化。Profile analyzer 可在 Unity Package Manager 中下载。</p><p>Profile analyzer：</p><p><a href="https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.0/manual/index.html</a><br><img src="//i0.hdslb.com/bfs/article/1661089763ed2fb26174a97c28bd41e76d4ba657.png@942w_620h_progressive.webp">Profiler analyzer 可以很好地补充 Profiler，可以进一步深入分析帧与标记数据<br>**<br>**</p><p>** 为每帧设定一个时间预算 **</p><p>你可以设立一个目标帧率，为每帧划定一个时间预算。理想情况下，一个以 30 fps 运行的应用每帧应占有约 33.33 毫秒（1000 毫秒 / 30 帧）。同样地，60 fps 每帧约为 16.66 毫秒。</p><p>设备可以在短时间内超过预算（如过场动画或加载过程中），但绝不能长时间如此。</p><p>** 设备温度优化 **</p><p>对于移动设备而言，长时间占用最大时间预算可能会导致设备过热，操作系统可能会启动 CPU 与 GPU 降频保护。我们建议每帧仅占用约 65% 的时间预算，保留一定的散热时间。常见的帧预算为：30 fps 为每帧 22 毫秒，60 fps 为每帧 11 毫秒。</p><p>大多数移动设备不像桌面设备那样有主动散热功能，因此环境温度可以直接影响性能。</p><p>如果设备发热严重，Profiler 可能会察觉并汇报这块性能低下的部分，即使其只是暂时性问题。为了应对分析时设备过热，分析应分成小段进行。这样便能允许设备散热、模拟出真实的运行条件。我们的建议是，在进行性能分析前后，预留 10-15 分钟用于设备散热。</p><p>** 分清 GPU 与 CPU 依赖程度 **</p><p>Profiler 可在 CPU 耗时或 GPU 耗时超出帧预算发出警告，它将弹出下方以 Gfx 为前缀的标记：</p><p>-<br><strong>Gfx.WaitForCommands</strong> 标记表示渲染线程正在等待主线程完成，后者可能出现了性能瓶颈。</p><p>-<br>而 **Gfx.WaitForPresent ** 表示主线程正在等待 GPU 递交渲染帧。</p><h1 id="内存分析"><a href="#内存分析" class="headerlink" title="** 内存分析 **"></a>** 内存分析 **</h1><p>Unity 会采取自动化内存管理来处理由用户生成的代码与脚本。值类型本地变量等小型数据会被分配到内存堆栈中，大型数据和持久性存储数据则会被分配到托管内存中。</p><p>垃圾数据收集器会定期识别并删除未被使用的托管内存，这个自动流程在检查堆的对象时可能导致游戏卡顿或运行放缓。</p><p>这里，优化内存便是指关注托管内存的分配与删除时机，将内存垃圾回收的影响降到最低。详情请在 Understanding the managed heap 中了解。</p><p>Understanding the managed heap：</p><p><a href="https://docs.unity.cn/cn/current/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html">https://docs.unity.cn/cn/current/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html</a><br><img src="//i0.hdslb.com/bfs/article/3b02870fd5e9d8da6a1fb8ff1621b3485496d324.png@942w_530h_progressive.webp">Memory Profiler 中的帧数据记录、检视与比较<br><strong>Memory Profiler</strong></p><p>Memory Profiler 属于一个独立的分析模块，可以截取托管数据堆内存的状态，帮助你识别出数据碎片化和内存泄漏等问题。</p><p>在 Tree Map 视图中点击一个变量便可跟踪其在内存原生对象上的状态。你可在此处找出由纹理过大或资源重复加载而导致的常见内存消耗问题。</p><p>通过以下链接了解如何使用 Unity 的 Memory Profiler 优化内存占用。</p><p>Memory Profiler：</p><p><a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@0.2/manual/index.html">https://docs.unity3d.com/Packages/com.unity.memoryprofiler@0.2/manual/index.html</a></p><p>**<br>**</p><p>** 降低内存垃圾回收（GC）对性能的影响 **</p><p>Unity 使用的是 Boehm-Demers-Weiser 垃圾回收器 ，它会中止主线程代码运行，在垃圾回收工作完成后再让其恢复运行。</p><p>请注意，部分多余的托管内存分配会造成 GC 耗能高峰：</p><p>-<br><strong>Strings（字符串）</strong>：在 C# 中，字符串属于引用类型，而非值类型。我们需要减少不必要的字符串创建或更改操作，尽量避免解析 JSON 和 XML 等由字符串组成的数据文件，将数据存储于 ScriptableObjects，或以 MessagePack 或 Protobuf 等格式保存。如果你需要在运行时构建字符串，可使用 StringBuilder 类。</p><p>-<br>**Unity 函数调用 **：部分函数会涉及托管内存分配。我们需要缓存数组引用，避免在循环进行中进行数组的内存分配，且尽量使用那些不会产生垃圾回收的函数。比如使用 GameObject.CompareTag，而不是使用 GameObject.tag 手动比对字符串（因为返回一个新字符串会产生垃圾数据）。</p><p>-<br><strong>Boxing（打包）</strong>：避免在引用类型变量处传入值类型变量，因为这样做会导致系统创建一个临时对象，在背地里将值类型转换为对象类型（如 int i = 123; object o = i ），从而产生垃圾回收的需求。尽量使用正确的类型覆写来传入想要的值类型。泛型也可用于类型覆写。</p><p>-<br><strong>Coroutines（协同程序）</strong>：虽然 yield 不会产生垃圾回收，但新建 WaitForSeconds 对象会。我们可以缓存并复用 WaitForSeconds 对象，不必在 yield 中再度创建。</p><p>-<br><strong>LINQ 与 Regular Expressions（正则表达式）</strong>：这两种方法都会在后台的数据打包期间产生垃圾回收。如果需要追求性能，请尽量避免使用 LINQ 和正则表达式，转而使用 for 循环和列表来创建数组。</p><p>Boehm-Demers-Weiser 垃圾回收器：</p><p><a href="https://www.hboehm.info/GC/">https://www.hboehm.info/GC/</a></p><p>** 定时处理垃圾回收 **</p><p>如果你确定垃圾回收带来的卡顿不会影响游戏特定阶段的体验，你可以使用 System.GC.Collect 来启动垃圾数据收集。</p><p>请在 Understanding Automatic Memory Management（自动化内存管理）中了解怎样妥善地使用这项功能。</p><p>Understanding Automatic Memory Management：</p><p><a href="https://docs.unity.cn/cn/current/Manual/UnderstandingAutomaticMemoryManagement.html">https://docs.unity.cn/cn/current/Manual/UnderstandingAutomaticMemoryManagement.html</a></p><p>** 使用增量式垃圾回收（Incremental GC）分散垃圾回收 **</p><p>增量式垃圾回收不会在程序运行期间长时间地中断运行，而会将总负荷分散到多帧，形成零碎的收集流程。如果垃圾数据收集对性能产生了较大的影响，可以尝试启用这个选项来降低 GC 的处理高峰。你可以使用 Profile analyzer 来检验此功能的实际作用。<br><img src="//i0.hdslb.com/bfs/article/8e3479d50eacf29b3c21d54e60d2040363851bba.png@942w_450h_progressive.webp">使用增量垃圾回收来降低 GC 处理高峰</p><h1 id="编程和代码架构"><a href="#编程和代码架构" class="headerlink" title="** 编程和代码架构 **"></a>** 编程和代码架构 **</h1><p>Unity 的 PlayerLoop 包含许多可与引擎核心互动的函数。该结构包含一些负责初始化和每帧更新的系统，所有脚本都将依靠 PlayerLoop 来生成游戏体验。</p><p>在分析时，你会在 PlayerLoop 下看到用户使用的代码（Editor 代码则位于 EditorLoop 下）。<br><img src="//i0.hdslb.com/bfs/article/db793b8131bdd64b4fc70968342484b46d887f8a.png@942w_222h_progressive.webp">Profiler 将显示在整个引擎运行过程中的自定义脚本、设置和图形<img src="//i0.hdslb.com/bfs/article/271d9b75a4e617ed92bb8f606dc4d2b7e04c8a70.png@942w_1961h_progressive.webp"><br>通过以下链接了解 PlayerLoop 和 脚本生命周期 。</p><p>PlayerLoop：</p><p><a href="https://docs.unity.cn/ScriptReference/LowLevel.PlayerLoop.html">https://docs.unity.cn/ScriptReference/LowLevel.PlayerLoop.html</a></p><p>脚本生命周期：</p><p><a href="https://docs.unity.cn/cn/2020.3/Manual/ExecutionOrder.html">https://docs.unity.cn/cn/2020.3/Manual/ExecutionOrder.html</a></p><p>你可以使用以下技巧和窍门来优化脚本。</p><p>** 深入理解 Unity PlayerLoop**</p><p>我们需要掌握 Unity 帧循环的执行顺序 。每个 Unity 脚本都会按照预定的顺序运行事件函数，这要求我们了解 <strong>Awake、Start、Update</strong> 以及其他运行周期相关函数之间的区别。</p><p>请在 Script Lifecycle Flowchart（脚本生命周期流程图）中了解函数的执行顺序。</p><p>Script Lifecycle Flowchart：</p><p><a href="https://docs.unity.cn/cn/2020.3/Manual/ExecutionOrder.html">https://docs.unity.cn/cn/2020.3/Manual/ExecutionOrder.html</a></p><p>** 降低每帧的代码量 **</p><p>有许多代码并非要在每帧上运行，这些不必要的逻辑完全可以在 <strong>Update、LateUpdate 和 FixedUpdate</strong> 中删去。这些事件函数可以保存那些必须每帧更新的代码，任何无须每帧更新的逻辑都不必放入其中，只有在相关事物发生变化时，这些逻辑才需被执行。</p><p>如果必须要使用 <strong>Update</strong>，可以考虑让代码每隔 n 帧运行一次。这种划分运行时间的方法也是一种将繁重工作负荷化整为零的常见技术。在下方例子中，**ExampleExpensiveFunction ** 将每隔三帧运行一次。</p><pre><code>private int interval =3;voidUpdate(){if(Time.frameCount % interval ==0){ExampleExpensiveFunction();}}</code></pre><p>** 避免在 Start/Awake 中加入繁重的逻辑 **</p><p>当首个场景加载时，每个对象都会调用如下函数：</p><p>-<br>Awake</p><p>-<br>OnEnable</p><p>-<br>Start</p><p>在应用完成第一帧的渲染前，我们须避免在这些函数中运行繁重的逻辑。否则，应用的加载时间会出乎意料地长。</p><p>请在 Order of execution for event functions（事件函数的执行顺序）中详细了解首个场景的加载。</p><p>Order of execution for event functions：</p><p><a href="https://docs.unity.cn/cn/2020.3/Manual/ExecutionOrder.html">https://docs.unity.cn/cn/2020.3/Manual/ExecutionOrder.html</a></p><p>** 避免加入空事件 **</p><p>即使是空的 MonoBehaviours 也会占用资源，因此我们应该删除空的 Update 及 LateUpdate 方法。</p><p>如果你想用这些方法进行测试，请使用预处理指令（preprocessor directives）：</p><pre><code>#ifUNITY_EDITORvoidUpdate(){}#endif</code></pre><p>如此一来，在编辑器中的 Update 测试便不会对构建版本造成不良的性能影响。</p><p>**<br>**</p><p>** 删去 Debug Log 语句 **</p><p>Log 声明（尤其是在 <strong>Update、LateUpdate</strong> 及 <strong>FixedUpdate</strong> 中）会拖慢性能，因此我们需要在构建之前禁用 ** Log ** 语句。</p><p>你可以用预处理指令编写一条 Conditional 属性来轻松禁用 Debug Log。比如下方这种的自定义类：</p><p>Conditional 属性：</p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=net-5.0">https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=net-5.0</a></p><pre><code>publicstaticclassLogging{[System.Diagnostics.Conditional(&quot;ENABLE_LOG&quot;)]staticpublicvoidLog(object message){        UnityEngine.Debug.Log(message);}}</code></pre><p><img src="//i0.hdslb.com/bfs/article/49e6b1c9ba3a14b6fa8c9de1e4420601955fbd09.png@942w_309h_progressive.webp">添加自定义预处理指令可以实现脚本的切分<br>用自定义类生成 Log 信息时，你只需在 **Player Settings 中禁用 ENABLE_LOG  预处理指令 **，所有的 Log 语句便会一下子消失。</p><p>** 使用哈希值、避免字符串 **</p><p>Unity 底层代码不会使用字符串来访问 Animator、Material 和 Shader 属性。出于提高效率的考虑，所有属性名称都会被哈希转换成属性 ID，用作实际的属性名称。</p><p>在 Animator、Material 或 Shader 上使用 Set 或 Get 方法时，我们便可以利用整数值而非字符串。后者还需经过一次哈希处理，并没有整数值那么直接。</p><p>使用 Animator.StringToHash 来转换 Animator 属性名称，用 Shader.PropertyToID 来转换 Material 和 Shader 属性名称。</p><p>Animator.StringToHash：<a href="https://docs.unity.cn/ScriptReference/Animator.StringToHash.html">https://docs.unity.cn/ScriptReference/Animator.StringToHash.html</a><br>Shader.PropertyToID：<a href="https://docs.unity.cn/ScriptReference/Shader.PropertyToID.html">https://docs.unity.cn/ScriptReference/Shader.PropertyToID.html</a></p><p>** 选择正确的数据结构 **</p><p>由于数据结构每帧可能会迭代上千次，因此其结构对性能有着较大的影响。如果你不清楚数据集合该用 List、Array 还是 Dictionary 表示，可以参考 C# 的 MSDN 数据结构指南来选择正确的结构。</p><p>MSDN 数据结构指南：</p><p><a href="https://docs.microsoft.com/en-us/dotnet/standard/collections/?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/dotnet/standard/collections/?redirectedfrom=MSDN</a></p><p>** 避免在运行时添加组件 **</p><p>在运行时调用 AddComponent 会占用一定的运行成本，Unity 必须检查组件是否有重复或依赖项。</p><p>当组件已经配置完成，Instantiating a Prefab（实例化预制件）一般来说性能更强。</p><p>Instantiating a Prefab：<a href="https://docs.unity.cn/cn/current/Manual/Prefabs.html">https://docs.unity.cn/cn/current/Manual/Prefabs.html</a></p><p>** 缓存 GameObjects 和组件 **</p><p>调用 <strong>GameObject.Find、GameObject.GetComponent 和 Camera.main</strong>（2020.2 以下的版本）会产生较大的运行负担，因此这些方法不适合在 Update 中调用，而应在 Start 中调用并缓存。</p><p>下方例子展示了一种低效率的 <strong>GetComponent</strong> 多次调用：</p><pre><code>voidUpdate(){    Renderer myRenderer = GetComponent&lt;Renderer&gt;();ExampleFunction(myRenderer);}</code></pre><p>其实 GetComponent 的结果会被缓存，因此只需调用一次即可。缓存的结果完全可在 Update 中重复使用，不必再度调用 GetComponent。</p><pre><code>private Renderer myRenderer;voidStart(){    myRenderer = GetComponent&lt;Renderer&gt;();}voidUpdate(){ExampleFunction(myRenderer);}</code></pre><p>** 对象池（Object Pool）**</p><p>Instantiate（实例化）和 Destroy（销毁）方法会产生需要垃圾回收数据、引发垃圾回收（GC）的处理高峰，且其运行较为缓慢。与其经常性地实例化和销毁 GameObjects（如射出的子弹），不如使用对象池将对象预先储存，再重复地使用和回收。</p><p>对象池：</p><p><a href="https://en.wikipedia.org/wiki/Object_pool_pattern">https://en.wikipedia.org/wiki/Object_pool_pattern</a><br>在这个例子中，ObjectPool 创建了 20 个 PlayerLaser 实例供重复使用<br>在游戏特定时间点（如显示菜单画面时）创建可复用的实例，来降低 CPU 处理高峰的影响，再用一个集合来形成“对象池”。在游戏期间，实例可在需要时启用 / 禁用，用完后可返回到池中，不必再进行销毁。<br>PlayerLaser 对象池目前尚未激活，正等待玩家射击<br>这一来你就可以减少托管内存分配的次数、防止产生垃圾回收的问题。</p><p>** 使用 ScriptableObjects（可编程对象）**</p><p>固定不变的值或配置信息可以存储在 <strong>ScriptableObject</strong> 中，不一定得储存于 MonoBehaviour。ScriptableObject 可由整个项目访问，一次设置便可应用于项目全局，但它并不能直接关联到 GameObject 上。</p><p>我们可在 ScriptableObject 中用字段来存储值或设定，然后在 MonoBehaviours 中引用该对象。<br>用作 “Inventory（物品栏）” 的 ScriptableObject 可保存多个游戏对象的设定<br>下方的 ScriptableObject 字段可有效防止多次 MonoBehaviour 实例化产生的数据重复。</p><p>请参考 ScriptableObjects 文档了解如何使用。</p><p>ScriptableObjects：<a href="https://docs.unity.cn/cn/current/Manual/class-ScriptableObject.html">https://docs.unity.cn/cn/current/Manual/class-ScriptableObject.html</a></p><p>后续我们将再发表两篇文章：一篇讨论 UI Physics，另一篇讨论音频和资源、项目配置和图形。敬请期待。</p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Software" scheme="https://tamsiree.com/categories/Software/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/categories/Software/Unity/"/>
    
    
    <category term="Software" scheme="https://tamsiree.com/tags/Software/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 音频压缩优化</title>
    <link href="https://tamsiree.com/Software/Unity/Unity%E9%9F%B3%E9%A2%91%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96/"/>
    <id>https://tamsiree.com/Software/Unity/Unity%E9%9F%B3%E9%A2%91%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96/</id>
    <published>2022-01-04T12:18:11.000Z</published>
    <updated>2025-11-05T13:53:39.390Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>没想到 Unity 的音频会成为内存杀手，在实际的商业项目中，音频的优化必不可少。</p><ol><li><p>Unity 支持许多不同的音频格式，但最终它将它们全部转换为首选格式。音频压缩格式有 PCM、ADPCM、Vorbis，不是所有平台都支持这些所有的压缩格式，有些平台，例如 WebGL 只支持 AAC 格式。</p></li><li><p>所有音频导入时，默认两项设置，LoadType 是 “Decompress On Load”，压缩格式是“Vorbis”，例如下图原始文件大小计算为 35.9 MB，导入的大小计算为 10.7 MB。这意味着这个音频剪辑将使您的游戏（存档）大小增加 10 兆字节，但播放它需要近 36 兆字节的 RAM。</p></li></ol><p><em><a href="https://i1.wp.com/blog.theknightsofunity.com/wp-content/uploads/2015/11/a0811c8c-e135-4126-b0c2-e0c170a1ae64.png"><img src="https://i1.wp.com/blog.theknightsofunity.com/wp-content/uploads/2015/11/a0811c8c-e135-4126-b0c2-e0c170a1ae64.png?resize=369,195" alt="These are default import settings."></a></em></p><p>3.Load Type 的各个选项</p><ul><li><p><em>Compressed In Memory</em> – 音频剪辑将存储在 RAM 中，播放时将解压缩，播放时不需要额外的存储。</p></li><li><p><em>Streaming</em> –音频永久存在设备上(硬盘或闪存上) ，播放流媒体方式. 不需要 RAM 进行存储或播放。</p></li><li><p><em>Decompress On Load</em> – 未压缩的音频将存储在 RAM 中。这个选项需要的内存最多，但是播放它不会像其他选项那样需要太多的 CPU 电源。</p><pre><code>   怎么选？长音频播放消耗大量内存，如果播放时不想在内存中进行解压，有两个选择：   （1）Load Type 选“Streaming”， Compression Format 选”Vorbis&quot;，使用最少的内存，但需要更多的 CPU 电量和硬盘 I/O 操作；   （2）Load Type 选 “Compressed In Memory”， Compression Format 选”Vorbis&quot;，磁盘 I/O 操作被替换成内存的消耗，请注意，要调整“Quaility” 滑块以减小压缩剪辑的大小，以交换音质，一般推荐 70% 左右。       一般是看到底音乐占据多少内存以及你的目标机型是什么样子的，如果音乐占据的内存本身比较高，你的目标机型的内存又比较小，那么就选择第二种，这种方案会卡一点，否则选择第一种就更好</code></pre></li></ul><ol start="4"><li><p>声音特效</p><p>  （1）对于经常播放的和短的音频剪辑，使用 “*Decompress On Load” 和“PCM 或 ADPCM” 压缩格式 *。当选择 PCM 时，不需要解压缩，如果音频剪辑很短，它将很快加载。你也可以使用 ADPCM。它需要解压，但解压比 Vorbis 快得多。</p><p>   （2）对于经常播放，中等大小的音频剪辑使用”<em>Compressed In Memory“</em> 和”ADPCM“压缩格式，比原始 PCM 小 3.5 倍，解压算法的 CPU 消耗量不会像 vorbis 消耗那么多 CPU。</p><p>   （3）对于很少播放并且长度比较短的声音剪辑，使用”<em>Compressed In Memory”,</em> ADPCM 这种压缩格式, 原因同（2）。</p><p>  （4）对于很少播放中等大小的音频，使用”*Compressed In Memory“ * 和 Vorbis 压缩格式。这个音频可能太长，无法使用 adpcm 存储，播放太少，因此解压缩所需的额外 CPU 电量不会太多。</p></li></ol><h2 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h2><blockquote><p> 一个 2MB 的音频文件，在内存中却变成了 20+MB</p></blockquote><p><img src="https://pic4.zhimg.com/v2-857eba873e78e060356d67eacadb9d5f_b.png"><img src="https://pic4.zhimg.com/80/v2-857eba873e78e060356d67eacadb9d5f_720w.png"><img src="https://pic3.zhimg.com/v2-042720489af2f3b2f8a3968b9bbf7e3e_b.jpg"><img src="https://pic3.zhimg.com/80/v2-042720489af2f3b2f8a3968b9bbf7e3e_720w.jpg"></p><h2 id="研究："><a href="#研究：" class="headerlink" title="研究："></a>研究：</h2><blockquote><p> 音频加载有多种模式： 造成这种现象是因为选择了 Decompress On Load 这种模式。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic4.zhimg.com/v2-1e9cd8363d2194c4a1048f20c013490b_b.jpg"><img src="https://pic4.zhimg.com/80/v2-1e9cd8363d2194c4a1048f20c013490b_720w.jpg"></h2><p>为什么会造成这种现象呢？这就要学习一下 unity 的音频的导入选项了。</p><h2 id="一、LoadType"><a href="#一、LoadType" class="headerlink" title="一、LoadType"></a>一、LoadType</h2><ol><li>Streaming: 流</li></ol><blockquote><p> 动态解码声音。此方法使用 == 最小量的内存 == 来缓冲从磁盘逐渐读取并在运行中解码的压缩数据。请注意，解压缩发生在分析器窗口的音频面板的 “Streaming CPU” 部分中可监视其 CPU 使用率的单独流式线程上。注意：即使没有加载任何音频数据，流式片段也会有大约 200KB 的过载。</p></blockquote><ol start="2"><li>Decompress On Load: 加载时解压缩（适用于小音效）</li></ol><blockquote><p> 音频文件一经加载就会被解压缩。对较小的压缩声音使用此选项可避免即时解压缩的性能开销。== 请注意，在加载时解压缩 Vorbis 编码的声音比使用它压缩大约多十倍的内存（对于 ADPCM 编码大约是 3.5 倍）==，所以不要将此选项用于大文件。</p></blockquote><ol start="3"><li>Compressed In Memory: 压缩在内存中</li></ol><blockquote><p> 保持声音在存储器中压缩并在播放时解压缩。这个选项有一个小的性能开销（尤其是对于 Ogg / Vorbis 压缩文件），所以 == 只能用于较大的文件 ==，因为在加载时解压缩会使用大量的内存。解压缩在混音器线程上发生，并可在 Profiler 窗口的音频面板中的 “DSP CPU” 部分进行监视。</p></blockquote><ol start="4"><li>Preload Audio Data: 预加载音频数据</li></ol><blockquote><p> 如果启用，音频剪辑将在场景加载时预先加载。默认情况下，这反映了在场景开始播放时所有音频剪辑已完成加载的标准 Unity 行为。如果未设置该标志，音频数据将要么被上加载的第一个的 AudioSource.Play（）/ 的 AudioSource .PlayOneShot（），或者它可以通过加载的 AudioSource.LoadAudioData（），并通过再次卸载的 AudioSource .UnloadAudioData（）。</p></blockquote><h3 id="总结：小文件音频建议使用预加载，大文件音频建议使用将-Load-Type-修改为-Streaming-这样在播放完毕后会自动释放对应文件。"><a href="#总结：小文件音频建议使用预加载，大文件音频建议使用将-Load-Type-修改为-Streaming-这样在播放完毕后会自动释放对应文件。" class="headerlink" title="总结：小文件音频建议使用预加载，大文件音频建议使用将 Load Type 修改为 Streaming , 这样在播放完毕后会自动释放对应文件。"></a>总结：小文件音频建议使用预加载，大文件音频建议使用将 Load Type 修改为 Streaming , 这样在播放完毕后会自动释放对应文件。</h3><h2 id="二、Compression-Format-压缩格式"><a href="#二、Compression-Format-压缩格式" class="headerlink" title="二、Compression Format: 压缩格式"></a>二、Compression Format: 压缩格式</h2><ul><li>PCM ：提供高品质但牺牲文件大小最适合使用在很短的音效上。</li><li>ADPCM： 这种格式适用于大量音效上如脚步爆破和武器，它比 PCM 小 3.5 倍但 CPU 使用率远低于 Vorbis/MP3</li><li>Vorbis/MP3： 比 PCM 小但是品质比 PCM 低，比 ADPCM 消耗更多 CPU。但大多数情况下我们还是应该使用这种格式，这个选择还多了个 Quality 可以调节质量改变文件大小 （Quality 测试 1 和 100 对内存影响并不大）</li></ul><h3 id="三、音道"><a href="#三、音道" class="headerlink" title="三、音道"></a>三、音道</h3><blockquote><p>强制音效用单声道<br>只有少数的手机装置真的有立体声喇叭，而将音效强制设定为单声道能让内存的消耗减半。就算游戏会输出部份的立体声，有些单声道像是 UI 音效还是可以开启这个选项。</p></blockquote><p>详细策略见下面这篇文章，具体的工具实现已上传<a href="https://link.zhihu.com/?target=https://github.com/Aver58/Tools/blob/master/UnityProject/Assets/Editor/Import/ImporterAudio.cs">github</a><br><img src="https://pic3.zhimg.com/v2-70cdde97990bbf84a709874ebfc1e58e_b.jpg"><img src="https://pic3.zhimg.com/80/v2-70cdde97990bbf84a709874ebfc1e58e_720w.jpg"><img src="https://pic1.zhimg.com/v2-b33b80f20fd8e50d6beaae23f486a720_b.jpg"><img src="https://pic1.zhimg.com/80/v2-b33b80f20fd8e50d6beaae23f486a720_720w.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/bearhb/p/11210136.html">Unity 性能优化 - 音频设置</a><br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chenfujun818/article/details/81710895">Unity 音频优化总结</a></p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Software" scheme="https://tamsiree.com/categories/Software/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/categories/Software/Unity/"/>
    
    
    <category term="Software" scheme="https://tamsiree.com/tags/Software/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 内存优化</title>
    <link href="https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity3D%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>https://tamsiree.com/%E9%9A%8F%E6%89%8B%E8%AE%B0/Unity3D%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2021-12-28T02:47:20.000Z</published>
    <updated>2025-11-05T13:53:39.378Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>转载自 ：<a href="http://blog.csdn.net/andyhebear/article/details/50977295">Unity3D 内存释放</a></p><p>最近网友通过网站搜索 <a href="http://lib.csdn.net/base/unity3d" title="Unity3D 知识库">Unity3D</a> 在手机及其他平台下占用内存太大. 这里写下关于 <a href="http://lib.csdn.net/base/unity3d" title="Unity3D 知识库">unity3d</a> 对于内存的管理与优化.</p><p>Unity3D 里有两种动态加载机制：一个是 Resources.Load，另外一个通过 AssetBundle, 其实两者区别不大。Resources.Load 就是从一个缺省打进程序包里的 AssetBundle 里加载资源，而一般 AssetBundle 文件需要你自己创建，运行时 动态加载，可以指定路径和来源的。</p><p>其实场景里所有静态的对象也有这么一个加载过程，只是 Unity3D 后台替你自动完成了。</p><p>详细说一下细节概念：<br>AssetBundle 运行时加载:<br>来自文件就用 CreateFromFile(注意这种方法只能用于 standalone 程序）这是最快的加载方法<br>也可以来自 Memory, 用 CreateFromMemory(byte[]), 这个 byte[]可以来自文件读取的缓冲，www 的下载或者其他可能的方式。<br>其实 WWW 的 assetBundle 就是内部数据读取完后自动创建了一个 assetBundle 而已<br>Create 完以后，等于把硬盘或者网络的一个文件读到内存一个区域，这时候只是个 AssetBundle 内存镜像数据块，还没有 Assets 的概念。<br>Assets 加载:<br>用 AssetBundle.Load(同 Resources.Load)这才会从 AssetBundle 的内存镜像里读取并创建一个 Asset 对象，创建 Asset 对象同时也会分配相应内存用于存放(反序列化)<br>异步读取用 AssetBundle.LoadAsync<br>也可以一次读取多个用 AssetBundle.LoadAll<br>AssetBundle 的释放：<br>AssetBundle.Unload(flase)是释放 AssetBundle 文件的内存镜像，不包含 Load 创建的 Asset 内存对象。<br>AssetBundle.Unload(true)是释放那个 AssetBundle 文件内存镜像和并销毁所有用 Load 创建的 Asset 内存对象。</p><p>一个 Prefab 从 assetBundle 里 Load 出来 里面可能包括：Gameobject transform mesh texture material shader script 和各种其他 Assets。<br>你 Instaniate 一个 Prefab，是一个对 Assets 进行 Clone(复制)+ 引用结合的过程，GameObject transform 是 Clone 是新生成的。其他 mesh / texture / material / shader 等，这其中些是纯引用的关系的，包括：Texture 和 TerrainData，还有引用和复制同时存在的，包括：Mesh/material /PhysicMaterial。引用的 Asset 对象不会被复制，只是一个简单的指针指向已经 Load 的 Asset 对象。这种含糊的引用加克隆的混合， 大概是搞糊涂大多数人的主要原因。<br>专门要提一下的是一个特殊的东西：Script Asset，看起来很奇怪，Unity 里每个 Script 都是一个封闭的 Class 定义而已, 并没有写调用代码，光 Class 的定义脚本是不会工作的。其 实 Unity 引擎就是那个调用代码，Clone 一个 script asset 等于 new 一个 class 实例，实例才会完成工作。把他挂到 Unity 主线程的调用链里去，Class 实例里的 OnUpdate OnStart 等才会被执行。多个物体挂同一个脚本，其实就是在多个物体上挂了那个脚本类的多个实例而已，这样就好理解了。在 new class 这个过程中，数据区是复制的，代码区是共享的，算是一种特殊的复制 + 引用关系。<br>你可以再 Instaniate 一个同样的 Prefab, 还是这套 mesh/texture/material/shader…，这时候会有新的 GameObject 等，但是不会创建新的引用对象比如 Texture.<br>所以你 Load 出来的 Assets 其实就是个数据源，用于生成新对象或者被引用，生成的过程可能是复制（clone)也可能是引用（指针）<br>当你 Destroy 一个实例时，只是释放那些 Clone 对象，并不会释放引用对象和 Clone 的数据源对象，Destroy 并不知道是否还有别的 object 在引用那些对象。<br>等到没有任何 游戏场景物体在用这些 Assets 以后，这些 assets 就成了没有引用的游离数据块了，是 UnusedAssets 了，这时候就可以通过 Resources.UnloadUnusedAssets 来释放, Destroy 不能完成这个任 务，AssetBundle.Unload(false)也不行，AssetBundle.Unload(true)可以但不安全，除非你很清楚没有任何 对象在用这些 Assets 了。<br>配个图加深理解：</p><p><a href="http://unity3d.9ria.com/?attachment_id=2926"><img src="http://unity3d.9ria.com/wp-content/uploads/2013/03/15162026-0158e692a60c4c849d482be37465ff58-500x369.jpg" title="15162026-0158e692a60c4c849d482be37465ff58"></a></p><p>Unity3D 占用内存太大怎么解决呢?</p><p>虽然都叫 Asset，但复制的和引用的是不一样的，这点被 Unity 的暗黑技术细节掩盖了，需要自己去理解。</p><p>关于内存管理<br>按照传统的编程思维，最好的方法是：自己维护所有对象，用一个 Queue 来保存所有 object, 不用时该 Destory 的，该 Unload 的自己处理。<br>但这样在 C# .net 框架底下有点没必要，而且很麻烦。<br>稳妥起见你可以这样管理</p><p>创建时：<br>先建立一个 AssetBundle, 无论是从 www 还是文件还是 memory<br>用 AssetBundle.load 加载需要的 asset<br>加载完后立即 AssetBundle.Unload(false), 释放 AssetBundle 文件本身的内存镜像，但不销毁加载的 Asset 对象。（这样你不用保存 AssetBundle 的引用并且可以立即释放一部分内存）<br>释放时：<br>如果有 Instantiate 的对象，用 Destroy 进行销毁<br>在合适的地方调用 Resources.UnloadUnusedAssets, 释放已经没有引用的 Asset.<br>如果需要立即释放内存加上 GC.Collect()，否则内存未必会立即被释放，有时候可能导致内存占用过多而引发异常。<br>这样可以保证内存始终被及时释放，占用量最少。也不需要对每个加载的对象进行引用。</p><p>当然这并不是唯一的方法，只要遵循加载和释放的原理，任何做法都是可以的。</p><p>系统在加载新场景时，所有的内存对象都会被自动销毁，包括你用 AssetBundle.Load 加载的对象和 Instaniate 克隆的。但是不包括 AssetBundle 文件自身的内存镜像，那个必须要用 Unload 来释放，用. net 的术语，这种数据缓存是非托管的。</p><p>总结一下各种加载和初始化的用法:<br>AssetBundle.CreateFrom…..：创建一个 AssetBundle 内存镜像，注意同一个 assetBundle 文件在没有 Unload 之前不能再次被使用<br><a href="WWW.AssetBundle%EF%BC%9A%E5%90%8C%E4%B8%8A%EF%BC%8C%E5%BD%93%E7%84%B6%E8%A6%81%E5%85%88">WWW.AssetBundle：同上，当然要先</a> new 一个再 yield return 然后才能使用<br>AssetBundle.Load(name)： 从 AssetBundle 读取一个指定名称的 Asset 并生成 Asset 内存对象，如果多次 Load 同名对象，除第一次外都只会返回已经生成的 Asset 对象，也就是说多次 Load 一个 Asset 并不会生成多个副本（singleton）。<br>Resources.Load(path&amp;name)：同上, 只是从默认的位置加载。<br>Instantiate（object)：Clone 一个 object 的完整结构，包括其所有 Component 和子物体（详见官方文档）, 浅 Copy，并不复制所有引用类型。有个特别用法，虽然很少这样 用，其实可以用 Instantiate 来完整的拷贝一个引用类型的 Asset, 比如 Texture 等，要拷贝的 Texture 必须类型设置为 Read/Write able。</p><p>总结一下各种释放<br>Destroy: 主要用于销毁克隆对象，也可以用于场景内的静态物体，不会自动释放该对象的所有引用。虽然也可以用于 Asset, 但是概念不一样要小心，如果用于销毁从文 件加载的 Asset 对象会销毁相应的资源文件！但是如果销毁的 Asset 是 Copy 的或者用脚本动态生成的，只会销毁内存对象。<br>AssetBundle.Unload(false): 释放 AssetBundle 文件内存镜像<br>AssetBundle.Unload(true): 释放 AssetBundle 文件内存镜像同时销毁所有已经 Load 的 Assets 内存对象<br>Reources.UnloadAsset(Object): 显式的释放已加载的 Asset 对象，只能卸载磁盘文件加载的 Asset 对象<br>Resources.UnloadUnusedAssets: 用于释放所有没有引用的 Asset 对象<br>GC.Collect()强制垃圾收集器立即释放内存 Unity 的 GC 功能不算好，没把握的时候就强制调用一下</p><p>在 3.5.2 之前好像 Unity 不能显式的释放 Asset</p><p>举两个例子帮助理解<br>例子 1：<br>一个常见的错误：你从某个 AssetBundle 里 Load 了一个 prefab 并克隆之：obj = Instaniate(AssetBundle1.Load(‘MyPrefab”);<br>这个 prefab 比如是个 npc<br>然后你不需要他的时候你用了：Destroy(obj); 你以为就释放干净了<br>其实这时候只是释放了 Clone 对象，通过 Load 加载的所有引用、非引用 Assets 对象全都静静静的躺在内存里。<br>这种情况应该在 Destroy 以后用：AssetBundle1.Unload(true)，彻底释放干净。<br>如果这个 AssetBundle1 是要反复读取的 不方便 Unload，那可以在 Destroy 以后用：Resources.UnloadUnusedAssets()把所有和这个 npc 有关的 Asset 都销毁。<br>当然如果这个 NPC 也是要频繁创建 销毁的 那就应该让那些 Assets 呆在内存里以加速游戏体验。<br>由此可以解释另一个之前有人提过的话题：为什么第一次 Instaniate 一个 Prefab 的时候都会卡一下，因为在你第一次 Instaniate 之前，相应的 Asset 对象还没有被创建，要加载系统内置的 AssetBundle 并创建 Assets, 第一次以后你虽然 Destroy 了，但 Prefab 的 Assets 对象都还在内存里，所以就很快了。</p><p>顺便提一下几种加载方式的区别:<br>其实存在 3 种加载方式：<br>一是静态引用，建一个 public 的变量，在 Inspector 里把 prefab 拉上去，用的时候 instantiate<br>二是 Resource.Load，Load 以后 instantiate<br>三是 AssetBundle.Load,Load 以后 instantiate<br>三种方式有细 节差异，前两种方式，引用对象 texture 是在 instantiate 时加载，而 assetBundle.Load 会把 perfab 的全部 assets 都加载，instantiate 时只是生成 Clone。所以前两种方式，除非你提前加载相关引用对象，否则第一次 instantiate 时会包含加载引用 assets 的操作，导致第一次加载的 lag。</p><p>例子 2：<br>从磁盘读取一个 1.unity3d 文件到内存并建立一个 AssetBundle1 对象<br>AssetBundle AssetBundle1 = AssetBundle.CreateFromFile(“1.unity3d”);<br>从 AssetBundle1 里读取并创建一个 Texture Asset, 把 obj1 的主贴图指向它<br>obj1.renderer.material.mainTexture = AssetBundle1.Load(“wall”) as Texture;<br>把 obj2 的主贴图也指向同一个 Texture Asset<br>obj2.renderer.material.mainTexture =obj1.renderer.material.mainTexture;<br>Texture 是引用对象，永远不会有自动复制的情况出现(除非你真需要，用代码自己实现 copy)，只会是创建和添加引用<br>如果继续：<br>AssetBundle1.Unload(true) 那 obj1 和 obj2 都变成黑的了，因为指向的 Texture Asset 没了<br>如果：<br>AssetBundle1.Unload(false) 那 obj1 和 obj2 不变，只是 AssetBundle1 的内存镜像释放了<br>继续：<br>Destroy(obj1),//obj1 被释放，但并不会释放刚才 Load 的 Texture<br>如果这时候：<br>Resources.UnloadUnusedAssets();<br>不会有任何内存释放 因为 Texture asset 还被 obj2 用着<br>如果<br>Destroy(obj2)<br>obj2 被释放，但也不会释放刚才 Load 的 Texture<br>继续<br>Resources.UnloadUnusedAssets();<br>这时候刚才 load 的 Texture Asset 释放了，因为没有任何引用了<br>最后 CG.Collect();<br>强制立即释放内存<br>由此可以引申出论坛里另一个被提了几次的问题，如何加载一堆大图片轮流显示又不爆掉<br>不考虑 AssetBundle，直接用 www 读图片文件的话等于是直接创建了一个 Texture Asset<br>假设文件保存在一个 List 里<br>TLlist<string> fileList;<br>int n=0;<br>IEnumerator OnClick()<br>{<br>WWW image = newwww(fileList[n++])；<br>yield return image;<br>obj.mainTexture = image.texture;</p><p>n = (n&gt;=fileList.Length-1)?0:n;<br>Resources.UnloadUnusedAssets();<br>}<br>这样可以保证内存里始终只有一个巨型 Texture Asset 资源，也不用代码追踪上一个加载的 Texture Asset, 但是速度比较慢<br>或者：<br>IEnumerator OnClick()<br>{<br>WWW image = newwww(fileList[n++])；<br>yield return image;<br>Texture tex =obj.mainTexture;<br>obj.mainTexture = image.texture;</p><p>n = (n&gt;=fileList.Length-1)?0:n;<br>Resources.UnloadAsset(tex);<br>}<br>这样卸载比较快</p><p>Hog 的评论引用：</p><p>感觉这是 Unity 内存管理暗黑和混乱的地方，特别是牵扯到 Texture<br>我最近也一直在 <a href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库">测试</a> 这些用 AssetBundle 加载的 asset 一样可以用 Resources.UnloadUnusedAssets 卸载，** 但必须先 AssetBundle.Unload, 才会被识别为无用的 asset。** 比较保险的做法是<br>创建时：<br>先建立一个 AssetBundle, 无论是从 www 还是文件还是 memory<br>用 AssetBundle.load 加载需要的 asset<br>用完后立即 AssetBundle.Unload(false), 关闭 AssetBundle 但不摧毁创建的对象和引用<br>销毁时：<br>对 Instantiate 的对象进行 Destroy<br>在合适的地方调用 Resources.UnloadUnusedAssets, 释放已经没有引用的 Asset.<br>如果需要立即释放加上 GC.Collect()<br>这样可以保证内存始终被及时释放<br>只要你 Unload 过的 AssetBundle, 那些创建的对象和引用都会在 LoadLevel 时被自动释放。</p><p>** 全面理解 Unity 加载和内存管理机制之二：进一步深入和细节<br>Unity 几种动态加载 Prefab 方式的差异:**<br>其实存在 3 种加载 prefab 的方式：<br>一是静态引用，建一个 public 的变量，在 Inspector 里把 prefab 拉上去，用的时候 instantiate<br>二是 Resource.Load，Load 以后 instantiate<br>三是 AssetBundle.Load,Load 以后 instantiate<br>三种方式有细节差异，前两种方式，引用对象 texture 是在 instantiate 时加载，而 assetBundle.Load 会把 perfab 的全部 assets 都加载，instantiate 时只是生成 Clone。所以前两种方式，除非你提前加载相关引用对象，否则第一次 instantiate 时会 包含加载引用类 assets 的操作，导致第一次加载的 lag。** 官方论坛有人说 Resources.Load 和静态引用是会把所有资源都预先加载的，反复测试的结果，静态引用和 Resources.Load 也是 OnDemand 的，用到时才会加载。**</p><p>几种 AssetBundle 创建方式的差异:<br>CreateFromFile: 这种方式不会把整个硬盘 AssetBundle 文件都加载到 内存来，而是类似建立一个文件操作句柄和缓冲区，需要时才实时 Load，所以这种加载方式是最节省资源的，基本上 AssetBundle 本身不占什么内 存，只需要 Asset 对象的内存。可惜只能在 PC/Mac Standalone 程序中使用。<br>CreateFromMemory 和 assetBundle: 这两种方式 AssetBundle 文件会整个镜像于内存中，理论上文件多大就需要多大的内存，之后 Load 时还要占用额外内存去生成 Asset 对象。</p><p>** 什么时候才是 UnusedAssets?**<br>看一个例子：<br>Object obj = Resources.Load(“MyPrefab”);<br>GameObject instance = Instantiate(obj) as GameObject;<br>………<br>Destroy(instance);<br>创建随后销毁了一个 Prefab 实例，这时候 MyPrefab 已经没有被实际的物体引用了，但如果这时：<br>Resources.UnloadUnusedAssets();<br>内存并没有被释放，原因：MyPrefab 还被这个变量 obj 所引用<br>这时候：<br>obj  = null;<br>Resources.UnloadUnusedAssets();<br>这样才能真正释放 Assets 对象<br>所以：UnusedAssets 不但要没有被实际物体引用，也要没有被生命周期内的变量所引用，才可以理解为 Unused(引用计数为 0)<br>所以所以：如果你用个全局变量保存你 Load 的 Assets，又没有显式的设为 null，那 在这个变量失效前你无论如何 UnloadUnusedAssets 也释放不了那些 Assets 的。如果你这些 Assets 又不是从磁盘加载的，那除了 UnloadUnusedAssets 或者加载新场景以外没有其他方式可以卸载之。</p><p>** 一个复杂的例子，代码很丑陋实际也不可能这样做，只是为了加深理解 **</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">OnClick</span>()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Resources.UnloadUnusedAssets();<span class="comment">// 清干净以免影响测试效果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> wait = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 www 读取一个 assetBundle, 里面是一个 Unity 基本球体和带一张大贴图的材质，是一个 Prefab</span></span><br><span class="line"></span><br><span class="line">WWW aa = <span class="keyword">new</span> WWW(<span class="string">@&quot;file://SpherePrefab.unity3d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> aa;</span><br><span class="line"></span><br><span class="line">AssetBundle asset = aa.assetBundle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;<span class="comment">// 每步都等待 0.5s 以便于分析结果</span></span><br><span class="line"></span><br><span class="line">Texture tt = asset.Load(<span class="string">&quot;BallTexture&quot;</span>) <span class="keyword">as</span> Texture;<span class="comment">// 加载贴图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">GameObject ba = asset.Load(<span class="string">&quot;SpherePrefab&quot;</span>) <span class="keyword">as</span> GameObject;<span class="comment">// 加载 Prefab</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">GameObject obj1 = Instantiate(ba) <span class="keyword">as</span> GameObject;<span class="comment">// 生成实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">Destroy(obj1);<span class="comment">// 销毁实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">asset.Unload(<span class="literal">false</span>);<span class="comment">// 卸载 Assetbundle</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">Resources.UnloadUnusedAssets();<span class="comment">// 卸载无用资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">ba = <span class="literal">null</span>;<span class="comment">// 将 prefab 引用置为空以后卸无用载资源</span></span><br><span class="line"></span><br><span class="line">Resources.UnloadUnusedAssets();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">tt = <span class="literal">null</span>;<span class="comment">// 将 texture 引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">Resources.UnloadUnusedAssets();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是测试结果的内存 Profile 曲线图</p><p><img src="https://images0.cnblogs.com/blog/90192/201303/15162118-7ab062b3a24f4b43b65bb64788429100.jpg"></p><p>Unity3D 占用内存太大怎么解决呢?</p><p>图片: p12.jpg</p><p>很经典的对称造型，用多少释放多少。</p><p>这是各阶段的内存和其他数据变化</p><p><img src="https://images0.cnblogs.com/blog/90192/201303/15162200-b403e1fc94a841b094c9fc5d0a588a5f.jpg"></p><p>说明:<br>1        初始状态<br>2        载入 AssetBundle 文件后，内存多了文件镜像，用量上升，Total Object 和 Assets 增加 1（AssetBundle 也是 object)<br>3        载入 Texture 后，内存继续上升，因为多了 Texture Asset,Total Objects 和 Assets 增加 1<br>4        载入 Prefab 后，内存无明显变化，因为最占内存的 Texture 已经加载，Materials 上升是因为多了 Prefab 的材质，Total Objects 和 Assets 增加 6，因为 Perfab 包含很多 Components<br>5        实例化 Prefab 以后，显存的 Texture Memory、GameObjectTotal、Objects in Scene 上升，都是因为实例化了一个可视的对象<br>6        销毁实例后，上一步的变化还原，很好理解<br>7        卸载 AssetBundle 文件后，AssetBundle 文件镜像占用的内存被释放，相应的 Assets 和 Total Objects Count 也减 1<br>8        直接 Resources.UnloadUnusedAssets, 没有任何变化，因为所有 Assets 引用并没有清空<br>9        把 Prefab 引用变量设为 null 以后，整个 Prefab 除了 Texture 外都没有任何引用了，所以被 UnloadUnusedAssets 销毁, Assets 和 Total Objects Count 减 6<br>10        再把 Texture 的引用变量设为 null, 之后也被 UnloadUnusedAssets 销毁，内存被释放，assets 和 Total Objects Count 减 1，基本还原到初始状态</p><p>从中也可以看出：<br><strong>Texture 加载以后是到内存，显示的时候才进入显存的 Texture Memory。<br>** 所有的东西基础都是 Object<br>Load 的是 Asset,Instantiate 的是 GameObject 和 Object in Scene<br>Load 的 Asset 要 Unload,new 的或者 Instantiate 的 object 可以 Destroy</strong>**</p><h2 id="Unity-3D-中的内存管理"><a href="#Unity-3D-中的内存管理" class="headerlink" title="Unity 3D 中的内存管理"></a>Unity 3D 中的内存管理</h2><p>Unity3D 在内存占用上一直被人诟病，特别是对于面向移动设备的游戏开发，动辄内存占用飙上一两百兆，导致内存资源耗尽，从而被系统强退造成极 差的体验。类似这种情况并不少见，但是绝大部分都是可以避免的。虽然理论上 Unity 的内存管理系统应当为开发者分忧解难，让大家投身到更有意义的事情中 去，但是对于 Unity 对内存的管理方式，官方文档中并没有太多的说明，基本需要依靠自己摸索。最近在接手的项目中存在严重的内存问题，在参照文档和 Unity Answer 众多猜测和证实之后，稍微总结了下 Unity 中的内存的分配和管理的基本方式，在此共享。</p><p>虽然 Unity 标榜自己的内存使用全都是“Managed Memory”，但是事实上你必须正确地使用内存，以保证回收机制正确运行。如果没有做应当做的事情，那么场景和代码很有可能造成很多非必要内存的占用， 这也是很多 Unity 开发者抱怨内存占用太大的原因。接下来我会介绍 Unity 使用内存的种类，以及相应每个种类的优化和使用的技巧。遵循使用原则，可以 让非必要资源尽快得到释放，从而降低内存占用。</p><h3 id="Unity-中的内存种类"><a href="#Unity-中的内存种类" class="headerlink" title="Unity 中的内存种类"></a>Unity 中的内存种类</h3><p>实际上 Unity 游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。</p><p>程序代码包括了所有的 Unity 引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。</p><p>这部分内存实际上是没有办法去 “管理” 的，它们将在内存中从一开始到最后一直存在。一个空的 Unity 默认场景，什么代码都不放，在 <a href="http://lib.csdn.net/base/ios" title="iOS 知识库">iOS</a> 设备上占 用内存应该在 17MB 左右，而加上一些自己的代码很容易就飙到 20MB 左右。想要减少这部分内存的使用，能做的就是减少使用的库，稍后再说。</p><p>托管堆是被 Mono 使用的一部分内存。Mono 项目一个开源的. net 框架的一种实现，对于 Unity 开发，其实充当了基本类库的角色。</p><p>托管堆用来存放类的实例（比如用 new 生成的列表，实例中的各种声明的变量等）。“托管”的意思是 Mono“应该”自动地改变堆的大小来适应你所需要的内存，</p><p>并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，</p><p>从而导致 Mono 认为这块内存一直有用，而无法回收。</p><p>最后，本机堆是 Unity 引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity 使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。</p><p>基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，</p><p>但是由于 Unity 有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，</p><p>但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），</p><p>也是 Unity 给人留下 “吃内存” 印象的罪魁祸首。</p><hr><h3 id="优化程序代码的内存占用"><a href="#优化程序代码的内存占用" class="headerlink" title="优化程序代码的内存占用"></a>优化程序代码的内存占用</h3><p>这部分的优化相对简单，因为能做的事情并不多：主要就是减少打包时的引用库，改一改 build 设置即可。</p><p>对于一个新项目来说不会有太大问题，但是如果是已经存在的项目，可能改变会导致原来所需要的库的缺失（虽说一般来说这种可能性不大），</p><p>因此有可能无法做到最优。</p><p>当使用 Unity 开发时，默认的 Mono 包含库可以说大部分用不上，在 Player Setting（Edit-&gt;Project Setting-&gt;Player 或者 Shift+Ctrl(Command)+B 里的 Player Setting 按钮）</p><p>面板里，将最下方的 Optimization 栏目中 “Api Compatibility Level” 选为. NET 2.0 Subset，表示你只会使用到部分的. NET 2.0 Subset，不需要 Unity 将全部. NET 的 Api 包含进去。接下来的 “Stripping Level” 表示从 build 的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分内容。你需要保证你的代码没有用到这部分被剥离的功能，</p><p>选为 “Use micro mscorlib” 的话将使用最小的库（一般来说也没啥问题，不行的话可以试试之前的两个）。库剥离可以极大地降低打包后的程序的尺寸以及程序代码的内存占用，唯一的缺点是这个功能只支持 Pro 版的 Unity。</p><p>这部分优化的力度需要根据代码所用到的. NET 的功能来进行调整，有可能不能使用 Subset 或者最大的剥离力度。</p><p>如果超出了限度，很可能会在需要该功能时因为找不到相应的库而 crash 掉（<a href="http://lib.csdn.net/base/ios" title="iOS 知识库">ios</a>的话很可能在 Xcode 编译时就报错了）。</p><p>比较好地解决方案是仍然用最强的剥离，并辅以较小的第三方的类库来完成所需功能。</p><p>一个最常见问题是最大剥离时 Sysytem.Xml 是不被 Subset 和 micro 支持的，如果只是为了 xml，完全可以导入一个轻量级的 xml 库来解决依赖（Unity 官方推荐这个）。</p><p>关于每个设定对应支持的库的详细列表，可以在这里找到。关于每个剥离级别到底做了什么，Unity 的文档也有说明。</p><p>实际上，在游戏开发中绝大多数被剥离的功能使用不上的，因此不管如何，库剥离的优化方法都值得一试。</p><hr><h3 id="托管堆优化"><a href="#托管堆优化" class="headerlink" title="托管堆优化"></a>托管堆优化</h3><p>Unity 有一篇不错的关于托管堆代码如何写比较好的说明，在此基础上我个人有一些补充。</p><p>首先需要明确，托管堆中存储的是你在你的代码中申请的内存（不论是用<a href="http://lib.csdn.net/base/javascript" title="JavaScript 知识库">js</a>，C# 还是 Boo 写的）。</p><p>一般来说，无非是 new 或者 Instantiate 两种生成 object 的方法（事实上 Instantiate 中也是调用了 new）。</p><p>在接收到 alloc 请求后，托管堆在其上为要新生成的对象实例以及其实例变量分配内存，如果可用空间不足，则向系统申请更多空间。</p><p>当你使用完一个实例对象之后，通常来说在脚本中就不会再有对该对象的引用了（这包括将变量设置为 null 或其他引用，超出了变量的作用域，</p><p>或者对 Unity 对象发送 Destory()）。在每隔一段时间，Mono 的垃圾回收机制将检测内存，将没有再被引用的内存释放回收。总的来说，</p><p>你要做的就是在尽可能早的时间将不需要的引用去除掉，这样回收机制才能正确地把不需要的内存清理出来。但是需要注意在内存清理时有可能造成游戏的短时间卡顿，</p><p>这将会很影响游戏体验，因此如果有大量的内存回收工作要进行的话，需要尽量选择合适的时间。</p><p>如果在你的游戏里，有特别多的类似实例，并需要对它们经常发送 Destroy()的话，游戏性能上会相当难看。比如小熊推金币中的金币实例，按理说每枚金币落下台子后</p><p>都需要对其 Destory()，然后新的金币进入台子时又需要 Instantiate，这对性能是极大的浪费。一种通常的做法是在不需要时，不摧毁这个 GameObject，而只是隐藏它，</p><p>并将其放入一个重用数组中。之后需要时，再从重用数组中找到可用的实例并显示。这将极大地改善游戏的性能，相应的代价是消耗部分内存，一般来说这是可以接受的。</p><p>关于对象重用，可以参考 Unity 关于内存方面的文档中 Reusable Object Pools 部分，或者 Prime31 有一个是用 Linq 来建立重用池的视频教程（Youtube，需要 FQ，上，下）。</p><p>如果不是必要，应该在游戏进行的过程中尽量减少对 GameObject 的 Instantiate()和 Destroy()调用，因为对计算资源会有很大消耗。在便携设备上短时间大量生成和摧毁物体的</p><p>话，很容易造成瞬时卡顿。如果内存没有问题的话，尽量选择先将他们收集起来，然后在合适的时候（比如按暂停键或者是关卡切换），将它们批量地销毁并 且回收内存。Mono 的内存回收会在后台自动进行，系统会选择合适的时间进行垃圾回收。在合适的时候，也可以手动地调用 System.GC.Collect()来建议系统进行一次垃圾回收。</p><p>要注意的是这里的调用真的仅仅只是建议，可能系统会在一段时间后在进行回收，也可能完全不理会这条请求，不过在大部分时间里，这个调用还是靠谱的。</p><hr><h3 id="本机堆的优化"><a href="#本机堆的优化" class="headerlink" title="本机堆的优化"></a>本机堆的优化</h3><p>当你加载完成一个 Unity 的 scene 的时候，scene 中的所有用到的 asset（包括 Hierarchy 中所有 GameObject 上以及脚本中赋值了的的材质，贴图，动画，声音等素材），</p><p>都会被自动加载（这正是 Unity 的 <a href="http://lib.csdn.net/base/aiplanning" title="人工智能规划与决策知识库">智能</a> 之处）。也就是说，当关卡呈现在用户面前的时候，所有 Unity 编辑器能认识的本关卡的资源都已经被预先加 入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。Unity 最 初的设计目的还是面向台式机，</p><p>几乎无限的内存和虚拟内存使得这样的占用似乎不是问题，但是这样的内存策略在之后移动平台的兴起和大量移动设备游戏的制作中出现了弊端，因为移动设 备能使用的资源始终非常有限。因此在面向移动设备游戏的制作时，尽量减少在 Hierarchy 对资源的直接引用，而是使用 Resource.Load 的方 法，在需要的时候从硬盘中读取资源，</p><p>在使用后用 Resource.UnloadAsset()和 Resources.UnloadUnusedAssets()尽快将其卸载掉。总之，这里是一个处理时间和占用内存空间的 trade off，</p><p>如何达到最好的效果没有标准答案，需要自己权衡。</p><p>在关卡结束的时候，这个关卡中所使用的所有资源将会被卸载掉（除非被标记了 DontDestroyOnLoad）的资源。注意不仅是 DontDestroyOnLoad 的资源本身，</p><p>其相关的所有资源在关卡切换时都不会被卸载。DontDestroyOnLoad 一般被用来在关卡之间保存一些玩家的状态，比如分数，级别等偏向文 本的信息。如果 DontDestroyOnLoad 了一个包含很多资源（比如大量贴图或者声音等大内存占用的东西）的话，这部分资源在场景切换时无法卸 载，将一直占用内存，</p><p>这种情况应该尽量避免。</p><p>另外一种需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附 着在 DontDestroyOnLoad 的 GameObject 上了）。而这些脚本很可能含有对其他物体的 Component 或者资源的引用，这样相关的 资源就都得不到释放，</p><p>这绝对是不想要的情况。另外，static 的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。</p><p>因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用 Destroy()</p><p>或者将其设置为 null。这样在垃圾回收的时候，这些内存将被认为已经无用而被回收。</p><p>需要注意的是，Unity 在一个场景开始时，根据场景构成和引用关系所自动读取的资源，只有在读取一个新的场景或者 reset 当前场景时，才会得到清理。</p><p>因此这部分内存占用是不可避免的。在小内存环境中，这部分初始内存的占用十分重要，因为它决定了你的关卡是否能够被正常加载。因此在计算资源充足</p><p>或是关卡开始之后还有机会进行加载时，尽量减少 Hierarchy 中的引用，变为手动用 Resource.Load，将大大减少内存占用。在 Resource.UnloadAsset()和 Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源 会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为 null 或者 Destroy。</p><p>同样需要注意，这两个 Unload 方法仅仅对 Resource.Load 拿到的资源有效，而不能回收任何场景开始时自动加载的资源。与此类似的还有 AssetBundle 的 Load 和 Unload 方法，灵活使用这些手动自愿加载和卸载的方法，是优化 Unity 内存占用的不二法则。</p><p>总之这些就是关于 Unity3d 优化细节, 具体还是查看 Unity3D 的技术手册, 以便实现最大的优化。</p><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shader 学习笔记</title>
    <link href="https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://tamsiree.com/GameEngine/Unity/Shader/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-26T16:34:43.000Z</published>
    <updated>2025-11-05T13:53:39.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里是前言介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一口气解决-RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend-和-Stencil"><a href="#一口气解决-RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend-和-Stencil" class="headerlink" title="一口气解决 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend 和 Stencil"></a>一口气解决 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend 和 Stencil</h2><p>** 知道吗，如果只是想要实现 Xray 效果的话，其实并不难。**</p><p><img src="https://pic1.zhimg.com/v2-8d07b211268f64c663515a011b1bca14_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-8d07b211268f64c663515a011b1bca14_720w.jpg"></p><p><em>实现上图的效果，原理就是对角色画两次。第一次是被遮挡住的效果(半透明、单色)，第二次是正常的效果(为了简化这里使用 unlight 只显示贴图)</em></p><p>** 这两个 pass 最大的区别，在于使用不同的 Ztest(深度测试)。但是这一次我决定不仅仅只写关于 Ztest 的问题。反正我已经决定对抗懒癌晚期，那就干脆一口气把 RenderQueue、Ztest、Zwrite、AlphaTest、AlphaBlend、StencilTest 这些烂七八糟的东西都拎出来写一遍, 因为这些东西有很多地方都是相通的，一起说明白反而省些力气。**</p><p>** 不过说实话，这些东西确实是有点麻烦。我尽自己最大的努力去把这些东西说明白。但是鉴于个人能力实在有限，如果有哪里说得不对或者不清楚，还请见谅。**</p><p><img src="https://pic2.zhimg.com/v2-0ba75819a33e8c1362a2b9f61677c92d_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-0ba75819a33e8c1362a2b9f61677c92d_720w.jpg"></p><p><em>如上图，现在有三个多边形分别是红色盒子绿色盒子和蓝色盒子，在镜头里红色的盒子在最前面（距离摄像机最近），所以盖住了其他两个颜色的盒子。</em></p><p>** 按照我们的生活常识，显示最前面的红盒子这样的结果是再正常不过了。可是计算机并不存在所谓的 “人类的常识”，它只依靠数学的方法去处理问题。而如何判断谁在前谁在后，这个问题却并非那么简单，并且很容易让人陷入混乱。因为这牵扯到 Ztest(深度测试)ZWrite(深度写入或者叫深度缓存) 和 RenderQueue(渲染序列)。**</p><p>** 如果是 2D 的话，只需要一个 Zindex 就可以确定 Sprite 之间的前后 (覆盖) 关系。RenderQueue(渲染序列)和这个 Zindex 的概念很像，都是直截了当指定了一个渲染的顺序。 关于 RenderQueue 可用的标签，有：**</p><p><strong>Background:1000</strong></p><p><strong>Geometry:2000</strong></p><p><strong>AlphaTest:2450</strong></p><p><strong>Transparent:3000</strong></p><p><strong>Overlay:4000</strong></p><p><strong>(写起来的样子是这样的：”Queue” = “TransParent”)</strong></p><p>** 数字越大的物体，其渲染顺序就越靠后，就会遮住数字小的物体。从名字里也能看得出来，BackGround 自然是那种最先渲染然后被所有东西覆盖掉的东西(比如天空盒)。而像 Overlay 这样的东西在绝大部分物体之后渲染，适合用来制作 UI。**</p><p>** 值得注意的是半透明物体 (Transparent Objects) 的渲染顺序十分靠后。一般情况下是在所有非半透明物体渲染之后，再渲染半透明物体。至于其原因等稍后再说明。**</p><p>** 除了使用默认的标签之外，还可以更详细指定渲染序列，写起来大概是这样的: “Queue” = “Geometry+1” 。这样这个物体会在所有 Geometry 渲染之后再渲染，顺序增加了一个“身位”。如果是 “Queue” = “Geometry+5000” ，那可就是比 Overlay 还靠后，绝对是最最后渲染的东西，理论上覆盖在一切东西之上。**</p><p>** 听起来似乎很简单，好像我们已经拿到了一把万能钥匙，可以随意控制那个小小 3D 世界里的所有一切。然而进度条告诉你事情并没这么简单（雾）。**</p><p>** 因为显卡既不允许你用这么简单粗暴的方式控制渲染结果，实际上你也没法用简单的 Queue 值来确定物体渲染的前后关系。**</p><p>** 试想一个大场景里动辄成千上万的物体，你如何去一个一个指定他们的 RenderQueue？即便你真的这么做了，一旦镜头转个 180° 是不是就全错了？更不要提每一帧都在变换位置的角色。就是神仙也不可能预知他们所处的位置到底应该是渲染序列的哪一个位置。**</p><p>** 这一点和 2D 游戏有着本质上的区别。在 2D 游戏里指定 ZIndex 的做法在 3D 游戏里肯定是走不通的。**</p><p>** 所以在大多数情况下(除了制作 UI 和天空盒之外)，这个 RenderQueue 并没有什么卵用。我用几张图来具体说明。**</p><p><img src="https://pic3.zhimg.com/v2-b7ff915181dbe3835625eb19b7569f7e_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-b7ff915181dbe3835625eb19b7569f7e_720w.jpg"></p><p><img src="https://pic4.zhimg.com/v2-8587a7b0b06c6d07818682107106aea7_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-8587a7b0b06c6d07818682107106aea7_720w.jpg"></p><p><em>如上图，正常情况下这三个盒子都是 “Queue” = “Geometry”。因为是“正常情况”，所以显示的效果肯定是正确的(红色的盒子挡住其他两个，同时绿色盒子挡住蓝色盒子)。但是打开 FrameDebugger 你会发现，渲染的顺序是很混乱的。也许是因为做测试的时候改动过 RenderQueue。现在莫名其妙的是先中间后两边。</em></p><p>** 关于非透明物体渲染的排序问题，我在这里多说两句。3D 实时渲染性能消耗的两个重要部分是 CPU 和 GPU。如果想节省 GPU 的时间，就要在渲染之前计算一次渲染顺序，这样在 Ztest 之后就，被遮挡的部分就不会进入 fragment shader；反之想要解放 CPU 的负担，就不要对渲染物体进行排序(排序这个东西大家都懂的)。当然这样会多次渲染被遮挡的像素。**</p><p>** 在 Unity3d 文档里，我找到了关于控制非透明物体渲染顺序的 API，其描述如下:**</p><p><img src="https://pic4.zhimg.com/v2-a4d69c1236e4e1f51e8346871b4900ab_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-a4d69c1236e4e1f51e8346871b4900ab_720w.jpg"></p><p><em>在我的印象当中以前是没有 Camera.opaqueSortMode 这个东西的，估计是新版本后加入的(我的 5.4.0 版本已经比较老了)。大家可以根据自己游戏性能的考虑去做优化。</em></p><p><img src="https://pic3.zhimg.com/v2-b7ff915181dbe3835625eb19b7569f7e_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-b7ff915181dbe3835625eb19b7569f7e_720w.jpg"></p><p><img src="https://pic3.zhimg.com/v2-b7aa162382d592cbd95b50b0d2d47f9e_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-b7aa162382d592cbd95b50b0d2d47f9e_720w.jpg"></p><p><em>如上图，当我们强行让绿色盒子的 RenderQueue 发生改变(“Queue”=”Geometry+1”)，这样绿色盒子的渲染序列变为最后渲染，然而实际的效果依然没有改变，红色盒子一如既往地盖住了绿色盒子(哪怕红色盒子是在绿色盒子之前就渲染出来的)。</em></p><p><strong>RenderQueue 之所以只决定了物体的渲染顺序，却没能决定物体的渲染结果，是因为显卡在渲染的时候，更多的是依靠深度测试 (Ztest) 来进行判断。</strong></p><p><strong>Ztest 的工作原理是这样的(假设这 3 个盒子是屏幕上的 3 个像素点)：</strong></p><p><strong>Step1：显卡按照渲染顺序先画出了蓝色盒子的像素(渲染的每一个步骤都可以在 FrameDebugger 里看到，真是方便)</strong></p><p><img src="https://pic4.zhimg.com/v2-13688250bfcb137b4c402b4c68b3223b_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-13688250bfcb137b4c402b4c68b3223b_720w.jpg"></p><p>** 在画蓝色盒子的像素的时候，除了 RGB 三个颜色的值以外，显卡还会把这个像素与当前镜头的距离记录下来 (这里记录为 z1)。与背景相比，蓝盒子显然距离镜头更近，即 z1&lt;∞。按照“默认” 的做法 (注意在这个例子里我一直强调是在“默认” 的情况，或者 “默认” 的做法)，画出蓝色的盒子，并且将摄像机在这个像素上的深度值替换为 z1。**</p><p><strong>Step2: 接下来按照渲染顺序，开始渲染红色的盒子。</strong></p><p><img src="https://pic2.zhimg.com/v2-f014923f3185f969480655821527fcbd_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-f014923f3185f969480655821527fcbd_720w.jpg"></p><p>** 当然红色盒子也有一个深度值 (记录为 z2)。这个时候显卡会用 z2 和摄像机在当前像素的深度值 z1 进行比较，发现 z2&lt;z1(因为红色盒子距离镜头比较近)。于是按照“默认” 的做法画出红色的盒子，并且将摄像机当前像素值更新为 z2。**</p><p><strong>Step3：接下来按照渲染顺序，开始渲染绿色的盒子。</strong></p><p><img src="https://pic1.zhimg.com/v2-c85bf90a5658ecc2d4ce177980bc2170_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-c85bf90a5658ecc2d4ce177980bc2170_720w.jpg"></p><p><em>虽然这张图和上一张很像，但是注意这个时候渲染的是被 “神隐” 的绿色盒子</em></p><p>** 当渲染绿色盒子的时候，情况就发生了变化。我们知道绿色盒子之所以最后渲染，是因为我们强行改变了绿色盒子的渲染顺序(“Queue” = “Geometry+1”)。但是绿色盒子距离摄像机的距离是大于红色盒子的。**</p><p>** 所以当渲染绿色盒子的时候，其深度值 (记录为 z3) 必然会比当前像素的深度值 z2 大 (z3&gt;z2，和上一步完全相反的情况)。于是显卡按照“默认” 的做法，扔掉了绿色盒子的像素，并且保持当前像素值为 z2。其结果就是看起来绿色盒子完全被红色盒子遮挡住了(哪怕它是最后渲染出来的物体)。**</p><p>** 这一套流程走下来我们不难看出，所谓 “默认” 的工作原理(注意我再次强调是“默认”)，就是当一个物体像素的 z 值小于当前镜头在该位置像素的深度值时，画出该物体的这个像素，并且将这个较小的 z 值更新为当前镜头在这个像素上的深度值。**</p><p>** 反之，当一个物体的像素的 z 值大于当前镜头在该位置像素的深度值时，不画出该物体的这个像素，并且保留摄像机在这个像素上的深度值。**</p><p>** 说起来实在是拗口，也不知道各位是否能看明白。反正我是尽力了。如果非要打个比方来说，我想和当初学 C 语言的时候进行数字排序的做法差不多。不知道各位同学是不是看起来很怀念呢？**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>],i,j,temp;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; 请输入十五个整数：&quot;</span>);  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="number">15</span>;j++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">&#123;</span><br><span class="line">temp=a[j]；</span><br><span class="line">a[j]=a[i]；</span><br><span class="line">a[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; 排序后的数是：%d&quot;</span>,a[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 而这个工作流程，就是所谓的 Ztest+Zwrite。**</p><p>** 比较新旧 z 值的大小，就是 Ztest; 之后更新摄像机每一个像素的 z 值，就是 Zwrite。Ztest 影响的是当前物体的显示；Zwrite 影响的是之后渲染物体的显示。**</p><p>** 可以看出来如果不进行 Zwrite 更新镜头的 z 值，那么 Ztest 的时候就会出现不正常的结果(完全不知道前面渲染出来的物体的深度，只能完全依赖 RenderQueue)；而 Zwrite 是否更新摄像机在当前像素上的 z 值，根据两个条件：**</p><p>** 一是要看是否允许进行 Zwrite（默认是 Zwrite On。当然很多时候我们会手动关掉 Zwrite, 即 Zwrite Off）；二是要看 Ztest 是否通过，只有通过了 ZWrite 才会更新新的 z 值。**</p><p>** 请务必注意这里：z 值是否更新并不在于物体在该像素上的 z 值比摄像机在该像素上的 z 值小。而在于是否通过 Ztest。只不过在默认的情况下，通过 Ztest 的条件是小于等于。如果 Ztest 的条件改变，那么 Zwrite 写入的新值就未必比原来的值小(关于 Ztest 的条件马上就会提到)。**</p><p><strong>Zwrite 的概念相对简单，无非就是根据条件，对一个变量进行反复地赋值。比较有意思的 Ztest。在三个盒子的例子里，我一直都在强调 “默认” 两个字。那么默认是什么呢，就是 Zwrite On + Ztest On。Zwrite 就两种情况(On 或者 Off)。而对于 Ztest 来说，条件就要丰富得多得多。Ztest 的条件总共有如下几种:</strong></p><p><strong>Less (当物体的这个像素的 Z 值小于当前摄像机在这个像素上的 Z 值，则通过 Ztest)</strong></p><p><strong>LEqual(条件变为小于等于)</strong></p><p><strong>Greater(条件变为大于)</strong></p><p><strong>GEqual(条件变为大于等于)</strong></p><p><strong>Equal(条件变为相等)</strong></p><p><strong>NotEqual(条件变为不相等)</strong></p><p><strong>Always(Ztest 永远通过)</strong></p><p><strong>Never(Ztest 永远不通过)</strong></p><p><strong>Off(等同于 ZTest Always)</strong></p><p><strong>On(等同于 ZTest LEqual)</strong></p><p><strong>ZTest LEqual 也就是上面一直提到的 “Ztest 默认工作的原理”。当不写明 Ztest 的处理方式的时候，ZTest 的通过条件 LEqual。因此我们就总能看到距离摄像机近的物体(Z 值小) 盖住了距离摄像机远 (Z 值大) 的物体，这样 “理所当然” 的效果。</strong></p><p>** 有意思的是当我们相要搞些事情的时候，就可以利用 ZTest 那些非默认的选项。当物体被遮挡住的时候(即 Ztest Greater), 原本是看不见的。但是 Xray 的效果不就正是要看见原本看不见的东西么？**</p><p>** 所以 Xray 效果的第一个 pass。我使用以下的“黑科技”:**</p><p><img src="https://pic3.zhimg.com/v2-5b06b29a38f18c138126a2f21c14ac52_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-5b06b29a38f18c138126a2f21c14ac52_720w.jpg"></p><p><em>Blend SrcAlpha OneMinusSrcAlpha 说明我们要用 alpha blend 的方式进行渲染(关于 Alpha Blend 后面会提到)。Ztest Greater 意味着我就是要处理 z 值大于摄像机 z 值的情况(只有在别的物体后面 z 值才会比较大，也就是说只有实际上被别的物体挡住的时候，才会用这种方式渲染)。同时关掉 Zwrite。</em></p><p>** 关闭 Zwrite 是比较重要的一步，开着 Zwrite 会把错误的 z 值 (比较大的 z 值) 更新上去。正如前面特别强调的，Zwrite 的条件之一是通过 Ztest。这一次 Ztest 的条件是 Greater，所以通过 Ztest 以后 z 值是比原来大的，更新上去以后会对其他物体的深度判断造成影响，关于这一点我们马上举例说明。**</p><p>** 第一个 pass 效果如下:**</p><p><img src="https://pic2.zhimg.com/v2-7698ec0e7c14466964a68304e5729ef9_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-7698ec0e7c14466964a68304e5729ef9_720w.jpg"></p><p><em>我们看到，Z 值比较小的像素(即未被遮挡住的像素)，反而因为没有处理 Ztest Lequal 的 Pass 而无法显示出来。</em></p><p>** 接下来就是第二个 Pass。我们使用新的 Ztest 条件：**</p><p><img src="https://pic3.zhimg.com/v2-d9bcb63d4b5c7f646f06a5447b923e76_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-d9bcb63d4b5c7f646f06a5447b923e76_720w.jpg"></p><p>** 其实这就是刚才我们一直所说的“默认情况”。换句话是其实 Zwrite On 和 ZTest LEqual 完全可以不用写。效果如下：**</p><p><img src="https://pic1.zhimg.com/v2-8d07b211268f64c663515a011b1bca14_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-8d07b211268f64c663515a011b1bca14_720w.jpg"></p><p>** 那么问题来了，如果我们在第一个 pass 中打开 Zwrite 会出现什么结果呢？**</p><p>** 第一个 Pass 打开 Zwrite 的效果如下:**</p><p><img src="https://pic1.zhimg.com/v2-d91e5808b6bc4abe5b2be91c064a1888_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-d91e5808b6bc4abe5b2be91c064a1888_720w.jpg"></p><p>** 无论是否被遮挡，人物都会显示成 Pass2 的效果（而且还有明显得错误）。**</p><p>** 我们利用刚才获知的原理来分析一下。在 Pass1 通过 Ztest 之后，因为打开了 Zwrite，所以将角色在 Pass1 阶段渲染出来的像素的深度值写入到屏幕当前的深度值。注意这个深度值是大于墙的像素的深度值的，但是依然被写进镜头的深度当中。**</p><p>** 当来到 Pass2 时，Ztest 的条件是 LEqual(小于等于)。因为当前摄像机中该像素的深度值就是角色身上像素的深度 (因为上一步通过 Zwrite 已经写入)。所以完全符 Equal(相等) 的条件。于是 Pass2 的像素成功通过 ZTest 并被画出来，Pass1 画出的像素自然就被 Pass2 覆盖掉了。**</p><p>** 有兴趣的朋友也可以在 Pass2 中试一试，当 Ztest 的条件是 Less 的时候会出现什么效果。这里就不一一举例了。**</p><p>** 以上是关于 ZTest、Zwrite 和 RenderQueue 三个容易产生混乱的概念。下面又是一个类似的概念：Stencil（模板）。**</p><p><strong>Stencil 和深度一样，是写进 buffer 里的一个数值(Z buffer 和 Stencil Buffer 这两个词你应该听过很多次了)。</strong></p><p><strong>Stencil 的工作原理和 Ztest+Zwrite 很相似，但是灵活性更高一些。关于 Stencil 的一些具体例子和讲解，网上有很多。我这里的重点就不放在实际例子上，而是关于模板和深度这两个东西在用法和原理上的异同。</strong></p><p>** 关于 Ztest+Zwrite 我已经提到过很多次了，最简单的理解就是“比较”+“写入”。如果你真的对其原理理解得非常好，那么搞定 Stencil 就没有任何问题。**</p><p>** 在 Unity3D 里面并不存在 “Stencil Test” 和“Stencil Write”这两个字眼儿。Stencil 就是一个过程，同时包含了 “比较” 和“写入”两个步骤。**</p><p><strong>Stencil 的完整语法：</strong></p><p><strong>stencil{</strong></p><p><strong>Ref referenceValue</strong></p><p><strong>ReadMask readMask</strong></p><p><strong>WriteMask writeMask</strong></p><p><strong>Comp comparisonFunction</strong></p><p><strong>Pass stencilOperation</strong></p><p><strong>Fail stencilOperation</strong></p><p><strong>ZFail stencilOperation</strong></p><p><strong>}</strong></p><p>** 具体详尽的用法写起来太麻烦(我实在是怕麻烦怕得要死)，我就稍微总结一下：总的来说你只要关注 Ref\Comp\Pass 三个关键词。再稍微复杂一点儿的情况，你可能需要用到 Fail\Zfail。最后在需要更复杂的判断的时候，你也许会需要用到那两个 Mask。**</p><p>** 我们再回顾一下 Ztest+Zwrite 的原理。获取 Z 值 -&gt;测试 (比较)Z 值 -&gt; 写入新的 Z 值(如果通过测试)。**</p><p>** 我们假定 Stencil 也有一个值叫 Ref 值。那么 Stencil 的用法也实在是看着眼熟：获取 Ref 值 -&gt;测试 (比较)Ref 值 -&gt; 写入新的 Ref 值(如果通过测试)。**</p><p>** 说到底这俩玩意儿的区别，就是在第一步，获取当前物体在这个像素上的这个变量。**</p><p><strong>Z 值是根据像素到摄像机的距离算出来的，不会因为你的个人意愿而改变；S 值是你可以随便填的(是的随便填，想写几就写几，范围 0-255)。</strong></p><p>** 这样一来 Stencil 可以帮助你突破 Ztest 所带来的限制，用更灵 (jian) 活(dan)便 (cu) 捷(bao)的方式来控制渲染效果。**</p><p><strong>Ref 就是写入这个像素的 Ref 值，正如我之前提到的想写几就写几完全看心情 (所以我一直都认为叫 Stencil Buffer 模板缓冲实在是有点唬人的感觉。改成“看哪个数字顺眼就用哪个数字比大小” 更贴切一些)。</strong></p><p><strong>Com 是进行 Test 的条件，当你看到一大堆 Less\LEqual\Greater\GEqual\Equal\NotEqual\Always\Never 这样的字眼儿，是不是感到非常的眼熟？这一步比较的过程和 Ztest 完全一样。</strong></p><p><strong>Pass 和 Zwrite 简直就是一个妈生出的俩个孩儿。区别就是这个小哥比他兄弟花样儿多点。Zwrite 无非就是写入或者不写入(On or Off)。Pass 甚至还可以控制如何写入(虽然大多数情况下可能用不到)。</strong></p><p><img src="https://pic4.zhimg.com/v2-efbed4ee6525cab050651da10572b817_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-efbed4ee6525cab050651da10572b817_720w.jpg"></p><p><em>Pass 支持的条件一览，其中 Keep 类似于 Zwrite 里的 Off;Replace 类似于 ZWrite 里的 On(此图来自互联网)。</em></p><p>** 举个栗子，如下图所示，现在有一面墙和一个茶壶，按照与镜头的位置关系，墙体遮挡住茶壶的下半部分。**</p><p><img src="https://pic4.zhimg.com/v2-b12d128a7157f7caf317d7999d80380b_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-b12d128a7157f7caf317d7999d80380b_720w.jpg"></p><p>** 如果我们想要做一个如 Flash 里的 Mask Layer 效果。就可以使用 Stencil 来做。**</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stencil </span><br><span class="line">&#123;</span><br><span class="line">    // 摄像机在当前像素的默认 stencil 值是 0</span><br><span class="line">    // 设置当前物体当前像素的参考值为 100</span><br><span class="line">    Ref 100 </span><br><span class="line">    // 永远通过 stencil 测试</span><br><span class="line">    // 这个 shader 的唯一目的就是在这个物体所占的像素上写入 stencil 值 100</span><br><span class="line">    Comp Always</span><br><span class="line">    // 通过后(因为 Comp Always 所以必然会通过), 将当前 stencil 值更新为 ref 的值(100)</span><br><span class="line">    Pass replace</span><br><span class="line">    // 这样墙所占有的像素的 Stencil 值就被确定下来了</span><br><span class="line">    // 如果有多个墙, 也可以用 Comp GEqual 或者 Comp LEqual</span><br><span class="line">    // 来找一个最大 / 最小的 stencil 值作为当前像素的 stencil 值</span><br><span class="line">&#125;</span><br><span class="line">Zwrite Off </span><br></pre></td></tr></table></figure><p>** 注意墙的深度缓冲要关掉，否则茶壶在做 Ztest 的时候会因为遮挡关系而被弃掉像素。**</p><p>** 接着是茶壶的 shader:**</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stencil </span><br><span class="line">&#123;</span><br><span class="line">// 像素默认的 stencil 值应该是 0</span><br><span class="line">// 设置茶壶在当前像素的参考值为 90</span><br><span class="line">Ref 90</span><br><span class="line">// 因为之前墙的 ref 值 100 已经写入到摄像机里, 所以当前像素的 ref 值已经是 100</span><br><span class="line">        // 因为茶壶的 Ref 值（90）小于当前摄像机在该位置的像素的 ref 值 100，测试通过 </span><br><span class="line">Comp LEqual</span><br><span class="line">// 通过后, 不更新 ref 值</span><br><span class="line">Pass keep</span><br><span class="line">// 这样墙在该像素上的 Stencil 值(100) 依然是摄像机在当前像素上的人 ref 值</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-b6d4f7bdce4ee7b56561149dac30f034_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-b6d4f7bdce4ee7b56561149dac30f034_720w.jpg"></p><p><em>茶壶被透明墙遮挡住的部分，因为其 Stencil 值通过测试，所以被显示了出来。</em></p><p>** 当然这里存在一个潜在的问题。试想如果这两个非透明物体在渲染的时候，顺序并不是先画墙再画茶壶。其结果就会因为墙的 ref 值没有提前更新好，而造成了茶壶在比较的 ref 值的时候出现我们不期望的结果。所以说，虽然我们并没有太多注意过非透明物体的渲染顺序。但是这东西确实会在各种意想不到的地方，造成莫名其妙的显示错误。**</p><p>** 最后就是 Alpah Test 和 Alpha Blend。看到 XXXTest 是不是第一反应又是 Test + Write 这种东西。然后又是一堆 Lequal、Gequal 这些乱七八糟的条件。**</p><p>** 好消息是这个世界上并不存在 “Alpha Write” 这种东西，并且 Alpha Test 也远没有之前那两个 Test 那么复杂；坏消息是你需要多了解一个新的概念——Alpha Blend, 一个既麻烦又特别容易出问题的玩意儿。**</p><p>** 首先一句话解决 Alpha Test。与其他的 Test 概念相通的是：Alpha Test 的运作原理也是当条件成立时，画出该像素，否则抛弃该像素。但是它的特点是无需 (也无法) 同镜头中同一个位置的其他像素值进行比较(自然更加无法进行写入)。**</p><p>** 相对而言，其他的 Test 还需要跟别的东西比较一下，Alpha Test 并不存在这个过程，它只和自己本身存在的变量进行比较，是一个非常自闭的过程。**</p><p>** 因为 AlpahTest 有以上的特性，所以在 Unity 的 shader 里并没有 Alpha Test On\Off 这样的关键字。Alpha Test 可用的函数只有两个，一个是 clip 一个是 discard。clip(x)函数的变量 x 必须小于 0 才会通过测试。比如说简单粗暴的 clip(-1)就把所有像素都干掉了；而用 if(){discard;}可以使用任意条件触发。相对而言 discard 比较灵活，但是要用到 if 让我很不爽。这两个函数的具体用法大家可自行百度(好吧是我懒得贴)。**</p><p>** 一般做渐变消失的时候，会用到 clip\discard。比如下图 **</p><p><img src="https://pic3.zhimg.com/v2-d83f5829ff843cbd471919d7f1a03b62_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-d83f5829ff843cbd471919d7f1a03b62_720w.jpg"></p><p><img src="https://pic4.zhimg.com/v2-3b94cb2c6143c778c8200c79236721df_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-3b94cb2c6143c778c8200c79236721df_720w.jpg"></p><p><img src="https://pic1.zhimg.com/v2-d61d607e1b5f0267261a5fd1cab3b0d4_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-d61d607e1b5f0267261a5fd1cab3b0d4_720w.jpg"></p><p><em>把不断变化的时间值传入 shader，来不断减小 clip()函数的变量，就能做出如上的效果。当然这个效果还可以进一步改进，因为和本文无关所以就不展开了。需要注意的是在移动平台上，Alpha Test 的消耗较大，属于能不用就不用的东西(就像 if、for 这些东西能不用尽量别用)。</em></p><p><em>如果你非要搞明白为什么简单粗暴的 alpha test 反而消耗大，就自己去查关于 PowerVR GPUs、Deferred Tile-Based-Rendering、Early-Z 等等这些知识点，对于我一个懒人来说搬运这些东西简直跟要了我的命没什么区别。</em></p><p><strong>Alpha Test 是一个非黑即白的过程。通过或者不通过，画出或者抛弃，简单粗暴一目了然。当然我们大多数时候并不喜欢如此粗暴的处理，毕竟人不是机器，凡事还需要温柔一点。所以我们更多的时候用的是 Alpha Blend 而非 Alpha Test。</strong></p><p><strong>Alpha Blend 即透明混合。我们之前提到的所有 Test 方式，不是你盖住我就是我盖住你，总之没有任何 “和谐共处” 的可能性。而 Alpha Blend 提供了这种可能性。根据 Blend 的方式不同，该物体在这个像素的 rgb 值会和其他物体在这个像素上的 rgb 进行混合。</strong></p><p><img src="https://pic1.zhimg.com/v2-42e0d0ff41ef2b67434b653bd8aed8e4_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-42e0d0ff41ef2b67434b653bd8aed8e4_720w.jpg"></p><p><em>Alpha Blend 的效果，在一般意义上这就是我们理解的“半透明”。</em></p><p>** 我们之前曾经提到过，半透明的物体 (也就是需要用 Alpha Blend 方式渲染的物体) 一般来说渲染序列比较靠后(通常我们用 “Queue” = “Transparent”)。道理很简单，你要和别的像素混合，那么必须要有其他像素已经画出来才行。如果透明物体被提前渲染出来，而当时还不存在后面要跟它混合的像素，自然就会出现错误。**</p><p>** 所以难怪只有 Overlay 这种做 UI 的物体，渲染顺序会排在 Transparent 之后——毕竟 UI 是不需要和场景中的半透物体进行混合。**</p><p><img src="https://pic1.zhimg.com/v2-87f12e69afa888da3a5d7e8c87c2e028_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-87f12e69afa888da3a5d7e8c87c2e028_720w.jpg"></p><p><img src="https://pic2.zhimg.com/v2-a658ce89bdb0b4f449be427f6ea3f85d_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-a658ce89bdb0b4f449be427f6ea3f85d_720w.jpg"></p><p><em>如图所示，当半透明物体 (红色方形粒子) 没有被指定渲染顺序为 Transparent 的时候，在混合天空盒的时候发生了明显错误。红圈是渲染粒子的部分，黑圈是渲染天空盒的部分。很明显在渲染粒子的时候，并没有渲染出来天空盒，所以也就没有混合 (Blend) 操作时可以用来混合的颜色。</em></p><p><img src="https://pic4.zhimg.com/v2-ad239998df983e903dff334dff9f95fb_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-ad239998df983e903dff334dff9f95fb_720w.jpg"></p><p><img src="https://pic4.zhimg.com/v2-e9da208c4b3cdae9044c33bfef0244df_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-e9da208c4b3cdae9044c33bfef0244df_720w.jpg"></p><p><em>当半透明的渲染顺序被正确指定为 Transparent 的时候，渲染天空盒发生在渲染粒子之前，也就是在画粒子的时候天空盒的像素就已经存在了。这样粒子就有了可以进行混合操作的颜色，因此半透明粒子与天空盒的混合效果正确。(说实话我很奇怪为什么 Unity 默认的天空盒渲染顺序居然不是 BackGround，也许他们有他们自己的考虑吧。)</em></p><p>** 注意在谈关于 Alpha Blend 的时候，几乎每一个细节都和 RenderQueue 息息相关。这和之前的 Ztest 完全不同。其区别在于 Ztest 只关心谁盖住了谁，一旦被盖住就不再在意被盖住的像素到底是个什么样; 然而 Alpha Blend 却需要关注任何一个画在当前位置的像素颜色，只有获得这些颜色的全部信息，才可能进行正确的混合。这也是为什么 Alpha Blend 的消耗很大(因为所有在该像素上的物体都要进入 fragment shader 进行绘制)，而且常常会引发各种非常棘手的问题。**</p><p>** 在写 Unity Shader 的时候，Alpha Blend 有两个非常重要的语句：Zwrite Off 和 Blend 的方式。**</p><p>** 一般情况下我们渲染半透明物体的时候，都是 Zwrite Off。**</p><p>** 为什么一定是 Zwrite Off？我们最开始说，只有打开 Zwrite，才有可能进行 “正确有效” 的 Ztest，否则所有关闭 Zwrite 的物体，其渲染将完全依赖于 RenderQueue。**</p><p>** 但是对于透明物体之间来说 (注意是透明物体之间，而不是透明和非透明物体之间)，我们需要的恰恰是不要进行有效的 Ztest——因为我们的初衷就是不能让“正确” 的遮挡关系产生作用。试想如果透明物体之间因为 Ztest 判定了 “正确” 的遮挡关系，而造成部分像素被显卡丢弃不画，又怎么可能产生之后混合的过程呢？**</p><p>** 而一旦放弃 Zwrite。透明物体之间的 Ztest 其实都是统统通过的，换言之任何一个半透明物体的像素在与其他半透明物体的像素进行 Ztest 的时候，将不会被认为是需要弃掉不画的像素(我再次强调，因为 RenderQueue 的关系，所有谈到的东西都仅限于半透明物体之间)。**</p><p><img src="https://pic4.zhimg.com/v2-2ffeff5b8aafb68d5e18c4896df5505b_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-2ffeff5b8aafb68d5e18c4896df5505b_720w.jpg"></p><p><img src="https://pic2.zhimg.com/v2-95d494fdc777d4f6de2d925d69a755ed_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-95d494fdc777d4f6de2d925d69a755ed_720w.jpg"></p><p><em>来看这张图，注意粒子后面的角色和墙不一样，这个角色与粒子相同也是个半透明的物体。当 Zwrite On 的时候，整个渲染过程是先画了方块形的粒子(Draw Dynamic)，再画的绿色的角色(那三个 Draw Mesh)。当开始绘制角色的时候显卡做了 Ztest，其判定这个角色被粒子遮挡住，所以像素并没有画出来。</em></p><p><img src="https://pic2.zhimg.com/v2-cc292be9f408d0df9f7884f365627891_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-cc292be9f408d0df9f7884f365627891_720w.jpg"></p><p><em>当 Zwrite Off 以后，注意这个时候依然是先画出粒子再画出角色，在角色做 Ztest 的时候，被判定并没有被粒子遮挡(因为粒子的深度信息并没有写入，角色像素的 Z 值小于等于当前摄像机在当前像素上的 Z 值)，所以角色的像素被绘制出来，并且与粒子的颜色进行了正常的混合。</em></p><p>** 你可能会问为什么墙不会被挡住，因为墙是 “Queue” = “Geometry”，作为一个渲染序列靠前的物体，在画粒子的时候其像素就已经存在了。**</p><p>** 根据上面的实例，我总结一下关于显卡的工作机制。显卡只能确定当下的像素是否可以绘制以及如何绘制。其结果可能是 1、弃掉这个像素不画。2、这个像素会覆盖掉之前的像素。3、如果是 Alpha Blend 就和之前的像素进行混合。但是注意无论如何渲染的过程都不可能影响之前的已经被画出来的像素——显卡也许会抛弃当前的像素不画，但是绝不可能让之前画出来的像素消失掉。这个规则非常重要，请务必理解。**</p><p>** 所以说对于 Alpha Blend 来说，RenderQueue 非常的重要。已经画出来的像素只能被混合却不能被消除。所以基本上出问题的一定是透明物体和透明物体之间，因为他们的 RenderQueue 是相同的。先渲染的永远存在，而后渲染的却有可能被抛弃。**</p><p>** 当然 ZTest Off 也许会解决这种因为遮挡而造成的不画像素的问题，但是相信我你绝对不会这么去做，因为会引发更多的麻烦(因为没了 Ztest，就是非透明物体也不能正确覆盖住透明物体了)。**</p><p>** 因为存在着如此 “危险” 的规则(之后的渲染不能改变之前的渲染)，渲染的先后顺序就绝对不可能是完全随机的。和非透明物体的渲染顺序控制类似，Unity 也提供了控制透明物体排序的机制。**</p><p><img src="https://pic2.zhimg.com/v2-4310e278900d4ad04627c59a6702e6ed_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-4310e278900d4ad04627c59a6702e6ed_720w.jpg"></p><p>** 因为透明物体之间的排序比较重要，所以我稍微多说两句。按照 Unity3D 的默认做法，在对透明物体在渲染之前的排序，是根据多边形中心点与摄像机的远近来比较的。比较之后显卡会从后向前对透明物体依次进行渲染。所以绝大多数情况下你看到的粒子特效，其前后遮挡关系还是没什么大问题的。**</p><p>** 但是这么做又会引出一个新的问题——当半透明物体交叉在一起的时候，这种判断方式几乎没有任何帮助。所以当一个复杂的多边形 (例如有很多部件的角色) 在使用 Alpha Blend 的时候，经常会出现显示效果错误，也是因为这种原因。**</p><p>** 所以从优化的角度来讲，我们一直希望尽量少用或者不用 Alpha Blend，但是现在的游戏几乎到处都充斥着 Alpha Blend 的物体。好在现在的处理器性能比之过去实在是强了太多，这些问题似乎也渐渐地不再成为游戏开发的限制。**</p><p>** 那么之所以我还要特意写出来，是希望大家能知道关于 Alpha Blend 消耗的来龙去脉。毕竟无论处理器的性能如何发展，我们做游戏还是要以能省一点儿是一点儿的态度去抠这些细节。**</p><p>** 单以上面的例子而言，如果你对之前的讲解理解深入的话，应该知道除了关闭 Zwrite 这一个办法之外，也可以用指定 RenderQueue 的方式强行让角色先绘制出来(或者让粒子后绘制)。这种强行改变(指定)RenderQueue 也能解决两个半透明物体遮挡的问题。但是正如我之前所说的，强行指定 RenderQueue 是一种极其不被推荐的做法。还是那句话，如果这个时候镜头转动了 180°（即物体和物体之间的前后关系完全反转），强行指定 RenderQueue 就会造成更严重的渲染错误。**</p><p><img src="https://pic2.zhimg.com/v2-0b0f92ef50e8d0154b52dfda1b563a91_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-0b0f92ef50e8d0154b52dfda1b563a91_720w.jpg"></p><p><img src="https://pic3.zhimg.com/v2-e50a7f4c4915ad18f79dbdd55ee91f8e_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-e50a7f4c4915ad18f79dbdd55ee91f8e_720w.jpg"></p><p><em>如上图，在没有关闭 Zwrite 的前提下， 改变粒子的渲染顺序(“Queue” = “Transparent+1” )。这样绿色的半透明角色就在粒子之前被渲染出来，红色的粒子也就有了可以进行混合的对象。</em></p><p><strong>Zwrite Off 虽然已经成为 Alpha Blend 的“标配”，但是不能进行 Zwrite 其实是很麻烦的。如果你认为上一个效果没毛病就万事大吉，那可就大错特错了。来看下图：</strong></p><p><img src="https://pic3.zhimg.com/v2-a73c096f34f70f4f83daede1f3c21736_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-a73c096f34f70f4f83daede1f3c21736_720w.jpg"></p><p><img src="https://pic4.zhimg.com/v2-bc7e9b1186b0f3a5cde5b882c302da6f_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-bc7e9b1186b0f3a5cde5b882c302da6f_720w.jpg"></p><p><em>大多数时候我们当然希望第一张图的效果（打开 Zwrite，遮挡住原本应该被遮挡的壶把）而非第二张图的效果(关闭 Zwirte，这样该物体的任何一个像素都不会改变摄像机在该像素上的深度，就会出现无法遮挡住问题)。</em></p><p><em>很显然，在不打开 Zwrite 的前提下，是不可能做出第一张图的效果的。但是正如我们之前所提到的，透明物体如果不是 Zwrite Off，又会引发半透明物体之间因为遮挡而无法混合的问题。这真是一个让人头疼的麻烦。</em></p><p>** 以下是官方一个例子的原理(实在搜不到了只好自己动手，惨)，是目前解决半透明问题比较常规的做法。首先做一个 pass 进行 Zwrite，然后在第二个 pass 里关闭 Zwrite，其他不变。可以做出一个完全是剪影的半透明效果。如下图右面的茶壶。**</p><p><img src="https://pic4.zhimg.com/v2-20dd33a5980c074beee9c9d730b9077f_b.jpg"></p><p><img src="https://pic4.zhimg.com/80/v2-20dd33a5980c074beee9c9d730b9077f_720w.jpg"></p><p><img src="https://pic1.zhimg.com/v2-9a3d0afd41d07edc84349e237376eec8_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-9a3d0afd41d07edc84349e237376eec8_720w.jpg"></p><p><strong>ColorMask 是指定输出通道，这里让第一个 pass 完全不输出任何东西，仅仅只是写入深度。这样一来茶壶就像是个非透明物体一样在屏幕上改变了当前像素的深度值。第二个 pass 正常绘制，在其 Ztest 的时候比较的就是刚刚自己留在屏幕上的 Z 值。这样一个完美的剪影就做出来了。</strong></p><p>** 这里说点题外话。一直以来我都以为把 Tag 放到 Pass 里是可行的，直到写本文的时候我才发现只有将 Tag 放在 Pass 外面才会真正起作用。那就意味着多 pass 之间来回切换 Tag 是不可能的(或许是我理解上有问题，毕竟我刚刚才发现)。**</p><p><img src="https://pic1.zhimg.com/v2-e19f9840fa0984f39af3145b1e73f060_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-e19f9840fa0984f39af3145b1e73f060_720w.jpg"></p><p>** 最后要说的是混合方式。如果你用 PhotoShop 的话，应该对图层混合的模式并不陌生，而 Blend 方式其实也是一样的概念。所以关于 Blend 的方式，我就不过多展开了，相关资料网上很多有兴趣可以自行百度。**</p><p>** 一般来说正常的 Blend 方式是：**</p><p><strong>Blend SrcAlpha OneMinusSrcAlpha</strong></p><p>** 这个语法翻译成中文，大意是这个像素的颜色乘以这个像素的 alpha 值(SrcAlpha) + 这个像素背后的颜色 * (1 - 这个像素的 alpha 值)（OneMinusSrcAlpha）。**</p><p>** 比如一个红色的像素(1,0,0,0.7)，期身后的颜色是蓝色(0,0,1,1)。那么在摄像机里，这个像素最终的颜色就应该是(0.7,0,0.3,0.7)（(1,0,0) * 0.7 + (0,0,1）* （1 - 0.7））。如果再出现一个半透明的物体，那就继续用这个步骤计算。**</p><p>** 这是 “正常” 的方式，得到的效果是我们习惯的 “默认” 的效果。那么非 “正常” 的效果呢？半透的混合方式还有如下几种。作为比较特殊的混合方式，所有这些方式你都可以在 PS 的图层混合里找到相同的效果。**</p><p><img src="https://pic3.zhimg.com/v2-6c920eb81f2d9e64731db6f15ff0c94e_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-6c920eb81f2d9e64731db6f15ff0c94e_720w.jpg"></p><hr><blockquote><p>参考来源： <a href="https://zhuanlan.zhihu.com/p/28557283">https://zhuanlan.zhihu.com/p/28557283</a></p></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/categories/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/categories/GameEngine/Unity/"/>
    
    <category term="Shader" scheme="https://tamsiree.com/categories/GameEngine/Unity/Shader/"/>
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/tags/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/tags/Unity/"/>
    
    <category term="Shader" scheme="https://tamsiree.com/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity 的 Application 路径</title>
    <link href="https://tamsiree.com/GameEngine/Unity/Unity%E7%9A%84Application%E8%B7%AF%E5%BE%84/"/>
    <id>https://tamsiree.com/GameEngine/Unity/Unity%E7%9A%84Application%E8%B7%AF%E5%BE%84/</id>
    <published>2021-07-22T00:50:46.000Z</published>
    <updated>2025-11-05T13:53:39.384Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>发现 **Application.temporaryCachePath 和 Application.persistentDataPath 返回空字符串 **。便花时间认真研究了一下 Unity3D 的路径问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们常用的是以下四个路径：</p><p>Application.dataPath<br>Application.streamingAssetsPath<br>Application.persistentDataPath<br>Application.temporaryCachePath  </p><p>根据测试，详细情况如下：</p><hr><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS:"></a>iOS:</h1><p>Application.dataPath            /var/containers/Bundle/Application/app sandbox/xxx.app/Data<br>Application.streamingAssetsPath /var/containers/Bundle/Application/app sandbox/test.app/Data/Raw<br>Application.temporaryCachePath /var/mobile/Containers/Data/Application/app sandbox/Library/Caches<br>Application.persistentDataPath  /var/mobile/Containers/Data/Application/app sandbox/Documents</p><p>iOS 和 Mac OS X 不同于 Windows，app 都是在一个沙盒空间中运行，每个 app 也有一个独立的数据存储空间，各 app 彼此不能互相访问、打扰。</p><p>dataPath 是 app 程序包安装路径，app 本身就在这里，此目录是只读的。streamingAssetsPath 是 dataPath 下的 Raw 目录。</p><p>app 的独立数据存储目录下有三个文件夹：Documents，Library 和 tmp。<br><strong>Documents</strong> 目录，这个目录用于存储需要长期保存的数据，比如我们的热更新内容就写在这里。需要注意的是，iCloud 会自动备份此目录，如果此目录下写入的内容较多，审核的可能会被苹果拒掉。</p><p><strong>Library</strong> 目录，这个目录下有两个子目录，Caches 和 Preferences。<br>    <strong>Caches</strong> 是一个相对临时的目录，适合存放下载缓存的临时文件，空间不足时可能会被系统清除，Application.temporaryCachePath 返回的就是此路径。我把热更新的临时文件写在这里，等一个版本的所有内容更新完全后，再把内容转移到 Documents 目录。<br>    <strong>Preferences</strong> 用于应用存储偏好设置，用 NSUserDefaults 读取或设置。</p><p><strong>tmp</strong> 目录，临时目录，存放应用运行时临时使用的数据。<br>需要注意的是，以上无论临时、缓存或者普通目录，如果不需要的数据，都请删除。不要占用用户的存储空间，像微信就是坏榜样。</p><p>下面是各路径对应的 OC 访问方法<br>app 安装路径: [[NSBundle mainBundle] resourcePath]<br>app 数据沙盒存储根目录: NSHomeDirectory()<br>Documents: NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)<br>Library:     NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)<br>Caches:     NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)<br>tmp:        NSTemporaryDirectory()</p><hr><h1 id="Android"><a href="#Android" class="headerlink" title="Android:"></a>Android:</h1><p>Application.dataPath            /data/app/package name-1/base.apk<br>Application.streamingAssetsPath jar:file:///data/app/package name-1/base.apk!/assets<br>Application.temporaryCachePath /storage/emulated/0/Android/data/package name/cache<br>Application.persistentDataPath   /storage/emulated/0/Android/data/package name/files</p><p>看 Android 上的路径，跟 iOS 有点类似，简单说一下。Android 的几个目录是 apk 程序包、内存存储 (InternalStorage) 和外部存储 (ExternalStorage) 目录。</p><p>**apk 程序包 ** 目录: apk 的安装路径，/data/app/package name-n/base.apk，dataPath 就是返回此目录。</p><p>** 内部存储 ** 目录: /data/data/package name-n/，用户自己或其它 app 都不能访问该目录。打开会发现里面有 4 个目录（需要 root）<br>    cache 缓存目录，类似于 iOS 的 Cache 目录<br>    databases 数据库文件目录<br>    files 类似于 iOS 的 Documents 目录<br>    shared_prefs 类似于 iOS 的 Preferences 目录，用于存放常用设置，比如 Unity3D 的 PlayerPrefs 就存放于此</p><p>** 外部存储 ** 目录: 在内置或外插的 sd 上，用户或其它 app 都可以访问，外部存储目录又分私有和公有目录。<br>    ** 公有目录 ** 是像 DCIM、Music、Movies、Download 这样系统创建的公共目录，当然你也可以像微信那样直接在 sd 卡根目录创建一个文件夹。好处嘛，就是卸载 app 数据依旧存在。</p><p>    ** 私有目录 ** 在 / storage/emulated/n/Android/data/package name/，打开可以看到里面有两个文件夹 cache 和 files。为什么跟内部存储目录重复了？这是为了更大的存储空间，以防内存存储空间较小。推荐把不需要隐私的、较大的数据存在这里，而需要隐私的或较小的数据存在内部存储空间。</p><p>下面是各路径对应的 Java 访问方法：<br>apk 包内: AssetManager.open(String filename)<br>内部存储: context.getFilesDir().getPath() or context.getCacheDir().getPath()<br>外部存储: context.getExternalFilesDir(null).getPath() or context.getExternalCacheDir().getPath()</p><p>理解了 Android 存储的原理，最后来说说开头提到的 bug，Application.temporaryCachePath/persistentDataPath 返回空字符串。这其实因为权限的原因，app 没有声明 ** 访问外部存储空间的权限 **，但是 Application.temporaryCachePath/ ApplicationpersistentDataPath 却想返回外部存储的路径。这是 Unity3D 的 bug，没有权限本应该抛出一个异常或者错误，让开发者知道原因。</p><p>经反复测试发现，有【外置 SD 卡】的设备上，如果声明读 / 写外部存储设备的权限，会返回外部存储路径，不声明则会返回内部存储路径，这样不会有问题。而在【无外置 SD 卡】的设备上，不管是否声明读 / 写外部存储设备的权限，Application.temporaryCachePath/persistentDataPath 都返回外部存储路径，但是又没有权限，就可能会导致返回 null 了，之所以说可能是因为这个 bug 不是必现，如果出现了设备重启之后就好了，怀疑是 linux 设备 mount 问题。但是出了问题，我们不能跟用户说你重启一下手机就好了。</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</code></pre><hr><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows:"></a>Windows:</h1><p>Application.dataPath:            应用的 appname_Data/<br>Application.streamingAssetsPath: 应用的 appname_Data/StreamingAssets<br>Application.temporaryCachePath: C:\Users\username\AppData\Local\Temp\company name\product name<br>Application.persistentDataPath:   C:\Users\username\AppData\LocalLow\company name\product name</p><hr><h1 id="PlayerPrefs-路径-补充"><a href="#PlayerPrefs-路径-补充" class="headerlink" title="PlayerPrefs 路径(补充)"></a>PlayerPrefs 路径(补充)</h1><p>Android: /data/data/pkg-name/shared_prefs/pkg-name.v2.playerprefs.xml<br>iOS:/Library/Preferences/[bundle identifier].plist<br>Windows:HKEY_CURRENT_USER/Software/CompanyName/ProductName<br>Mac:~/Library/Preferences/com.CompanyName.ProductName.plist</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><blockquote><ol><li> <a href="https://developer.apple.com/icloud/documentation/data-storage/index.html">iOS Data Storage Guidelines</a></li><li> <a href="https://developer.android.com/guide/topics/data/data-storage.html">Android API: Storage Options</a></li><li> <a href="http://blog.csdn.net/u012702547/article/details/50269639">彻底理解 Android 中的内部存储与外部存储</a></li><li> <a href="https://docs.unity3d.com/2020.1/Documentation/ScriptReference/PlayerPrefs.html">Unity - Scripting API：PlayerPrefs</a></li><li> <a href="https://blog.csdn.net/ynnmnm/article/details/52253674">Unity3D 各平台 Application.xxxPath 的路径</a></li></ol></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/categories/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/categories/GameEngine/Unity/"/>
    
    
    <category term="GameEngine" scheme="https://tamsiree.com/tags/GameEngine/"/>
    
    <category term="Unity" scheme="https://tamsiree.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C# 单例模式</title>
    <link href="https://tamsiree.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/CSharp%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://tamsiree.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/CSharp%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-02T03:34:38.000Z</published>
    <updated>2025-11-05T13:53:39.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单例模式是软件工程学中最富盛名的设计模式之一。从本质上看，单例模式只允许被其自身实例化一次，且向外部提供了一个访问该实例的接口。通常来说，单例对象进行实例化时一般不带参数，因为如果不同的实例化请求传递的参数不同的话会导致问题的产生。(若多个请求都是传递的同样的参数的话，工厂模式更应该被考虑)</p><p>C# 中实现单例有很多种方法，本文将按顺序介绍非线程安全、完全懒汉式、线程安全和低 / 高性能集中版本。</p><p>在所有的实现版本中，都有以下几个共同点：</p><ul><li>唯一的、私有的且无参的构造函数，这样不允许外部类进行实例化；</li><li>类是密封的，尽管这不是强制的，但是严格来讲从上一点来看密封类能有助于 JIT 的优化；</li><li>一个静态变量应该指向类的唯一实例；</li><li>一个公共的静态变量用于获得这个类的唯一实例 (如果需要, 应该创建它）；</li></ul><p>需要注意的是，本文中所有的例子中都是用一个 public static Instance 的变量来访问单例类实例，要将其转换成公共函数是很容易的，但是这样并不会带来效率和线程安全上的提升。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Version-1-非线程安全"><a href="#Version-1-非线程安全" class="headerlink" title="Version 1 - 非线程安全"></a>Version 1 - 非线程安全</h2><pre><code>public sealed class Singleton{    private static Singleton instance = null;    private Singleton() { }    public static Singleton Instance    {        get        {            if (instance == null)            {                instance = new Singleton();            }            return instance;        }    }}</code></pre><p>该版本在多线程下是不安全的，会创建多个实例，请不要在生产环境中使用！</p><p>因为如果两个线程同时运行到 if(instance==null) 判断时，就会创建两个实例，这是违背单例模式的初衷的。实际上在后面那个线程进行判断是已经生成了一个实例，但是对于不同的线程来说除非进行了线程间的通信，否则它是不知道的。</p><h2 id="Version-2-简单的线程安全"><a href="#Version-2-简单的线程安全" class="headerlink" title="Version 2 - 简单的线程安全"></a>Version 2 - 简单的线程安全</h2><pre><code>public sealed class Singleton2{    private static Singleton2 instance = null;    private static readonly object obj = new object();    private Singleton2() { }    public Singleton2 Instance    {        get        {            lock (obj)            {                if (instance == null)                {                    instance = new Singleton2();                }                return instance;            }        }    }}</code></pre><p>该版本是线程安全的。通过对一个过线程共享的对象进行加锁操作，保证了在同一时刻只有一个线程在执行 lock{} 里的代码。当第一个线程在进行 instance 判断或创建时，后续线程必须等待直到前一线程执行完毕，因此保证了只有第一个线程能够创建 instance 实例。</p><p>但不幸的是，因为每次对 instance 的请求都会进行 lock 操作，其性能是不佳的。</p><p>需要注意的是，这里使用了一个 private static object 变量进行锁定，这是因为当如果对一个外部类可以访问的对象进行锁定时会导致性能低下甚至死锁。因此通常来说为了保证线程安全，进行加锁的对象应该是 private 的。</p><h2 id="Version-3-Double-check-locking-的线程安全"><a href="#Version-3-Double-check-locking-的线程安全" class="headerlink" title="Version 3 - Double-check locking 的线程安全"></a>Version 3 - Double-check locking 的线程安全</h2><pre><code>public sealed class Singleton3{    private static Singleton3 instance = null;    private static object obj = new object();    private Singleton3() { }    public static Singleton3 Instance    {        get        {            if (instance == null)            {                lock (obj)                {                    if (instance == null)                    {                        instance = new Singleton3();                    }                }            }            return instance;        }    }}</code></pre><p>该版本中试图去避免每次访问都进行加锁操作并实现线程安全。然后，这段代码对 Java 不起作用，因 Java 的内存模型不能保证在构造函数一定在其他对象引用 instance 之前完成。还有重要的一点，它不如后面的实现方式。</p><h2 id="Version-4-不完全懒汉式，但不加锁的线程安全"><a href="#Version-4-不完全懒汉式，但不加锁的线程安全" class="headerlink" title="Version 4 - 不完全懒汉式，但不加锁的线程安全"></a>Version 4 - 不完全懒汉式，但不加锁的线程安全</h2><pre><code>public sealed class Singleton4{    private static readonly Singleton4 instance = new Singleton4();    /// &lt;summary&gt;    /// 显式的静态构造函数用来告诉 C# 编译器在其内容实例化之前不要标记其类型    /// &lt;/summary&gt;    static Singleton4() { }    private Singleton4() { }    public static Singleton4 Instance { get { return instance; } }}</code></pre><p>这个版本是的实现非常的简单，但是却又是线程安全的。C# 的静态构造函数只有在当其类的实例被创建或者有静态成员被引用时执行，在整个应用程序域中只会被执行一次。使用当前方式明显比前面版本中进行额外的判断要快。</p><p>当然这个版本也存在一些瑕疵：</p><ul><li>不是真正意义上的懒汉模式 (需要的时候才创建实例)，若单例类还存在其他静态成员，当其他类第一次引用这些成员时便会创建该 instance。下个版本实现会修正这个问题；</li><li>只有. NET 中才具有 beforefieldinit 特性，即懒汉式实现。且在. Net 1.1 以前的编译器不支持，不过这个现在来看问题不大；</li></ul><p>所有版本中，只有这里将 instance 设置成了 readonly, 这不仅保证了代码的高校且显得十分短小。</p><h2 id="Version-5-完全懒汉实例化"><a href="#Version-5-完全懒汉实例化" class="headerlink" title="Version 5 - 完全懒汉实例化"></a>Version 5 - 完全懒汉实例化</h2><pre><code>public sealed class Singleton5{    private Singleton5() { }    public static Singleton5 Instance { get { return Nested.instance; } }    private class Nested    {        static Nested() { }        internal static readonly Singleton5 instance = new Singleton5();    }}</code></pre><p>该版本看起来稍微复杂难懂，其实只是在写法上实现了上一版本的瑕疵，通过内嵌类的方式先实现了只有在真正应用 Instance 时才进行实例化。其性能表现与上一版本无异。</p><h2 id="Version-6-使用-NET-4-Lazy-type-特性"><a href="#Version-6-使用-NET-4-Lazy-type-特性" class="headerlink" title="Version 6 - 使用. NET 4 Lazy type 特性"></a>Version 6 - 使用. NET 4 Lazy type 特性</h2><pre><code>public sealed class Singleton6{    private static readonly Lazy&lt;Singleton6&gt; lazy =           new Lazy&lt;Singleton6&gt;(()=&gt; new Singleton6());    public static Singleton6 Instance { get { return lazy.Value; } }    private Singleton6() { }}</code></pre><p>如果你使用的是. NET 4 或其以上版本，可以使用 System.Lazy type 来实现完全懒汉式。其代码看起来也很简洁且性能表现也很好。</p><h2 id="性能-VS-懒汉式"><a href="#性能-VS-懒汉式" class="headerlink" title="性能 VS 懒汉式"></a>性能 VS 懒汉式</h2><p>一般情况下，我们并不需要实现完全懒汉式，除非你的构造初始化执行了某些费时的工作。因此一般的，我们使用显式的静态构造函数就能够适用。</p><p>本文翻译自 Implementing the Singleton Pattern in C#</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>有时候在进行构造函数初始化时可能 会抛出异常，但这对整个应用程序来说不应该是致命的，所以可能的情况下，你应该自己处理这种异常情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述提供的几种实现方法中，一般情况下提倡使用 <code>Version 4</code>，除非遇到有时早于单列类实例化时就引用了其他静态成员。这种情况下，<code>Version 2</code> 一旦被考虑，虽然它看起来会因加锁耗时，但是其实运行起来并没有你想的那么慢，关键是你很容易写对它。显然 <code>Version 1</code> 你永远都不应该考虑，<code>Version 3</code> 在与 <code>Version 5</code> 的对比下也是不在考虑范围之内的。</p><hr><blockquote><p>参考来源：<a href="https://www.cnblogs.com/zhaoshujie/p/14323654.html">[ C# 实现单例模式的 6 种方法 ]</a></p></blockquote><hr><blockquote><p>to be continued…</p></blockquote>]]></content>
    
    
    <summary type="html">单例模式是软件工程学中最富盛名的设计模式之一。从本质上看，单例模式只允许被其自身实例化一次，且向外部提供了一个访问该实例的接口。通常来说，单例对象进行实例化时一般不带参数，因为如果不同的实例化请求传递的参数不同的话会导致问题的产生。(若多个请求都是传递的同样的参数的话，工厂模式更应该被考虑)</summary>
    
    
    
    <category term="编程语言" scheme="https://tamsiree.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C#" scheme="https://tamsiree.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="编程语言" scheme="https://tamsiree.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C#" scheme="https://tamsiree.com/tags/C/"/>
    
  </entry>
  
</feed>
