---
title: 数据结构
date: 2020-01-02 15:09:04
description: 数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的 `逻辑结构` 和数据的 `物理结构` 以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。
tags:
  - Research
  - 数据结构
categories:
  - Research
  - 数据结构
mathjax: true
cover: https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg05e3c1f.jpg
---
# 定义
数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的 `逻辑结构` 和数据的 `物理结构` 以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。  
简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为 `逻辑结构` 和 `存储结构` 。

数据的 `逻辑结构` 和 `物理结构` 是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的 `逻辑结构` ，而算法的实现依赖于指定的 `存储结构` 。

数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是 `分解` 与 `抽象` 。通过 `分解` 可以划分出数据的3个层次；再通过 `抽象` ，舍弃数据元素的具体内容，就得到 `逻辑结构` 。类似地，通过 `分解` 将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为 `数据结构` 。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到 `存储结构` 和 `实现运算` ，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。

---

# 生活中的例子
## 例子1： 如何在书架上摆放图书？

`关于数据组织`

方法1：随便放  
操作1：新书怎么插入？  
哪里有空放哪里，一步到位。
操作2：怎么找到某本指定的书？  
......累死

方法2：按照书名的拼音字母顺序排放
操作1：新书怎么插入？  
新买进一本《阿Q正传》  
操作2：怎么找到某本指定的书？  
二分查找！

方法3：把书架划分成几块区域，每块区域指定摆放某种类别的图书；在每种类别内，按照书名的拼音字母顺序排放  
操作1：新书怎么插入？  
先定类别，二分查找确定位置，移出空位  
操作2：怎么找到某本指定的书？  
先定类别，再二分查找  
问题：空间如何分配？类别应该分多细？

> 解决问题方法的效率，跟数据的组织方式有关

## 例子2：写程序实现一个函数PrintN，使得传入一个正整数为N的参数后，能顺序打印1到N的全部正整数

`关于空间使用`

代码块1：使用for循环实现

```c
void PrintN(int N)
{
  int i;
  for(i = 1;i<=N;i++){
    printf("%d\n",i);
  }
  return;
}
```

代码块2：使用递归实现

```c
void PrintN(int N){
  if(N){
    PrintN(N-1);
    printf("%d\n",N);
  }
  return;
}
```

> 解决问题方法的效率，跟空间的利用效率有关

## 例子3：写程序计算给定多像是在给定点x处的值

$f(x)=a_0+a_1x+\cdots + a_{n-1}x^{n-1}+a_nx^n.$

代码块:

```c
double f(int n,double a[],double x)
{
  int i;
  double p = a[0];
  for(i =1; i<=n;i++)
    p+=(a[i]*pow(x,i));
  return p;
}
```

使用秦九韶算法改良：  
每一次把公因子提出来  
$f(x)=a_0+x(a_1+x(\cdots(a_{n-1}+x(a_n))\cdots))$

```c
double f(int n,double a[],double x)
{
  int i;
  double p = a[n];
  for(i=n;i>0;i--)
    p=a[i-1]+x*p;
  return p;
}
```

clock(): 捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”。  
常数CLK_TCK：机器时钟每秒所走的时钟打点数。

```c
#include <stdio.h>
#include <time.h>

/* clock_t是clock()函数返回的变量类型 */
clock_t start,stop;
/* 记录被测函数运行时间，以秒为单位 */
double duration;
/* 不在测试范围内的准备工作写在clock()调用之前 */
int main()
{
  /* 开始计时 */
  start = clock();
  /* 把被测函数加在这里 */
  MyFunction();
  /* 停止计时 */
  stop = clock();
  duration = ((double)(stop-start))/CLK_TCK;

  /* 其他不在测试范围的处理写在后面，例如输出duration的值 */
  return 0;
}
```

例子4： 写程序计算给定多项式$f(x)=\sum_{i=0}^9 i\bullet x^i$ 在给定点$x=1.1$处的值$f(1.1)$

代码块1：

```c
double f1(int n,double a[],double x)
{
  int i;
  double p = a[0];
  for(i=1;i<=n;i++)
    p += (a[i] * pow(x,i));
  return p;
}
```

代码块2：

```c
double f2(int n,double a[],double x)
{
  int i;
  double p = a[n];
  for(i=n;i>0;i--)
    p=a[i-1]+x*p;
  return p;
}
```

实测代码：

```c
#include <stdio.h>
#include <time.h>
#include <math.h>
clock_t start,stop;
double duration;
/* 多项式最大项数，即多项式阶数+1 */
#define MAXN 10

/* 被测函数最大重复调用次数 */
#define MAXK 1e7

double f1(int n,double a[],double x)
{
  int i;
  double p = a[0];
  for(i=1;i<=n;i++)
    p += (a[i] * pow(x,i));
  return p;
}

double f2(int n,double a[],double x)
{
  int i;
  double p = a[n];
  for(i=n;i>0;i--)
    p=a[i-1]+x*p;
  return p;
}

int main()
{
  int i;
  /* 存储多项式的系数 */
  double a[MAXN];
  for(i = 0;i < MAXN;i++)
    a[i] = (double) i;

  start = clock();
  /* 重复调用函数以获得充分多的时钟打点数 */
  for(i = 0;i< MAXK;i++)
    f1(MAXN-1,a,1.1);
  stop = clock();
  /* 计算函数单次运行的时间 */
  duration = ((double)(stop - start))/CLK_TCK/MAXK;
  printf("ticks1=%f\n",(double)(stop - start));
  printf("duration1=%6.2e\n",duration);

  start = clock();
  for(i = 0;i< MAXK;i++)
    f2(MAXN-1,a,1.1);
  stop = clock();
  duration = ((double)(stop - start))/CLK_TCK/MAXK;
  printf("ticks1=%f\n",(double)(stop - start));
  printf("duration1=%6.2e\n",duration);

  return 0;
}
```

如果测试出来的结果都是 `0`，可能是程序运行得太快，clock相隔时间太短。  
可以让被测函数`重复运行`充分多次，使得测出的总的时钟打点间隔充分长，最后计算被测函数`平均每次`运行的时间即可。

> 解决问题方法的效率，跟算法的巧妙程度有关

---

# 什么是数据结构

数据对象在计算机中的组织方式
- 逻辑结构
- 物理存储结构

数据对象与算法
- 数据对象必定与一系列加在其上的操作相关联  
- 完成这些操作所用的方法就是算法

---

# 抽象数据类型(Abstract Data Type)  
数据类型
- 数据对象集
- 数据集合相关联的操作集

抽象：描述数据类型的方法不依赖于具体实现
- 与存放数据的机器无关
- 与数据存储的物理结构无关
- 与实现操作的算法和编程语言均无关

只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题

## 例子5：“矩阵”的抽象数据类型定义
类型名称：矩阵(Matrix)  
数据对象集：一个M × N的矩阵$A_{M×N}=(a_{ij})(i=1,\cdots,M;j=1,\cdots,N)$由M × N 个三元组<a,i,j>构成，其中a是矩阵元素的值，i是元素所在的行号，j是元素所在的列号。

操作集：对于任意矩阵$A、B、C\in Matrix,$以及整数$i、j、M、N$
- Matrix Create(int M,int N): 返回一个M × N 的空矩阵；
- int GetMaxRow(Matrix A): 返回矩阵A的总行数；
- int GetMaxCol(Matrix A): 返回矩阵A的总列数；
- ElementType GetEntry(Matrix A,int i,int j): 返回矩阵A的第i行、第j列的元素；
- Matrix Add(Matrix A,Matrix B): 如果A和B的行、列数一致，则返回矩阵C=A+B,否则返回错误标志；
- Matrix Multiply(Matrix A,Matrix B): 如果A的列数等于B的行数，则返回矩阵C=AB，否则返回错误标志；
- ......

---

# 算法(Algorithm)
- 一个有限指令集
- 接受一些输入(有些情况下不需要输入)
- 产生输出
- 一定在有限步骤之后终止
- 每一条指令必须
  - 有充分明确的目标，不可以有歧义
  - 计算机能处理的范围之内
  - 描述应不依赖于任何一种计算机语言以及具体的实现手段

例子1：选择排序算法的伪码描述

```c
void SelectionSort(int List[] , int N)
{
  /* 将N个整数List[0] ...List[N-1]进行非递减排序 */
  for(i = 0;i< N;i++){
    /* 从List[i]到List[N-1]中找到最小元，并将起位置赋给MinPosition */
    MinPosition = ScanForMin(List,i,N-1);

    /* 将未排序部分的最小元换到有序部分的最后位置 */
    Swap(List[i],List[MinPosition]);

  }
}
```

## 什么是好的算法？
空间复杂度S(n)——根据算法写成的程序在执行时`占用存储单元的长度`。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。

时间复杂度T(n)——根据算法写成的程序在执行时`耗费时间的长度`。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行的结果。

> 计算机的加减运算比乘除运算快很多，所有尽量使用加减法，少用乘除法

例子 1

```c
void PrintN(int N){
  if(N){
    PrintN(N-1);
    printf("%d\n",N);
  }
  return;
}
```

> 这是个递归算法，如果取 N=10000 时，将会与占用内存的数量成正比。

![](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204144843.png)

> 所以尽量少用递归，递归可能导致空间复杂度显著提高。  
> 空间复杂度 $S(N)=C\cdot N$

例子 2

```c
double f1(int n,double a[],double x)
{
  int i;
  double p = a[0];
  for(i=1;i<=n;i++)
    p += (a[i] * pow(x,i));
  return p;
}
```

> 上述算法中因为存在幂函数，幂函数的算法相当于幂的次方数，所以上述算法中转化之后存在 $(1+2+\cdots+n)=(n^2+n)/2$ 次乘法.  
> 时间复杂度 $T(n)=C_1n^2+C_2n$

```c
double f2(int n,double a[],double x)
{
  int i;
  double p = a[n];
  for(i=n;i>0;i--)
    p=a[i-1]+x*p;
  return p;
}
```

> 上述算法中只存在 n 次乘法.  
> 时间复杂度 $T(n)=C\cdot n$


- 在分析一般算法的效率时，我们经常关注下面两种复杂度
  - 最坏情况复杂度 $T_{worst}(n)$
  - 平均复杂度 $T_{avg}(n)$  
$$T_{avg}(n)\le T_{worst}(n)$$

### 复杂度的渐进表示法

- $T(n)=\Omicron(f(n))$ 表示存在常数 $C\gt 0,n_0\gt 0$ 使得当 $n\gt n_0$ 时有 $T(n)\le C \cdot f(n)$ ，即是 上界
- $T(n)=\Omega (f(n))$ 表示存在常数 $C\gt 0,n_0\gt 0$ 使得当 $n\gt n_0$ 时有 $T(n)\ge C \cdot g(n)$ ，即是 下界
- $T(n)=\Theta(h(n))$ 表示同时有 $T(n)=\Omicron(h(n))$ 和 $T(n)=\Omega (h(n))$ ，即是 既是上界也是下界

太大的上界和太小的下界对于分析算法问题没有太大的帮助。


![输入规模n有关的函数复杂度](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204153630.png)

![函数复杂度增长趋势图](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204153709.png)

![每秒10亿指令计算机的运行时间表](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204153957.png)

### 复杂度分析小窍门

- 若两段算法分别有复杂度 $T_1(n)=O(f_1(n))$ 和 $T_2(n)=O(f_2(n))$,则
  - $T_1(n)+T_2(n)=max(O(f_1(n)),O(f_2(n)))$
  - $T_1(n)$ × $T_2(n)=O(f_1(n)$ × $f_2(n))$
- 若 $T(n)$ 是关于 n 的 k 阶多项式，那么$T(n)=\Theta(n^k)$
- 一个`for`循环的时间复杂度等于循环次数乘以循环体代码的复杂度
- `if-else`结构的复杂度取决于`if`的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大

## 算法应用实例
### 最大子列和问题

例子 1:给定N个整数的序列{$A_1,A_2,\cdots,A_N$},求函数 $f(i,j)=max$ { ${0,\sum_{k=i}^jA_k}$ } 的最大值。

#### 算法1

```c
int MaxSubseqSum1(int A[],int N)
{
  int ThisSum,MaxSum = 0;
  int i,j,k;
  for(i = 0;i< N;i++)
  {/* i是子列左端位置 */
    for(j = i;j <  N;j++)
    {/* j是子列右端位置 */
      ThisSum=0;/* ThisSum是从A[i]到A[j]的子列和 */
      for(k=i;k<=j;k++)
      {
        ThisSum += A[k];
      }
      if(ThisSum > MaxSum)/* 如果刚得到的这个子列和更大 */
      {
        MaxSum = ThisSum;/* 则更新结果 */
      }
    }/* j循环结束 */
  }/* i循环结束 */
  return MaxSum;
}
```

> 算法1的时间复杂度为 $T(N)=O(N^3)$

#### 算法2

```c
int MaxSubseqSum2(int A[],int N)
{
  int ThisSum,MaxSum = 0;
  int i,j;
  for(i=0;i< N;i++)
  {/* i是子列左端位置 */
    ThisSum = 0;/* ThisSums是从A[i]到A[j]的子列和 */
    for(j = i;j< N;j++)
    {/* j是子列右端位置 */
      ThisSum += A[j];
      /* 对于相同的i,不同的j，只要在j-1次循环的基础上累加1项即可 */
      if(ThisSum>MaxSum)
      {/* 如果刚得到的这个子列和更大 */
        MaxSum = ThisSum;/* 则更新结果 */
      }
    }/* j循环结束 */
  }/* i循环结束 */
  return MaxSum;
}
```
> 算法2的时间复杂度为 $T(N)=O(N^2)$

#### 算法3：分而治之

![分而治之](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204165248.png)

#### 算法4： 在线处理

```c
int MaxSubseqSum4(int A[],int N)
{
  int ThisSum,MaxSum;
  int i;
  ThisSum = MaxSum = 0;
  for(i=0;i< N;i++)
  {
    ThisSum += A[i];/* 向右累加 */
    if(ThisSum > MaxSum)
    {
      MaxSum = ThisSum;/* 发现更大和则更新当前结果 */
    }else if(ThisSum < 0){/* 如果当前子列和为负 */
      ThisSum = 0;/* 则不可能使后面的部分和增大，则抛弃之 */
    }
  }
  return MaxSum;
}
```

> 算法4的时间复杂度为 $T(N)=O(N)$

> “`在线`”的意思是指每输入一个数据就进行`即时处理`，在任何一个地方中止输入，算法都能正确给出当前的解。

![运算时间比较(秒)](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204171312.png)


---

## 线性结构
### 线性表及其实现

多项式的表示

[例]一元多项式及其运算  
一元多项式：$f(x)=a_0+a_1x+\cdots+a_{n-1}x^{n-1}+a_nx^n$  
主要运算：多项式的相加、相减、相乘等

【分析】如何表示多项式？  
多项式的关键数据：  
- 多项式项数`n`
- 各项系数$a_i$及指数i

方法1：顺序存储结构直接表示  
数组各分量对应多项式各项：  
$a[i]$ : 项$x^i$的系数$a_i$ 

例如： $f(x)=4x^5-3x^2+1$

![多项式用数组表示](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204174040.png)

两个多项式相加： 两个数组对应分量相加  
问题： 如何表示多项式 $x+3x^{2000}$ ?

导致空间复杂度增大，浪费内存

方法2： 顺序存储结构表示非零项  
每个非零项 $a_ix^i$ 涉及两个信息：系数 $a_i$ 和指数 i  
可以将一个多项式看成是一个 $(a_i,i)$ 的二元组的集合。

用结构数组表示： 数组分量是由系数 $a^i$、指数i组成的结构，对应一个非零项。

例如： $P_1(x)=9x^P{12}+15x^8+3x^2$ 和 $P_2(x)=26x^19-4x^8-13x^6+82$

![顺序存储结构表示非零项](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204183319.png)

> 按照指数大小有序存储!

相加过程： 从头开始，比较两个多项式当前对应项的指数

P1:(9,12), (15,8), (3,2)

P2:(26,19), (-4,8), (-13,6), (82,0)

P3:(26,19), (9,12), (11,8), (-13,6), (82,0)

$P_3(x)=26x^{19}+9x^{12}+11x^8-13x^6+x^2+82$

方法3： 链表结构存储非零项  
链表中每个`结点`存储多项式中的一个`非零项`，包括`系数和指数`两个数据域以及一个`指针域`

```
typedef strut PolyNode *Polynomial;
struct PolyNode{
  int coef;
  int expon;
  Polynomial link;
}
```


---
> to be continued...
 