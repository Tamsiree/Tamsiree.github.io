---
title: 数据结构
date: 2020-01-02 15:09:04
description: 数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的 `逻辑结构` 和数据的 `物理结构` 以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。
tags:
  - Research
  - 数据结构
categories:
  - Research
  - 数据结构
cover: https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/bg05e3c1f.jpg
---
# 定义
数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的 `逻辑结构` 和数据的 `物理结构` 以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。  
简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为 `逻辑结构` 和 `存储结构` 。

数据的 `逻辑结构` 和 `物理结构` 是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的 `逻辑结构` ，而算法的实现依赖于指定的 `存储结构` 。

数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是 `分解` 与 `抽象` 。通过 `分解` 可以划分出数据的3个层次；再通过 `抽象` ，舍弃数据元素的具体内容，就得到 `逻辑结构` 。类似地，通过 `分解` 将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为 `数据结构` 。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到 `存储结构` 和 `实现运算` ，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。


# 生活中的例子
## 例子1： 如何在书架上摆放图书？

`关于数据组织`

方法1：随便放  
操作1：新书怎么插入？  
哪里有空放哪里，一步到位。
操作2：怎么找到某本指定的书？  
......累死

方法2：按照书名的拼音字母顺序排放
操作1：新书怎么插入？  
新买进一本《阿Q正传》  
操作2：怎么找到某本指定的书？  
二分查找！

方法3：把书架划分成几块区域，每块区域指定摆放某种类别的图书；在每种类别内，按照书名的拼音字母顺序排放  
操作1：新书怎么插入？  
先定类别，二分查找确定位置，移出空位  
操作2：怎么找到某本指定的书？  
先定类别，再二分查找  
问题：空间如何分配？类别应该分多细？

> 解决问题方法的效率，跟数据的组织方式有关

## 例子2：写程序实现一个函数PrintN，使得传入一个正整数为N的参数后，能顺序打印1到N的全部正整数

`关于空间使用`

代码块1：使用for循环实现

```c
void PrintN(int N)
{
  int i;
  for(i = 1;i<=N;i++){
    printf("%d\n",i);
  }
  return;
}
```

代码块2：使用递归实现

```c
void PrintN(int N){
  if(N){
    PrintN(N-1);
    printf("%d\n",N);
  }
  return;
}
```

> 解决问题方法的效率，跟空间的利用效率有关

## 例子3：写程序计算给定多像是在给定点x处的值

$f(x)=a_0+a_1x+\cdots + a_{n-1}x^{n-1}+a_nx^n.$

代码块:

```c
double f(int n,double a[],double x)
{
  int i;
  double p = a[0];
  for(i =1; i<=n;i++)
    p+=(a[i]*pow(x,i));
  return p;
}
```

使用秦九韶算法改良：  
每一次把公因子提出来  
$f(x)=a_0+x(a_1+x(\cdots(a_{n-1}+x(a_n))\cdots))$

```c
double f(int n,double a[],double x)
{
  int i;
  double p = a[n];
  for(i=n;i>0;i--)
    p=a[i-1]+x*p;
  return p;
}
```

clock(): 捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”。  
常数CLK_TCK：机器时钟每秒所走的时钟打点数。

```c
#include <stdio.h>
#include <time.h>

/* clock_t是clock()函数返回的变量类型 */
clock_t start,stop;
/* 记录被测函数运行时间，以秒为单位 */
double duration;
/* 不在测试范围内的准备工作写在clock()调用之前 */
int main()
{
  /* 开始计时 */
  start = clock();
  /* 把被测函数加在这里 */
  MyFunction();
  /* 停止计时 */
  stop = clock();
  duration = ((double)(stop-start))/CLK_TCK;

  /* 其他不在测试范围的处理写在后面，例如输出duration的值 */
  return 0;
}
```

例子4： 写程序计算给定多项式$f(x)=\sum_{i=0}^9 i\bullet x^i$ 在给定点$x=1.1$处的值$f(1.1)$

代码块1：

```c
double f1(int n,double a[],double x)
{
  int i;
  double p = a[0];
  for(i=1;i<=n;i++)
    p += (a[i] * pow(x,i));
  return p;
}
```

代码块2：

```c
double f2(int n,double a[],double x)
{
  int i;
  double p = a[n];
  for(i=n;i>0;i--)
    p=a[i-1]+x*p;
  return p;
}
```

实测代码：

```c
#include <stdio.h>
#include <time.h>
#include <math.h>
clock_t start,stop;
double duration;
/* 多项式最大项数，即多项式阶数+1 */
#define MAXN 10

/* 被测函数最大重复调用次数 */
#define MAXK 1e7

double f1(int n,double a[],double x)
{
  int i;
  double p = a[0];
  for(i=1;i<=n;i++)
    p += (a[i] * pow(x,i));
  return p;
}

double f2(int n,double a[],double x)
{
  int i;
  double p = a[n];
  for(i=n;i>0;i--)
    p=a[i-1]+x*p;
  return p;
}

int main()
{
  int i;
  /* 存储多项式的系数 */
  double a[MAXN];
  for(i = 0;i < MAXN;i++)
    a[i] = (double) i;

  start = clock();
  /* 重复调用函数以获得充分多的时钟打点数 */
  for(i = 0;i< MAXK;i++)
    f1(MAXN-1,a,1.1);
  stop = clock();
  /* 计算函数单次运行的时间 */
  duration = ((double)(stop - start))/CLK_TCK/MAXK;
  printf("ticks1=%f\n",(double)(stop - start));
  printf("duration1=%6.2e\n",duration);

  start = clock();
  for(i = 0;i< MAXK;i++)
    f2(MAXN-1,a,1.1);
  stop = clock();
  duration = ((double)(stop - start))/CLK_TCK/MAXK;
  printf("ticks1=%f\n",(double)(stop - start));
  printf("duration1=%6.2e\n",duration);

  return 0;
}
```

如果测试出来的结果都是 `0`，可能是程序运行得太快，clock相隔时间太短。  
可以让被测函数`重复运行`充分多次，使得测出的总的时钟打点间隔充分长，最后计算被测函数`平均每次`运行的时间即可。

> 解决问题方法的效率，跟算法的巧妙程度有关


# 什么是数据结构

数据对象在计算机中的组织方式
- 逻辑结构
- 物理存储结构

数据对象与算法
- 数据对象必定与一系列加在其上的操作相关联  
- 完成这些操作所用的方法就是算法

# 抽象数据类型(Abstract Data Type)  
数据类型
- 数据对象集
- 数据集合相关联的操作集

抽象：描述数据类型的方法不依赖于具体实现
- 与存放数据的机器无关
- 与数据存储的物理结构无关
- 与实现操作的算法和编程语言均无关

只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题

## 例子5：“矩阵”的抽象数据类型定义
类型名称：矩阵(Matrix)  
数据对象集：一个M × N的矩阵$A_{M×N}=(a_{ij})(i=1,\cdots,M;j=1,\cdots,N)$由M × N 个三元组<a,i,j>构成，其中a是矩阵元素的值，i是元素所在的行号，j是元素所在的列号。

操作集：对于任意矩阵$A、B、C\in Matrix,$以及整数$i、j、M、N$
- Matrix Create(int M,int N): 返回一个M × N 的空矩阵；
- int GetMaxRow(Matrix A): 返回矩阵A的总行数；
- int GetMaxCol(Matrix A): 返回矩阵A的总列数；
- ElementType GetEntry(Matrix A,int i,int j): 返回矩阵A的第i行、第j列的元素；
- Matrix Add(Matrix A,Matrix B): 如果A和B的行、列数一致，则返回矩阵C=A+B,否则返回错误标志；
- Matrix Multiply(Matrix A,Matrix B): 如果A的列数等于B的行数，则返回矩阵C=AB，否则返回错误标志；
- ......

# 算法(Algorithm)
- 一个有限指令集
- 接受一些输入(有些情况下不需要输入)
- 产生输出
- 一定在有限步骤之后终止
- 每一条指令必须
  - 有充分明确的目标，不可以有歧义
  - 计算机能处理的范围之内
  - 描述应不依赖于任何一种计算机语言以及具体的实现手段

例子1：选择排序算法的伪码描述

```c
void SelectionSort(int List[] , int N)
{
  /* 将N个整数List[0] ...List[N-1]进行非递减排序 */
  for(i = 0;i< N;i++){
    /* 从List[i]到List[N-1]中找到最小元，并将起位置赋给MinPosition */
    MinPosition = ScanForMin(List,i,N-1);

    /* 将未排序部分的最小元换到有序部分的最后位置 */
    Swap(List[i],List[MinPosition]);

  }
}
```

## 什么是好的算法？
空间复杂度S(n)——根据算法写成的程序在执行时`占用存储单元的长度`。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。

时间复杂度T(n)——根据算法写成的程序在执行时`耗费时间的长度`。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行的结果。

> 计算机的加减运算比乘除运算快很多，所有尽量使用加减法，少用乘除法

例子1

```c
void PrintN(int N){
  if(N){
    PrintN(N-1);
    printf("%d\n",N);
  }
  return;
}
```

这是个递归算法，如果取N=10000时，将会占用内存的数量

![](https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Post/20200204144843.png)

---
> to be continued...
