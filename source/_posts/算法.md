---
title: 算法
author: Tamsiree
date: 2020-06-03 19:26:10
description: 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。
tags:
  - Research
  - 算法
categories:
  - Research
  - 算法
cover: https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/wallhaveneolelw.jpg
---
# 前言
算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

# 正文
## 算法
### 冒泡排序
冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。  
它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。  
这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。  

#### 算法原理

冒泡排序算法的原理如下:

> 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。  
> 2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。  
> 3. 针对所有的元素重复以上的步骤，除了最后一个。  
> 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 

C#的冒泡排序

```csharp
    public static int[] BubbleSortMethod(int[] arrayInt)
    {
        for (int i = 0; i < arrayInt.Length - 1; i++)
        {
            for (int j = 0; j < arrayInt.Length - i - 1; j++)
            {
                if (arrayInt[j] > arrayInt[j + 1])
                {
                    int temp = arrayInt[j];
                    arrayInt[j] = arrayInt[j + 1];
                    arrayInt[j + 1] = temp;
                }
            }
        }
        return arrayInt;
    }
```

### 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

#### 算法原理

首先，假设表中元素是按 `升序排列` ，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

C#的二分查找

```csharp
    /**
    * 二分查找算法
    *
    * @param srcArray 有序数组
    * @param des 查找元素
    * @return des的数组下标，没找到返回-1
    */
    public static int BinarySearchMethod(int[] srcArray, int des)
    {
        int low = 0;
        int high = srcArray.Length - 1;
        while (low <= high)
        {
            int middle = (low + high) / 2;
            if (des == srcArray[middle])
            {
                return middle;
            }
            else if (des < srcArray[middle])
            {
                high = middle - 1;
            }
            else
            {
                low = middle + 1;
            }
        }
        return -1;
    }
```


### 最大公约数 (二进制算法)

#### 算法原理

二进制最大公约数算法避免了欧几里得算法（辗转相除法）的大量取模操作，有效减少了时间消耗，且更为方便。

本算法基于以下事实：

> 对于两个数的最大公约数 gcd(m, n)，有  
> m<n 时，gcd(m, n)=gcd(n, m)  
> m 偶 n 偶时，gcd(m, n)=2*gcd(m/2, n/2)  
> m 偶 n 奇时，gcd(m, n)=gcd(m/2, n)  
> m 奇 n 偶时，gcd(m, n)=gcd(m, n/2)  
> m 奇 n 奇时，gcd(m, n)=gcd(n, m-n)  

采用递归即可。


```csharp
//最大公约数
private int GCD(int x,int y)   
{
    int i,j;
    if(x==0) return y;
    if(y==0) return x;
    for(i=0;0==(x&1);++i)x>>=1;   // 去掉所有的2
    for(j=0;0==(y&1);++j)y>>=1;   // 去掉所有的2
    if(j<i) i=j;
    while(1){
            if(x<y)x^=y,y^=x,x^=y;   // 若 x < y 交换 x, y
            if(0==(x-=y)) return y<<i;  // 若x == y， gcd == x == y (就是在辗转减，while(1)控制)
            while(0==(x&1))x>>=1; // 去掉所有的2
    }
}
```

```csharp
//最小公倍数
private int get_lcm(int a,int b)///获得最小公倍数
{
    int x=a;
    int y=b;
    while(b)
    {
        int t=a;
        a=b;
        b=t%b;
    }
    return x/a*y;
}
```



---
> to be continued...
