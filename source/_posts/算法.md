---
title: 算法
author: Tamsiree
date: 2020-06-03 19:26:10
description: 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。
tags:
  - Research
  - 算法
categories:
  - Research
  - 算法
cover: https://cdn.jsdelivr.net/gh/Tamsiree/Assets@master/Picture/Blog/Cover/wallhaveneolelw.jpg
---
# 前言
算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

# 正文
## 算法
### 冒泡排序
冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。  
它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。  
这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。  

#### 算法原理

冒泡排序算法的原理如下:

> 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。  
> 2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。  
> 3. 针对所有的元素重复以上的步骤，除了最后一个。  
> 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 

C#的冒泡排序

```c#
    public static int[] BubbleSortMethod(int[] arrayInt)
    {
        for (int i = 0; i < arrayInt.Length - 1; i++)
        {
            for (int j = 0; j < arrayInt.Length - i - 1; j++)
            {
                if (arrayInt[j] > arrayInt[j + 1])
                {
                    int temp = arrayInt[j];
                    arrayInt[j] = arrayInt[j + 1];
                    arrayInt[j + 1] = temp;
                }
            }
        }
        return arrayInt;
    }
```

### 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

#### 算法原理

首先，假设表中元素是按 `升序排列` ，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

C#的二分查找

```c#
    /**
    * 二分查找算法
    *
    * @param srcArray 有序数组
    * @param des 查找元素
    * @return des的数组下标，没找到返回-1
    */
    public static int BinarySearchMethod(int[] srcArray, int des)
    {
        int low = 0;
        int high = srcArray.Length - 1;
        while (low <= high)
        {
            int middle = (low + high) / 2;
            if (des == srcArray[middle])
            {
                return middle;
            }
            else if (des < srcArray[middle])
            {
                high = middle - 1;
            }
            else
            {
                low = middle + 1;
            }
        }
        return -1;
    }
```

---
> to be continued...
